JQPlugin subclass: #JQEffect	instanceVariableNames: 'method effect speed complete'	classVariableNames: ''	package: 'JQuery-UI-Objects'!JQEffect class	instanceVariableNames: ''!WAFileLibrary subclass: #JQUiDeploymentLibrary	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQUiDeploymentLibrary class	instanceVariableNames: ''!WAFileLibrary subclass: #JQBaseTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQBaseTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQHumanityTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQHumanityTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQCupertinoTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQCupertinoTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQTrontasticTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQTrontasticTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQPepperGrinderTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQPepperGrinderTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQExciteBikeTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQExciteBikeTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQStartTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQStartTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQLeFrogTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQLeFrogTheme class	instanceVariableNames: ''!JQPlugin subclass: #JQWidget	instanceVariableNames: 'action arguments'	classVariableNames: ''	package: 'JQuery-UI-Objects'!JQWidget class	instanceVariableNames: ''!JQWidget subclass: #JQDraggable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQDraggable class	instanceVariableNames: ''!JQWidget subclass: #JQResizable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQResizable class	instanceVariableNames: ''!JQWidget subclass: #JQButton	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQButton class	instanceVariableNames: ''!JQWidget subclass: #JQTabs	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQTabs class	instanceVariableNames: ''!JQWidget subclass: #JQDroppable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQDroppable class	instanceVariableNames: ''!JQBaseTheme subclass: #JQDarkHiveTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQDarkHiveTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQUiDarknessTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQUiDarknessTheme class	instanceVariableNames: ''!JQWidget subclass: #JQSelectable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQSelectable class	instanceVariableNames: ''!JQBaseTheme subclass: #JQRedmondTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQRedmondTheme class	instanceVariableNames: ''!JQWidget subclass: #JQDatepicker	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQDatepicker class	instanceVariableNames: ''!JQBaseTheme subclass: #JQFlickTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQFlickTheme class	instanceVariableNames: ''!WAFileLibrary subclass: #JQUiDevelopmentLibrary	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQUiDevelopmentLibrary class	instanceVariableNames: ''!JQBaseTheme subclass: #JQBlackTieTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQBlackTieTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQSunnyTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQSunnyTheme class	instanceVariableNames: ''!JQWidget subclass: #JQPosition	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Utility'!JQPosition class	instanceVariableNames: ''!JQBaseTheme subclass: #JQMintChocTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQMintChocTheme class	instanceVariableNames: ''!JQWidget subclass: #JQAccordion	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQAccordion class	instanceVariableNames: ''!JQBaseTheme subclass: #JQDotLuvTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQDotLuvTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQUiLightnessTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQUiLightnessTheme class	instanceVariableNames: ''!JQWidget subclass: #JQSlider	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQSlider class	instanceVariableNames: ''!JQBaseTheme subclass: #JQSmoothnessTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQSmoothnessTheme class	instanceVariableNames: ''!JQWidget subclass: #JQDialog	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQDialog class	instanceVariableNames: ''!JQBaseTheme subclass: #JQHotSneaksTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQHotSneaksTheme class	instanceVariableNames: ''!WAFileLibrary subclass: #JQUiGoogleLibrary	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQUiGoogleLibrary class	instanceVariableNames: ''!JQBaseTheme subclass: #JQBlitzerTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQBlitzerTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQSwankyPurseTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQSwankyPurseTheme class	instanceVariableNames: ''!JQWidget subclass: #JQProgressbar	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQProgressbar class	instanceVariableNames: ''!JQBaseTheme subclass: #JQOvercastTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQOvercastTheme class	instanceVariableNames: ''!JQWidget subclass: #JQAutocomplete	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQAutocomplete class	instanceVariableNames: ''!JQBaseTheme subclass: #JQEggplantTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQEggplantTheme class	instanceVariableNames: ''!JQBaseTheme subclass: #JQVaderTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQVaderTheme class	instanceVariableNames: ''!JQWidget subclass: #JQSortable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQSortable class	instanceVariableNames: ''!JQBaseTheme subclass: #JQSouthStreetTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!JQSouthStreetTheme class	instanceVariableNames: ''!JQPlugin subclass: #JQEffect	instanceVariableNames: 'method effect speed complete'	classVariableNames: ''	package: 'JQuery-UI-Objects'!JQEffect comment: 'This is the core dependency of the effects of jQuery UI. This file is needed by all other effects and can also be used as stand-alone. Please note that ui.core.js is not a dependency for the effects to work.'!!JQEffect methodsFor: 'private' stamp: '1/8/2026 11:26:12'!argumentsDo: aBlock	aBlock value: effect.	(options isEmpty and: [ speed isNil and: [ complete isNil ] ])		ifFalse: [ aBlock value: options ].	(speed isNil and: [ complete isNil ])		ifFalse: [ aBlock value: speed ].	(complete isNil)		ifFalse: [ aBlock value: complete ]! !!JQEffect methodsFor: 'private' stamp: '1/8/2026 11:26:12'!method	^ method! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!blind	"Blinds the element away or shows it by blinding it in."		self effect: 'blind'! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!clip	"Clips the element on or off, vertically or horizontally."		self effect: 'clip'! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!drop	"Drops the element away or shows it by dropping it in."		self effect: 'drop'! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!explode	"Explodes the element into multiple pieces."		self effect: 'explode'! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!fade	"Fade the element in and out."		self effect: 'fade'! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!fold	"Folds the element like a piece of paper."		self effect: 'fold'! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!puff	"Scale and fade out animations create the puff effect."		self effect: 'puff'! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!scale	"Shrink or grow an element by a percentage factor."		self effect: 'scale'! !!JQEffect methodsFor: 'effects-toggle' stamp: '1/8/2026 11:26:12'!slide	"Slides the element out of the viewport."		self effect: 'slide'! !!JQEffect methodsFor: 'effects' stamp: '1/8/2026 11:26:12'!bounce	"Bounces the element vertically or horizontally n-times."		self effect: 'bounce'! !!JQEffect methodsFor: 'effects' stamp: '1/8/2026 11:26:12'!highlight	"Highlights the background with a defined color."		self effect: 'highlight'! !!JQEffect methodsFor: 'effects' stamp: '1/8/2026 11:26:12'!pulsate	"Pulsates the opacity of the element multiple times."		self effect: 'pulsate'! !!JQEffect methodsFor: 'effects' stamp: '1/8/2026 11:26:12'!shake	"Shakes the element vertically or horizontally n-times."		self effect: 'shake'! !!JQEffect methodsFor: 'effects' stamp: '1/8/2026 11:26:12'!size	"Resize an element to a specified width and height."		self effect: 'size'! !!JQEffect methodsFor: 'effects' stamp: '1/8/2026 11:26:12'!transfer	"Transfers the outline of an element to another."		self effect: 'transfer'! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!className: aString	"Transfer - Class name the transfer element will receive."	self optionAt: 'className' put: aString! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!color: aColor	"Highlight - The highlight color."	self optionAt: 'color' put: aColor! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!direction: aString	"Blind - vertical or horizontal."	"Clip - vertical or horizontal."	"Drop - left, right, up, down."	"Slide - left, right, up, down."	"Scale - both, vertical, horizontal."	"Bounce - left, right, up, down."	"Shake - left, right, up, down."	self optionAt: 'direction' put: aString! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!distance: anInteger	"Bounce - The bounce distance."	"Shake - The bounce distance."	self optionAt: 'distance' put: anInteger! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!easing: aString	self optionAt: 'easing' put: aString! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!from	^ self options 		at: 'from'		ifAbsentPut: [ GRSmallDictionary2 new ]! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!from: aDictionary	"Transfer - The element from width/height to."		self optionAt: 'from' put: aDictionary! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!origin: anArray	"Scale - the vanishing point."	"Size - the vanishing point."	self optionAt: 'origin' put: anArray! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!percent: anInteger	"Puff - The percentage to scale to."	"Scale - The percentage to scale to."	self optionAt: 'percent' put: anInteger! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!pieces: aNumber	"Explode - Explodes or implodes the element into/from many pieces."	self optionAt: 'pieces' put: aNumber! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!scale: aString	"Scale - Which areas of the element will be resized: 'both', 'box', 'content'."	"Size - Which areas of the element will be resized: 'both', 'box', 'content'."	self optionAt: 'scale' put: aString! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!size: anInteger	"Fold - Size to fold."	self optionAt: 'size' put: anInteger! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!times: anInteger	"Pulsate - Number of times to pulsate."	"Bounce - Number of times to bounce."	"Shake - Number of times to shake."	self optionAt: 'times' put: anInteger! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!to	^ self options 		at: 'to'		ifAbsentPut: [ GRSmallDictionary2 new ]! !!JQEffect methodsFor: 'options' stamp: '1/8/2026 11:26:12'!to: aDictionaryOrString	"Transfer - The element to transfer to."	self optionAt: 'to' put: aDictionaryOrString! !!JQEffect methodsFor: 'methods' stamp: '1/8/2026 11:26:12'!effect	"Uses a specific effect on an element."		self method: 'effect'! !!JQEffect methodsFor: 'methods' stamp: '1/8/2026 11:26:12'!hide	"Uses a specific effect on an element to hide the element if the first argument is an effect string."		self method: 'hide'! !!JQEffect methodsFor: 'methods' stamp: '1/8/2026 11:26:12'!show	"Uses a specific effect on an element to show the element if the first argument is a effect string."		self method: 'show'! !!JQEffect methodsFor: 'methods' stamp: '1/8/2026 11:26:12'!toggle	"Uses a specific effect on an element to toggle the element if the first argument is an effect string."		self method: 'toggle'! !!JQEffect methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!effect: aString	"The effect to be used."		effect := aString! !!JQEffect methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method: aString	"The method to be used."	method := aString! !!JQEffect methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!speed: aDuration	"A string representing one of the three predefined speeds (slow, normal, or fast) or the number of milliseconds to run the animation."		speed := aDuration! !!JQEffect methodsFor: 'accessing-speed' stamp: '1/8/2026 11:26:12'!fast	self speed: 'fast'! !!JQEffect methodsFor: 'accessing-speed' stamp: '1/8/2026 11:26:12'!normal	self speed: 'normal'! !!JQEffect methodsFor: 'accessing-speed' stamp: '1/8/2026 11:26:12'!slow	self speed: 'slow'! !!JQEffect methodsFor: 'convenience' stamp: '1/8/2026 11:26:12'!fromHeight: anInteger	self from at: 'height' put: anInteger! !!JQEffect methodsFor: 'convenience' stamp: '1/8/2026 11:26:12'!fromWidth: anInteger	self from at: 'width' put: anInteger! !!JQEffect methodsFor: 'convenience' stamp: '1/8/2026 11:26:12'!toHeight: anInteger	self to at: 'height' put: anInteger! !!JQEffect methodsFor: 'convenience' stamp: '1/8/2026 11:26:12'!toWidth: anInteger	self to at: 'width' put: anInteger! !!JQEffect methodsFor: 'initialization' stamp: '1/8/2026 11:26:12'!initialize	super initialize.	self effect; highlight; options! !!JQEffect methodsFor: 'events' stamp: '1/8/2026 11:26:12'!onComplete: anObject	"A function to be executed whenever the animation completes, executes once for each element animated against."		complete := anObject asFunction! !WAFileLibrary subclass: #JQUiDeploymentLibrary	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQUiDeploymentLibrary methodsFor: 'uploaded' stamp: '1/8/2026 11:26:12'!jQueryUiJs	<ignoreForCoverage>	^ '/*!! jQuery UI - v1.13.2 - 2022-07-14* http://jqueryui.com* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-patch.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js* Copyright jQuery Foundation and other contributors; Licensed MIT */!!function(t){"use strict";"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)}(function(V){"use strict";V.ui=V.ui||{};V.ui.version="1.13.2";var n,i=0,a=Array.prototype.hasOwnProperty,r=Array.prototype.slice;V.cleanData=(n=V.cleanData,function(t){for(var e,i,s=0;null!!=(i=t[s]);s++)(e=V._data(i,"events"))&&e.remove&&V(i).triggerHandler("remove");n(t)}),V.widget=function(t,i,e){var s,n,o,a={},r=t.split(".")[0],l=r+"-"+(t=t.split(".")[1]);return e||(e=i,i=V.Widget),Array.isArray(e)&&(e=V.extend.apply(null,[{}].concat(e))),V.expr.pseudos[l.toLowerCase()]=function(t){return!!!!V.data(t,l)},V[r]=V[r]||{},s=V[r][t],n=V[r][t]=function(t,e){if(!!this||!!this._createWidget)return new n(t,e);arguments.length&&this._createWidget(t,e)},V.extend(n,s,{version:e.version,_proto:V.extend({},e),_childConstructors:[]}),(o=new i).options=V.widget.extend({},o.options),V.each(e,function(e,s){function n(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}a[e]="function"==typeof s?function(){var t,e=this._super,i=this._superApply;return this._super=n,this._superApply=o,t=s.apply(this,arguments),this._super=e,this._superApply=i,t}:s}),n.prototype=V.widget.extend(o,{widgetEventPrefix:s&&o.widgetEventPrefix||t},a,{constructor:n,namespace:r,widgetName:t,widgetFullName:l}),s?(V.each(s._childConstructors,function(t,e){var i=e.prototype;V.widget(i.namespace+"."+i.widgetName,n,e._proto)}),delete s._childConstructors):i._childConstructors.push(n),V.widget.bridge(t,n),n},V.widget.extend=function(t){for(var e,i,s=r.call(arguments,1),n=0,o=s.length;n<o;n++)for(e in s[n])i=s[n][e],a.call(s[n],e)&&void 0!!==i&&(V.isPlainObject(i)?t[e]=V.isPlainObject(t[e])?V.widget.extend({},t[e],i):V.widget.extend({},i):t[e]=i);return t},V.widget.bridge=function(o,e){var a=e.prototype.widgetFullName||o;V.fn[o]=function(i){var t="string"==typeof i,s=r.call(arguments,1),n=this;return t?this.length||"instance"!!==i?this.each(function(){var t,e=V.data(this,a);return"instance"===i?(n=e,!!1):e?"function"!!=typeof e[i]||"_"===i.charAt(0)?V.error("no such method ''"+i+"'' for "+o+" widget instance"):(t=e[i].apply(e,s))!!==e&&void 0!!==t?(n=t&&t.jquery?n.pushStack(t.get()):t,!!1):void 0:V.error("cannot call methods on "+o+" prior to initialization; attempted to call method ''"+i+"''")}):n=void 0:(s.length&&(i=V.widget.extend.apply(null,[i].concat(s))),this.each(function(){var t=V.data(this,a);t?(t.option(i||{}),t._init&&t._init()):V.data(this,a,new e(i,this))})),n}},V.Widget=function(){},V.Widget._childConstructors=[],V.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!!1,create:null},_createWidget:function(t,e){e=V(e||this.defaultElement||this)[0],this.element=V(e),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=V(),this.hoverable=V(),this.focusable=V(),this.classesElementLookup={},e!!==this&&(V.data(e,this.widgetFullName,this),this._on(!!0,this.element,{remove:function(t){t.target===e&&this.destroy()}}),this.document=V(e.style?e.ownerDocument:e.document||e),this.window=V(this.document[0].defaultView||this.document[0].parentWindow)),this.options=V.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:V.noop,_create:V.noop,_init:V.noop,destroy:function(){var i=this;this._destroy(),V.each(this.classesElementLookup,function(t,e){i._removeClass(e,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:V.noop,widget:function(){return this.element},option:function(t,e){var i,s,n,o=t;if(0===arguments.length)return V.widget.extend({},this.options);if("string"==typeof t)if(o={},t=(i=t.split(".")).shift(),i.length){for(s=o[t]=V.widget.extend({},this.options[t]),n=0;n<i.length-1;n++)s[i[n]]=s[i[n]]||{},s=s[i[n]];if(t=i.pop(),1===arguments.length)return void 0===s[t]?null:s[t];s[t]=e}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=e}return this._setOptions(o),this},_setOptions:function(t){for(var e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(t){var e,i,s;for(e in t)s=this.classesElementLookup[e],t[e]!!==this.options.classes[e]&&s&&s.length&&(i=V(s.get()),this._removeClass(s,e),i.addClass(this._classes({element:i,keys:e,classes:t,add:!!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!!1})},disable:function(){return this._setOptions({disabled:!!0})},_classes:function(n){var o=[],a=this;function t(t,e){for(var i,s=0;s<t.length;s++)i=a.classesElementLookup[t[s]]||V(),i=n.add?(function(){var i=[];n.element.each(function(t,e){V.map(a.classesElementLookup,function(t){return t}).some(function(t){return t.is(e)})||i.push(e)}),a._on(V(i),{remove:"_untrackClassesElement"})}(),V(V.uniqueSort(i.get().concat(n.element.get())))):V(i.not(n.element).get()),a.classesElementLookup[t[s]]=i,o.push(t[s]),e&&n.classes[t[s]]&&o.push(n.classes[t[s]])}return(n=V.extend({element:this.element,classes:this.options.classes||{}},n)).keys&&t(n.keys.match(/\S+/g)||[],!!0),n.extra&&t(n.extra.match(/\S+/g)||[]),o.join(" ")},_untrackClassesElement:function(i){var s=this;V.each(s.classesElementLookup,function(t,e){-1!!==V.inArray(i.target,e)&&(s.classesElementLookup[t]=V(e.not(i.target).get()))}),this._off(V(i.target))},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!!0)},_toggleClass:function(t,e,i,s){var n="string"==typeof t||null===t,i={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s="boolean"==typeof s?s:i};return i.element.toggleClass(this._classes(i),s),this},_on:function(n,o,t){var a,r=this;"boolean"!!=typeof n&&(t=o,o=n,n=!!1),t?(o=a=V(o),this.bindings=this.bindings.add(o)):(t=o,o=this.element,a=this.widget()),V.each(t,function(t,e){function i(){if(n||!!0!!==r.options.disabled&&!!V(this).hasClass("ui-state-disabled"))return("string"==typeof e?r[e]:e).apply(r,arguments)}"string"!!=typeof e&&(i.guid=e.guid=e.guid||i.guid||V.guid++);var s=t.match(/^([\w:-]*)\s*(.*)$/),t=s[1]+r.eventNamespace,s=s[2];s?a.on(t,s,i):o.on(t,i)})},_off:function(t,e){e=(e||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.off(e),this.bindings=V(this.bindings.not(t).get()),this.focusable=V(this.focusable.not(t).get()),this.hoverable=V(this.hoverable.not(t).get())},_delay:function(t,e){var i=this;return setTimeout(function(){return("string"==typeof t?i[t]:t).apply(i,arguments)},e||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){this._addClass(V(t.currentTarget),null,"ui-state-hover")},mouseleave:function(t){this._removeClass(V(t.currentTarget),null,"ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){this._addClass(V(t.currentTarget),null,"ui-state-focus")},focusout:function(t){this._removeClass(V(t.currentTarget),null,"ui-state-focus")}})},_trigger:function(t,e,i){var s,n,o=this.options[t];if(i=i||{},(e=V.Event(e)).type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),e.target=this.element[0],n=e.originalEvent)for(s in n)s in e||(e[s]=n[s]);return this.element.trigger(e,i),!!("function"==typeof o&&!!1===o.apply(this.element[0],[e].concat(i))||e.isDefaultPrevented())}},V.each({show:"fadeIn",hide:"fadeOut"},function(o,a){V.Widget.prototype["_"+o]=function(e,t,i){var s,n=(t="string"==typeof t?{effect:t}:t)?!!0!!==t&&"number"!!=typeof t&&t.effect||a:o;"number"==typeof(t=t||{})?t={duration:t}:!!0===t&&(t={}),s=!!V.isEmptyObject(t),t.complete=i,t.delay&&e.delay(t.delay),s&&V.effects&&V.effects.effect[n]?e[o](t):n!!==o&&e[n]?e[n](t.duration,t.easing,i):e.queue(function(t){V(this)[o](),i&&i.call(e[0]),t()})}});var s,x,k,o,l,h,c,u,C;V.widget;function D(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function I(t,e){return parseInt(V.css(t,e),10)||0}function T(t){return null!!=t&&t===t.window}x=Math.max,k=Math.abs,o=/left|center|right/,l=/top|center|bottom/,h=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,C=V.fn.position,V.position={scrollbarWidth:function(){if(void 0!!==s)return s;var t,e=V("<div style=''display:block;position:absolute;width:200px;height:200px;overflow:hidden;''><div style=''height:300px;width:auto;''></div></div>"),i=e.children()[0];return V("body").append(e),t=i.offsetWidth,e.css("overflow","scroll"),t===(i=i.offsetWidth)&&(i=e[0].clientWidth),e.remove(),s=t-i},getScrollInfo:function(t){var e=t.isWindow||t.isDocument?"":t.element.css("overflow-x"),i=t.isWindow||t.isDocument?"":t.element.css("overflow-y"),e="scroll"===e||"auto"===e&&t.width<t.element[0].scrollWidth;return{width:"scroll"===i||"auto"===i&&t.height<t.element[0].scrollHeight?V.position.scrollbarWidth():0,height:e?V.position.scrollbarWidth():0}},getWithinInfo:function(t){var e=V(t||window),i=T(e[0]),s=!!!!e[0]&&9===e[0].nodeType;return{element:e,isWindow:i,isDocument:s,offset:!!i&&!!s?V(t).offset():{left:0,top:0},scrollLeft:e.scrollLeft(),scrollTop:e.scrollTop(),width:e.outerWidth(),height:e.outerHeight()}}},V.fn.position=function(u){if(!!u||!!u.of)return C.apply(this,arguments);var d,p,f,g,m,t,_="string"==typeof(u=V.extend({},u)).of?V(document).find(u.of):V(u.of),v=V.position.getWithinInfo(u.within),b=V.position.getScrollInfo(v),y=(u.collision||"flip").split(" "),w={},e=9===(t=(e=_)[0]).nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:T(t)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:t.preventDefault?{width:0,height:0,offset:{top:t.pageY,left:t.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()};return _[0].preventDefault&&(u.at="left top"),p=e.width,f=e.height,m=V.extend({},g=e.offset),V.each(["my","at"],function(){var t,e,i=(u[this]||"").split(" ");(i=1===i.length?o.test(i[0])?i.concat(["center"]):l.test(i[0])?["center"].concat(i):["center","center"]:i)[0]=o.test(i[0])?i[0]:"center",i[1]=l.test(i[1])?i[1]:"center",t=h.exec(i[0]),e=h.exec(i[1]),w[this]=[t?t[0]:0,e?e[0]:0],u[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===y.length&&(y[1]=y[0]),"right"===u.at[0]?m.left+=p:"center"===u.at[0]&&(m.left+=p/2),"bottom"===u.at[1]?m.top+=f:"center"===u.at[1]&&(m.top+=f/2),d=D(w.at,p,f),m.left+=d[0],m.top+=d[1],this.each(function(){var i,t,a=V(this),r=a.outerWidth(),l=a.outerHeight(),e=I(this,"marginLeft"),s=I(this,"marginTop"),n=r+e+I(this,"marginRight")+b.width,o=l+s+I(this,"marginBottom")+b.height,h=V.extend({},m),c=D(w.my,a.outerWidth(),a.outerHeight());"right"===u.my[0]?h.left-=r:"center"===u.my[0]&&(h.left-=r/2),"bottom"===u.my[1]?h.top-=l:"center"===u.my[1]&&(h.top-=l/2),h.left+=c[0],h.top+=c[1],i={marginLeft:e,marginTop:s},V.each(["left","top"],function(t,e){V.ui.position[y[t]]&&V.ui.position[y[t]][e](h,{targetWidth:p,targetHeight:f,elemWidth:r,elemHeight:l,collisionPosition:i,collisionWidth:n,collisionHeight:o,offset:[d[0]+c[0],d[1]+c[1]],my:u.my,at:u.at,within:v,elem:a})}),u.using&&(t=function(t){var e=g.left-h.left,i=e+p-r,s=g.top-h.top,n=s+f-l,o={target:{element:_,left:g.left,top:g.top,width:p,height:f},element:{element:a,left:h.left,top:h.top,width:r,height:l},horizontal:i<0?"left":0<e?"right":"center",vertical:n<0?"top":0<s?"bottom":"middle"};p<r&&k(e+i)<p&&(o.horizontal="center"),f<l&&k(s+n)<f&&(o.vertical="middle"),x(k(e),k(i))>x(k(s),k(n))?o.important="horizontal":o.important="vertical",u.using.call(this,t,o)}),a.offset(V.extend(h,{using:t}))})},V.ui.position={fit:{left:function(t,e){var i=e.within,s=i.isWindow?i.scrollLeft:i.offset.left,n=i.width,o=t.left-e.collisionPosition.marginLeft,a=s-o,r=o+e.collisionWidth-n-s;e.collisionWidth>n?0<a&&r<=0?(i=t.left+a+e.collisionWidth-n-s,t.left+=a-i):t.left=!!(0<r&&a<=0)&&r<a?s+n-e.collisionWidth:s:0<a?t.left+=a:0<r?t.left-=r:t.left=x(t.left-o,t.left)},top:function(t,e){var i=e.within,s=i.isWindow?i.scrollTop:i.offset.top,n=e.within.height,o=t.top-e.collisionPosition.marginTop,a=s-o,r=o+e.collisionHeight-n-s;e.collisionHeight>n?0<a&&r<=0?(i=t.top+a+e.collisionHeight-n-s,t.top+=a-i):t.top=!!(0<r&&a<=0)&&r<a?s+n-e.collisionHeight:s:0<a?t.top+=a:0<r?t.top-=r:t.top=x(t.top-o,t.top)}},flip:{left:function(t,e){var i=e.within,s=i.offset.left+i.scrollLeft,n=i.width,o=i.isWindow?i.scrollLeft:i.offset.left,a=t.left-e.collisionPosition.marginLeft,r=a-o,l=a+e.collisionWidth-n-o,h="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,i="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,a=-2*e.offset[0];r<0?((s=t.left+h+i+a+e.collisionWidth-n-s)<0||s<k(r))&&(t.left+=h+i+a):0<l&&(0<(o=t.left-e.collisionPosition.marginLeft+h+i+a-o)||k(o)<l)&&(t.left+=h+i+a)},top:function(t,e){var i=e.within,s=i.offset.top+i.scrollTop,n=i.height,o=i.isWindow?i.scrollTop:i.offset.top,a=t.top-e.collisionPosition.marginTop,r=a-o,l=a+e.collisionHeight-n-o,h="top"===e.my[1]?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,i="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,a=-2*e.offset[1];r<0?((s=t.top+h+i+a+e.collisionHeight-n-s)<0||s<k(r))&&(t.top+=h+i+a):0<l&&(0<(o=t.top-e.collisionPosition.marginTop+h+i+a-o)||k(o)<l)&&(t.top+=h+i+a)}},flipfit:{left:function(){V.ui.position.flip.left.apply(this,arguments),V.ui.position.fit.left.apply(this,arguments)},top:function(){V.ui.position.flip.top.apply(this,arguments),V.ui.position.fit.top.apply(this,arguments)}}};V.ui.position,V.extend(V.expr.pseudos,{data:V.expr.createPseudo?V.expr.createPseudo(function(e){return function(t){return!!!!V.data(t,e)}}):function(t,e,i){return!!!!V.data(t,i[3])}}),V.fn.extend({disableSelection:(t="onselectstart"in document.createElement("div")?"selectstart":"mousedown",function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}),enableSelection:function(){return this.off(".ui-disableSelection")}});var t,d=V,p={},e=p.toString,f=/^([\-+])=\s*(\d+\.?\d*)/,g=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16),t[4]?(parseInt(t[4],16)/255).toFixed(2):1]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16),t[4]?(parseInt(t[4]+t[4],16)/255).toFixed(2):1]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],m=d.Color=function(t,e,i,s){return new d.Color.fn.parse(t,e,i,s)},_={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},v={byte:{floor:!!0,max:255},percent:{max:1},degrees:{mod:360,floor:!!0}},b=m.support={},y=d("<p>")[0],w=d.each;function P(t){return null==t?t+"":"object"==typeof t?p[e.call(t)]||"object":typeof t}function M(t,e,i){var s=v[e.type]||{};return null==t?i||!!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:Math.min(s.max,Math.max(0,t)))}function S(s){var n=m(),o=n._rgba=[];return s=s.toLowerCase(),w(g,function(t,e){var i=e.re.exec(s),i=i&&e.parse(i),e=e.space||"rgba";if(i)return i=n[e](i),n[_[e].cache]=i[_[e].cache],o=n._rgba=i._rgba,!!1}),o.length?("0,0,0,0"===o.join()&&d.extend(o,B.transparent),n):B[s]}function H(t,e,i){return 6*(i=(i+1)%1)<1?t+(e-t)*i*6:2*i<1?e:3*i<2?t+(e-t)*(2/3-i)*6:t}y.style.cssText="background-color:rgba(1,1,1,.5)",b.rgba=-1<y.style.backgroundColor.indexOf("rgba"),w(_,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),d.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(t,e){p["[object "+e+"]"]=e.toLowerCase()}),(m.fn=d.extend(m.prototype,{parse:function(n,t,e,i){if(void 0===n)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=d(n).css(t),t=void 0);var o=this,s=P(n),a=this._rgba=[];return void 0!!==t&&(n=[n,t,e,i],s="array"),"string"===s?this.parse(S(n)||B._default):"array"===s?(w(_.rgba.props,function(t,e){a[e.idx]=M(n[e.idx],e)}),this):"object"===s?(w(_,n instanceof m?function(t,e){n[e.cache]&&(o[e.cache]=n[e.cache].slice())}:function(t,i){var s=i.cache;w(i.props,function(t,e){if(!!o[s]&&i.to){if("alpha"===t||null==n[t])return;o[s]=i.to(o._rgba)}o[s][e.idx]=M(n[t],e,!!0)}),o[s]&&d.inArray(null,o[s].slice(0,3))<0&&(null==o[s][3]&&(o[s][3]=1),i.from&&(o._rgba=i.from(o[s])))}),this):void 0},is:function(t){var n=m(t),o=!!0,a=this;return w(_,function(t,e){var i,s=n[e.cache];return s&&(i=a[e.cache]||e.to&&e.to(a._rgba)||[],w(e.props,function(t,e){if(null!!=s[e.idx])return o=s[e.idx]===i[e.idx]})),o}),o},_space:function(){var i=[],s=this;return w(_,function(t,e){s[e.cache]&&i.push(t)}),i.pop()},transition:function(t,a){var e=(h=m(t))._space(),i=_[e],t=0===this.alpha()?m("transparent"):this,r=t[i.cache]||i.to(t._rgba),l=r.slice(),h=h[i.cache];return w(i.props,function(t,e){var i=e.idx,s=r[i],n=h[i],o=v[e.type]||{};null!!==n&&(null===s?l[i]=n:(o.mod&&(n-s>o.mod/2?s+=o.mod:s-n>o.mod/2&&(s-=o.mod)),l[i]=M((n-s)*a+s,e)))}),this[e](l)},blend:function(t){if(1===this._rgba[3])return this;var e=this._rgba.slice(),i=e.pop(),s=m(t)._rgba;return m(d.map(e,function(t,e){return(1-i)*s[e]+i*t}))},toRgbaString:function(){var t="rgba(",e=d.map(this._rgba,function(t,e){return null!!=t?t:2<e?1:0});return 1===e[3]&&(e.pop(),t="rgb("),t+e.join()+")"},toHslaString:function(){var t="hsla(",e=d.map(this.hsla(),function(t,e){return null==t&&(t=2<e?1:0),t=e&&e<3?Math.round(100*t)+"%":t});return 1===e[3]&&(e.pop(),t="hsl("),t+e.join()+")"},toHexString:function(t){var e=this._rgba.slice(),i=e.pop();return t&&e.push(~~(255*i)),"#"+d.map(e,function(t){return 1===(t=(t||0).toString(16)).length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}})).parse.prototype=m.fn,_.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/255,i=t[1]/255,s=t[2]/255,n=t[3],o=Math.max(e,i,s),a=Math.min(e,i,s),r=o-a,l=o+a,t=.5*l,i=a===o?0:e===o?60*(i-s)/r+360:i===o?60*(s-e)/r+120:60*(e-i)/r+240,l=0==r?0:t<=.5?r/l:r/(2-l);return[Math.round(i)%360,l,t,null==n?1:n]},_.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],t=t[3],i=s<=.5?s*(1+i):s+i-s*i,s=2*s-i;return[Math.round(255*H(s,i,e+1/3)),Math.round(255*H(s,i,e)),Math.round(255*H(s,i,e-1/3)),t]},w(_,function(l,t){var e=t.props,o=t.cache,a=t.to,r=t.from;m.fn[l]=function(t){if(a&&!!this[o]&&(this[o]=a(this._rgba)),void 0===t)return this[o].slice();var i=P(t),s="array"===i||"object"===i?t:arguments,n=this[o].slice();return w(e,function(t,e){t=s["object"===i?t:e.idx];null==t&&(t=n[e.idx]),n[e.idx]=M(t,e)}),r?((t=m(r(n)))[o]=n,t):m(n)},w(e,function(a,r){m.fn[a]||(m.fn[a]=function(t){var e,i=P(t),s="alpha"===a?this._hsla?"hsla":"rgba":l,n=this[s](),o=n[r.idx];return"undefined"===i?o:("function"===i&&(i=P(t=t.call(this,o))),null==t&&r.empty?this:("string"===i&&(e=f.exec(t))&&(t=o+parseFloat(e[2])*("+"===e[1]?1:-1)),n[r.idx]=t,this[s](n)))})})}),(m.hook=function(t){t=t.split(" ");w(t,function(t,o){d.cssHooks[o]={set:function(t,e){var i,s,n="";if("transparent"!!==e&&("string"!!==P(e)||(i=S(e)))){if(e=m(i||e),!!b.rgba&&1!!==e._rgba[3]){for(s="backgroundColor"===o?t.parentNode:t;(""===n||"transparent"===n)&&s&&s.style;)try{n=d.css(s,"backgroundColor"),s=s.parentNode}catch(t){}e=e.blend(n&&"transparent"!!==n?n:"_default")}e=e.toRgbaString()}try{t.style[o]=e}catch(t){}}},d.fx.step[o]=function(t){t.colorInit||(t.start=m(t.elem,o),t.end=m(t.end),t.colorInit=!!0),d.cssHooks[o].set(t.elem,t.start.transition(t.end,t.pos))}})})("backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor"),d.cssHooks.borderColor={expand:function(i){var s={};return w(["Top","Right","Bottom","Left"],function(t,e){s["border"+e+"Color"]=i}),s}};var z,A,O,N,E,W,F,L,R,Y,B=d.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"},j="ui-effects-",q="ui-effects-style",K="ui-effects-animated";function U(t){var e,i,s=t.ownerDocument.defaultView?t.ownerDocument.defaultView.getComputedStyle(t,null):t.currentStyle,n={};if(s&&s.length&&s[0]&&s[s[0]])for(i=s.length;i--;)"string"==typeof s[e=s[i]]&&(n[e.replace(/-([\da-z])/gi,function(t,e){return e.toUpperCase()})]=s[e]);else for(e in s)"string"==typeof s[e]&&(n[e]=s[e]);return n}function X(t,e,i,s){return t={effect:t=V.isPlainObject(t)?(e=t).effect:t},"function"==typeof(e=null==e?{}:e)&&(s=e,i=null,e={}),"number"!!=typeof e&&!!V.fx.speeds[e]||(s=i,i=e,e={}),"function"==typeof i&&(s=i,i=null),e&&V.extend(t,e),i=i||e.duration,t.duration=V.fx.off?0:"number"==typeof i?i:i in V.fx.speeds?V.fx.speeds[i]:V.fx.speeds._default,t.complete=s||e.complete,t}function $(t){return!!t||"number"==typeof t||V.fx.speeds[t]||("string"==typeof t&&!!V.effects.effect[t]||("function"==typeof t||"object"==typeof t&&!!t.effect))}function G(t,e){var i=e.outerWidth(),e=e.outerHeight(),t=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/.exec(t)||["",0,i,e,0];return{top:parseFloat(t[1])||0,right:"auto"===t[2]?i:parseFloat(t[2]),bottom:"auto"===t[3]?e:parseFloat(t[3]),left:parseFloat(t[4])||0}}V.effects={effect:{}},N=["add","remove","toggle"],E={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1},V.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(t,e){V.fx.step[e]=function(t){("none"!!==t.end&&!!t.setAttr||1===t.pos&&!!t.setAttr)&&(d.style(t.elem,e,t.end),t.setAttr=!!0)}}),V.fn.addBack||(V.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),V.effects.animateClass=function(n,t,e,i){var o=V.speed(t,e,i);return this.queue(function(){var i=V(this),t=i.attr("class")||"",e=(e=o.children?i.find("*").addBack():i).map(function(){return{el:V(this),start:U(this)}}),s=function(){V.each(N,function(t,e){n[e]&&i[e+"Class"](n[e])})};s(),e=e.map(function(){return this.end=U(this.el[0]),this.diff=function(t,e){var i,s,n={};for(i in e)s=e[i],t[i]!!==s&&(E[i]||!!V.fx.step[i]&&isNaN(parseFloat(s))||(n[i]=s));return n}(this.start,this.end),this}),i.attr("class",t),e=e.map(function(){var t=this,e=V.Deferred(),i=V.extend({},o,{queue:!!1,complete:function(){e.resolve(t)}});return this.el.animate(this.diff,i),e.promise()}),V.when.apply(V,e.get()).done(function(){s(),V.each(arguments,function(){var e=this.el;V.each(this.diff,function(t){e.css(t,"")})}),o.complete.call(i[0])})})},V.fn.extend({addClass:(O=V.fn.addClass,function(t,e,i,s){return e?V.effects.animateClass.call(this,{add:t},e,i,s):O.apply(this,arguments)}),removeClass:(A=V.fn.removeClass,function(t,e,i,s){return 1<arguments.length?V.effects.animateClass.call(this,{remove:t},e,i,s):A.apply(this,arguments)}),toggleClass:(z=V.fn.toggleClass,function(t,e,i,s,n){return"boolean"==typeof e||void 0===e?i?V.effects.animateClass.call(this,e?{add:t}:{remove:t},i,s,n):z.apply(this,arguments):V.effects.animateClass.call(this,{toggle:t},e,i,s)}),switchClass:function(t,e,i,s,n){return V.effects.animateClass.call(this,{add:e,remove:t},i,s,n)}}),V.expr&&V.expr.pseudos&&V.expr.pseudos.animated&&(V.expr.pseudos.animated=(W=V.expr.pseudos.animated,function(t){return!!!!V(t).data(K)||W(t)})),!!1!!==V.uiBackCompat&&V.extend(V.effects,{save:function(t,e){for(var i=0,s=e.length;i<s;i++)null!!==e[i]&&t.data(j+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;s<n;s++)null!!==e[s]&&(i=t.data(j+e[s]),t.css(e[s],i))},setMode:function(t,e){return e="toggle"===e?t.is(":hidden")?"show":"hide":e},createWrapper:function(i){if(i.parent().is(".ui-effects-wrapper"))return i.parent();var s={width:i.outerWidth(!!0),height:i.outerHeight(!!0),float:i.css("float")},t=V("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),e={width:i.width(),height:i.height()},n=document.activeElement;try{n.id}catch(t){n=document.body}return i.wrap(t),i[0]!!==n&&!!V.contains(i[0],n)||V(n).trigger("focus"),t=i.parent(),"static"===i.css("position")?(t.css({position:"relative"}),i.css({position:"relative"})):(V.extend(s,{position:i.css("position"),zIndex:i.css("z-index")}),V.each(["top","left","bottom","right"],function(t,e){s[e]=i.css(e),isNaN(parseInt(s[e],10))&&(s[e]="auto")}),i.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),i.css(e),t.css(s).show()},removeWrapper:function(t){var e=document.activeElement;return t.parent().is(".ui-effects-wrapper")&&(t.parent().replaceWith(t),t[0]!!==e&&!!V.contains(t[0],e)||V(e).trigger("focus")),t}}),V.extend(V.effects,{version:"1.13.2",define:function(t,e,i){return i||(i=e,e="effect"),V.effects.effect[t]=i,V.effects.effect[t].mode=e,i},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!!==i?(e||100)/100:1,e="vertical"!!==i?(e||100)/100:1;return{height:t.height()*e,width:t.width()*s,outerHeight:t.outerHeight()*e,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();1<e&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(q,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(q)||"",t.removeData(q)},mode:function(t,e){t=t.is(":hidden");return"toggle"===e&&(e=t?"show":"hide"),e=(t?"hide"===e:"show"===e)?"none":e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(t){var e,i=t.css("position"),s=t.position();return t.css({marginTop:t.css("marginTop"),marginBottom:t.css("marginBottom"),marginLeft:t.css("marginLeft"),marginRight:t.css("marginRight")}).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()),/^(static|relative)/.test(i)&&(i="absolute",e=V("<"+t[0].nodeName+">").insertAfter(t).css({display:/^(inline|ruby)/.test(t.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:t.css("marginTop"),marginBottom:t.css("marginBottom"),marginLeft:t.css("marginLeft"),marginRight:t.css("marginRight"),float:t.css("float")}).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).addClass("ui-effects-placeholder"),t.data(j+"placeholder",e)),t.css({position:i,left:s.left,top:s.top}),e},removePlaceholder:function(t){var e=j+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(t){V.effects.restoreStyle(t),V.effects.removePlaceholder(t)},setTransition:function(s,t,n,o){return o=o||{},V.each(t,function(t,e){var i=s.cssUnit(e);0<i[0]&&(o[e]=i[0]*n+i[1])}),o}}),V.fn.extend({effect:function(){function t(t){var e=V(this),i=V.effects.mode(e,r)||o;e.data(K,!!0),l.push(i),o&&("show"===i||i===o&&"hide"===i)&&e.show(),o&&"none"===i||V.effects.saveStyle(e),"function"==typeof t&&t()}var s=X.apply(this,arguments),n=V.effects.effect[s.effect],o=n.mode,e=s.queue,i=e||"fx",a=s.complete,r=s.mode,l=[];return V.fx.off||!!n?r?this[r](s.duration,a):this.each(function(){a&&a.call(this)}):!!1===e?this.each(t).each(h):this.queue(i,t).queue(i,h);function h(t){var e=V(this);function i(){"function"==typeof a&&a.call(e[0]),"function"==typeof t&&t()}s.mode=l.shift(),!!1===V.uiBackCompat||o?"none"===s.mode?(e[r](),i()):n.call(e[0],s,function(){e.removeData(K),V.effects.cleanUp(e),"hide"===s.mode&&e.hide(),i()}):(e.is(":hidden")?"hide"===r:"show"===r)?(e[r](),i()):n.call(e[0],s,i)}},show:(R=V.fn.show,function(t){if($(t))return R.apply(this,arguments);t=X.apply(this,arguments);return t.mode="show",this.effect.call(this,t)}),hide:(L=V.fn.hide,function(t){if($(t))return L.apply(this,arguments);t=X.apply(this,arguments);return t.mode="hide",this.effect.call(this,t)}),toggle:(F=V.fn.toggle,function(t){if($(t)||"boolean"==typeof t)return F.apply(this,arguments);t=X.apply(this,arguments);return t.mode="toggle",this.effect.call(this,t)}),cssUnit:function(t){var i=this.css(t),s=[];return V.each(["em","px","%","pt"],function(t,e){0<i.indexOf(e)&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):G(this.css("clip"),this)},transfer:function(t,e){var i=V(this),s=V(t.to),n="fixed"===s.css("position"),o=V("body"),a=n?o.scrollTop():0,r=n?o.scrollLeft():0,o=s.offset(),o={top:o.top-a,left:o.left-r,height:s.innerHeight(),width:s.innerWidth()},s=i.offset(),l=V("<div class=''ui-effects-transfer''></div>");l.appendTo("body").addClass(t.className).css({top:s.top-a,left:s.left-r,height:i.innerHeight(),width:i.innerWidth(),position:n?"fixed":"absolute"}).animate(o,t.duration,t.easing,function(){l.remove(),"function"==typeof e&&e()})}}),V.fx.step.clip=function(t){t.clipInit||(t.start=V(t.elem).cssClip(),"string"==typeof t.end&&(t.end=G(t.end,t.elem)),t.clipInit=!!0),V(t.elem).cssClip({top:t.pos*(t.end.top-t.start.top)+t.start.top,right:t.pos*(t.end.right-t.start.right)+t.start.right,bottom:t.pos*(t.end.bottom-t.start.bottom)+t.start.bottom,left:t.pos*(t.end.left-t.start.left)+t.start.left})},Y={},V.each(["Quad","Cubic","Quart","Quint","Expo"],function(e,t){Y[t]=function(t){return Math.pow(t,e+2)}}),V.extend(Y,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;t<((e=Math.pow(2,--i))-1)/11;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),V.each(Y,function(t,e){V.easing["easeIn"+t]=e,V.easing["easeOut"+t]=function(t){return 1-e(1-t)},V.easing["easeInOut"+t]=function(t){return t<.5?e(2*t)/2:1-e(-2*t+2)/2}});y=V.effects,V.effects.define("blind","hide",function(t,e){var i={up:["bottom","top"],vertical:["bottom","top"],down:["top","bottom"],left:["right","left"],horizontal:["right","left"],right:["left","right"]},s=V(this),n=t.direction||"up",o=s.cssClip(),a={clip:V.extend({},o)},r=V.effects.createPlaceholder(s);a.clip[i[n][0]]=a.clip[i[n][1]],"show"===t.mode&&(s.cssClip(a.clip),r&&r.css(V.effects.clipToBox(a)),a.clip=o),r&&r.animate(V.effects.clipToBox(a),t.duration,t.easing),s.animate(a,{queue:!!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("bounce",function(t,e){var i,s,n=V(this),o=t.mode,a="hide"===o,r="show"===o,l=t.direction||"up",h=t.distance,c=t.times||5,o=2*c+(r||a?1:0),u=t.duration/o,d=t.easing,p="up"===l||"down"===l?"top":"left",f="up"===l||"left"===l,g=0,t=n.queue().length;for(V.effects.createPlaceholder(n),l=n.css(p),h=h||n["top"==p?"outerHeight":"outerWidth"]()/3,r&&((s={opacity:1})[p]=l,n.css("opacity",0).css(p,f?2*-h:2*h).animate(s,u,d)),a&&(h/=Math.pow(2,c-1)),(s={})[p]=l;g<c;g++)(i={})[p]=(f?"-=":"+=")+h,n.animate(i,u,d).animate(s,u,d),h=a?2*h:h/2;a&&((i={opacity:0})[p]=(f?"-=":"+=")+h,n.animate(i,u,d)),n.queue(e),V.effects.unshift(n,t,1+o)}),V.effects.define("clip","hide",function(t,e){var i={},s=V(this),n=t.direction||"vertical",o="both"===n,a=o||"horizontal"===n,o=o||"vertical"===n,n=s.cssClip();i.clip={top:o?(n.bottom-n.top)/2:n.top,right:a?(n.right-n.left)/2:n.right,bottom:o?(n.bottom-n.top)/2:n.bottom,left:a?(n.right-n.left)/2:n.left},V.effects.createPlaceholder(s),"show"===t.mode&&(s.cssClip(i.clip),i.clip=n),s.animate(i,{queue:!!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("drop","hide",function(t,e){var i=V(this),s="show"===t.mode,n=t.direction||"left",o="up"===n||"down"===n?"top":"left",a="up"===n||"left"===n?"-=":"+=",r="+="==a?"-=":"+=",l={opacity:0};V.effects.createPlaceholder(i),n=t.distance||i["top"==o?"outerHeight":"outerWidth"](!!0)/2,l[o]=a+n,s&&(i.css(l),l[o]=r+n,l.opacity=1),i.animate(l,{queue:!!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("explode","hide",function(t,e){var i,s,n,o,a,r,l=t.pieces?Math.round(Math.sqrt(t.pieces)):3,h=l,c=V(this),u="show"===t.mode,d=c.show().css("visibility","hidden").offset(),p=Math.ceil(c.outerWidth()/h),f=Math.ceil(c.outerHeight()/l),g=[];function m(){g.push(this),g.length===l*h&&(c.css({visibility:"visible"}),V(g).remove(),e())}for(i=0;i<l;i++)for(o=d.top+i*f,r=i-(l-1)/2,s=0;s<h;s++)n=d.left+s*p,a=s-(h-1)/2,c.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-s*p,top:-i*f}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:p,height:f,left:n+(u?a*p:0),top:o+(u?r*f:0),opacity:u?0:1}).animate({left:n+(u?0:a*p),top:o+(u?0:r*f),opacity:u?1:0},t.duration||500,t.easing,m)}),V.effects.define("fade","toggle",function(t,e){var i="show"===t.mode;V(this).css("opacity",i?0:1).animate({opacity:i?1:0},{queue:!!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("fold","hide",function(e,t){var i=V(this),s=e.mode,n="show"===s,o="hide"===s,a=e.size||15,r=/([0-9]+)%/.exec(a),l=!!!!e.horizFirst?["right","bottom"]:["bottom","right"],h=e.duration/2,c=V.effects.createPlaceholder(i),u=i.cssClip(),d={clip:V.extend({},u)},p={clip:V.extend({},u)},f=[u[l[0]],u[l[1]]],s=i.queue().length;r&&(a=parseInt(r[1],10)/100*f[o?0:1]),d.clip[l[0]]=a,p.clip[l[0]]=a,p.clip[l[1]]=0,n&&(i.cssClip(p.clip),c&&c.css(V.effects.clipToBox(p)),p.clip=u),i.queue(function(t){c&&c.animate(V.effects.clipToBox(d),h,e.easing).animate(V.effects.clipToBox(p),h,e.easing),t()}).animate(d,h,e.easing).animate(p,h,e.easing).queue(t),V.effects.unshift(i,s,4)}),V.effects.define("highlight","show",function(t,e){var i=V(this),s={backgroundColor:i.css("backgroundColor")};"hide"===t.mode&&(s.opacity=0),V.effects.saveStyle(i),i.css({backgroundImage:"none",backgroundColor:t.color||"#ffff99"}).animate(s,{queue:!!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("size",function(s,e){var n,i=V(this),t=["fontSize"],o=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],a=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],r=s.mode,l="effect"!!==r,h=s.scale||"both",c=s.origin||["middle","center"],u=i.css("position"),d=i.position(),p=V.effects.scaledDimensions(i),f=s.from||p,g=s.to||V.effects.scaledDimensions(i,0);V.effects.createPlaceholder(i),"show"===r&&(r=f,f=g,g=r),n={from:{y:f.height/p.height,x:f.width/p.width},to:{y:g.height/p.height,x:g.width/p.width}},"box"!!==h&&"both"!!==h||(n.from.y!!==n.to.y&&(f=V.effects.setTransition(i,o,n.from.y,f),g=V.effects.setTransition(i,o,n.to.y,g)),n.from.x!!==n.to.x&&(f=V.effects.setTransition(i,a,n.from.x,f),g=V.effects.setTransition(i,a,n.to.x,g))),"content"!!==h&&"both"!!==h||n.from.y!!==n.to.y&&(f=V.effects.setTransition(i,t,n.from.y,f),g=V.effects.setTransition(i,t,n.to.y,g)),c&&(c=V.effects.getBaseline(c,p),f.top=(p.outerHeight-f.outerHeight)*c.y+d.top,f.left=(p.outerWidth-f.outerWidth)*c.x+d.left,g.top=(p.outerHeight-g.outerHeight)*c.y+d.top,g.left=(p.outerWidth-g.outerWidth)*c.x+d.left),delete f.outerHeight,delete f.outerWidth,i.css(f),"content"!!==h&&"both"!!==h||(o=o.concat(["marginTop","marginBottom"]).concat(t),a=a.concat(["marginLeft","marginRight"]),i.find("*[width]").each(function(){var t=V(this),e=V.effects.scaledDimensions(t),i={height:e.height*n.from.y,width:e.width*n.from.x,outerHeight:e.outerHeight*n.from.y,outerWidth:e.outerWidth*n.from.x},e={height:e.height*n.to.y,width:e.width*n.to.x,outerHeight:e.height*n.to.y,outerWidth:e.width*n.to.x};n.from.y!!==n.to.y&&(i=V.effects.setTransition(t,o,n.from.y,i),e=V.effects.setTransition(t,o,n.to.y,e)),n.from.x!!==n.to.x&&(i=V.effects.setTransition(t,a,n.from.x,i),e=V.effects.setTransition(t,a,n.to.x,e)),l&&V.effects.saveStyle(t),t.css(i),t.animate(e,s.duration,s.easing,function(){l&&V.effects.restoreStyle(t)})})),i.animate(g,{queue:!!1,duration:s.duration,easing:s.easing,complete:function(){var t=i.offset();0===g.opacity&&i.css("opacity",f.opacity),l||(i.css("position","static"===u?"relative":u).offset(t),V.effects.saveStyle(i)),e()}})}),V.effects.define("scale",function(t,e){var i=V(this),s=t.mode,s=parseInt(t.percent,10)||(0===parseInt(t.percent,10)||"effect"!!==s?0:100),s=V.extend(!!0,{from:V.effects.scaledDimensions(i),to:V.effects.scaledDimensions(i,s,t.direction||"both"),origin:t.origin||["middle","center"]},t);t.fade&&(s.from.opacity=1,s.to.opacity=0),V.effects.effect.size.call(this,s,e)}),V.effects.define("puff","hide",function(t,e){t=V.extend(!!0,{},t,{fade:!!0,percent:parseInt(t.percent,10)||150});V.effects.effect.scale.call(this,t,e)}),V.effects.define("pulsate","show",function(t,e){var i=V(this),s=t.mode,n="show"===s,o=2*(t.times||5)+(n||"hide"===s?1:0),a=t.duration/o,r=0,l=1,s=i.queue().length;for(!!n&&i.is(":visible")||(i.css("opacity",0).show(),r=1);l<o;l++)i.animate({opacity:r},a,t.easing),r=1-r;i.animate({opacity:r},a,t.easing),i.queue(e),V.effects.unshift(i,s,1+o)}),V.effects.define("shake",function(t,e){var i=1,s=V(this),n=t.direction||"left",o=t.distance||20,a=t.times||3,r=2*a+1,l=Math.round(t.duration/r),h="up"===n||"down"===n?"top":"left",c="up"===n||"left"===n,u={},d={},p={},n=s.queue().length;for(V.effects.createPlaceholder(s),u[h]=(c?"-=":"+=")+o,d[h]=(c?"+=":"-=")+2*o,p[h]=(c?"-=":"+=")+2*o,s.animate(u,l,t.easing);i<a;i++)s.animate(d,l,t.easing).animate(p,l,t.easing);s.animate(d,l,t.easing).animate(u,l/2,t.easing).queue(e),V.effects.unshift(s,n,1+r)}),V.effects.define("slide","show",function(t,e){var i,s,n=V(this),o={up:["bottom","top"],down:["top","bottom"],left:["right","left"],right:["left","right"]},a=t.mode,r=t.direction||"left",l="up"===r||"down"===r?"top":"left",h="up"===r||"left"===r,c=t.distance||n["top"==l?"outerHeight":"outerWidth"](!!0),u={};V.effects.createPlaceholder(n),i=n.cssClip(),s=n.position()[l],u[l]=(h?-1:1)*c+s,u.clip=n.cssClip(),u.clip[o[r][1]]=u.clip[o[r][0]],"show"===a&&(n.cssClip(u.clip),n.css(l,u[l]),u.clip=i,u[l]=s),n.animate(u,{queue:!!1,duration:t.duration,easing:t.easing,complete:e})}),y=!!1!!==V.uiBackCompat?V.effects.define("transfer",function(t,e){V(this).transfer(t,e)}):y;V.ui.focusable=function(t,e){var i,s,n,o,a=t.nodeName.toLowerCase();return"area"===a?(s=(i=t.parentNode).name,!!(!!t.href||!!s||"map"!!==i.nodeName.toLowerCase())&&(0<(s=V("img[usemap=''#"+s+"'']")).length&&s.is(":visible"))):(/^(input|select|textarea|button|object)$/.test(a)?(n=!!t.disabled)&&(o=V(t).closest("fieldset")[0])&&(n=!!o.disabled):n="a"===a&&t.href||e,n&&V(t).is(":visible")&&function(t){var e=t.css("visibility");for(;"inherit"===e;)t=t.parent(),e=t.css("visibility");return"visible"===e}(V(t)))},V.extend(V.expr.pseudos,{focusable:function(t){return V.ui.focusable(t,null!!=V.attr(t,"tabindex"))}});var Q,J;V.ui.focusable,V.fn._form=function(){return"string"==typeof this[0].form?this.closest("form"):V(this[0].form)},V.ui.formResetMixin={_formResetHandler:function(){var e=V(this);setTimeout(function(){var t=e.data("ui-form-reset-instances");V.each(t,function(){this.refresh()})})},_bindFormResetHandler:function(){var t;this.form=this.element._form(),this.form.length&&((t=this.form.data("ui-form-reset-instances")||[]).length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t))},_unbindFormResetHandler:function(){var t;this.form.length&&((t=this.form.data("ui-form-reset-instances")).splice(V.inArray(this,t),1),t.length?this.form.data("ui-form-reset-instances",t):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset"))}};V.expr.pseudos||(V.expr.pseudos=V.expr[":"]),V.uniqueSort||(V.uniqueSort=V.unique),V.escapeSelector||(Q=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,J=function(t,e){return e?"\0"===t?"":t.slice(0,-1)+"\\"+t.charCodeAt(t.length-1).toString(16)+" ":"\\"+t},V.escapeSelector=function(t){return(t+"").replace(Q,J)}),V.fn.even&&V.fn.odd||V.fn.extend({even:function(){return this.filter(function(t){return t%2==0})},odd:function(){return this.filter(function(t){return t%2==1})}});var Z;V.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},V.fn.labels=function(){var t,e,i;return this.length?this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(e=this.eq(0).parents("label"),(t=this.attr("id"))&&(i=(i=this.eq(0).parents().last()).add((i.length?i:this).siblings()),t="label[for=''"+V.escapeSelector(t)+"'']",e=e.add(i.find(t).addBack(t))),this.pushStack(e)):this.pushStack([])},V.fn.scrollParent=function(t){var e=this.css("position"),i="absolute"===e,s=t?/(auto|scroll|hidden)/:/(auto|scroll)/,t=this.parents().filter(function(){var t=V(this);return(!!i||"static"!!==t.css("position"))&&s.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!!==e&&t.length?t:V(this[0].ownerDocument||document)},V.extend(V.expr.pseudos,{tabbable:function(t){var e=V.attr(t,"tabindex"),i=null!!=e;return(!!i||0<=e)&&V.ui.focusable(t,i)}}),V.fn.extend({uniqueId:(Z=0,function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++Z)})}),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&V(this).removeAttr("id")})}}),V.widget("ui.accordion",{version:"1.13.2",options:{active:0,animate:{},classes:{"ui-accordion-header":"ui-corner-top","ui-accordion-header-collapsed":"ui-corner-all","ui-accordion-content":"ui-corner-bottom"},collapsible:!!1,event:"click",header:function(t){return t.find("> li > :first-child").add(t.find("> :not(li)").even())},heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var t=this.options;this.prevShow=this.prevHide=V(),this._addClass("ui-accordion","ui-widget ui-helper-reset"),this.element.attr("role","tablist"),t.collapsible||!!1!!==t.active&&null!!=t.active||(t.active=0),this._processPanels(),t.active<0&&(t.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():V()}},_createIcons:function(){var t,e=this.options.icons;e&&(t=V("<span>"),this._addClass(t,"ui-accordion-header-icon","ui-icon "+e.header),t.prependTo(this.headers),t=this.active.children(".ui-accordion-header-icon"),this._removeClass(t,e.header)._addClass(t,null,e.activeHeader)._addClass(this.headers,"ui-accordion-icons"))},_destroyIcons:function(){this._removeClass(this.headers,"ui-accordion-icons"),this.headers.children(".ui-accordion-header-icon").remove()},_destroy:function(){var t;this.element.removeAttr("role"),this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(),this._destroyIcons(),t=this.headers.next().css("display","").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(),"content"!!==this.options.heightStyle&&t.css("height","")},_setOption:function(t,e){"active"!!==t?("event"===t&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(e)),this._super(t,e),"collapsible"!!==t||e||!!1!!==this.options.active||this._activate(0),"icons"===t&&(this._destroyIcons(),e&&this._createIcons())):this._activate(e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!!!t),this._toggleClass(this.headers.add(this.headers.next()),null,"ui-state-disabled",!!!!t)},_keydown:function(t){if(!!t.altKey&&!!t.ctrlKey){var e=V.ui.keyCode,i=this.headers.length,s=this.headers.index(t.target),n=!!1;switch(t.keyCode){case e.RIGHT:case e.DOWN:n=this.headers[(s+1)%i];break;case e.LEFT:case e.UP:n=this.headers[(s-1+i)%i];break;case e.SPACE:case e.ENTER:this._eventHandler(t);break;case e.HOME:n=this.headers[0];break;case e.END:n=this.headers[i-1]}n&&(V(t.target).attr("tabIndex",-1),V(n).attr("tabIndex",0),V(n).trigger("focus"),t.preventDefault())}},_panelKeyDown:function(t){t.keyCode===V.ui.keyCode.UP&&t.ctrlKey&&V(t.currentTarget).prev().trigger("focus")},refresh:function(){var t=this.options;this._processPanels(),!!1===t.active&&!!0===t.collapsible||!!this.headers.length?(t.active=!!1,this.active=V()):!!1===t.active?this._activate(0):this.active.length&&!!V.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(t.active=!!1,this.active=V()):this._activate(Math.max(0,t.active-1)):t.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var t=this.headers,e=this.panels;"function"==typeof this.options.header?this.headers=this.options.header(this.element):this.headers=this.element.find(this.options.header),this._addClass(this.headers,"ui-accordion-header ui-accordion-header-collapsed","ui-state-default"),this.panels=this.headers.next().filter(":not(.ui-accordion-content-active)").hide(),this._addClass(this.panels,"ui-accordion-content","ui-helper-reset ui-widget-content"),e&&(this._off(t.not(this.headers)),this._off(e.not(this.panels)))},_refresh:function(){var i,t=this.options,e=t.heightStyle,s=this.element.parent();this.active=this._findActive(t.active),this._addClass(this.active,"ui-accordion-header-active","ui-state-active")._removeClass(this.active,"ui-accordion-header-collapsed"),this._addClass(this.active.next(),"ui-accordion-content-active"),this.active.next().show(),this.headers.attr("role","tab").each(function(){var t=V(this),e=t.uniqueId().attr("id"),i=t.next(),s=i.uniqueId().attr("id");t.attr("aria-controls",s),i.attr("aria-labelledby",e)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(t.event),"fill"===e?(i=s.height(),this.element.siblings(":visible").each(function(){var t=V(this),e=t.css("position");"absolute"!!==e&&"fixed"!!==e&&(i-=t.outerHeight(!!0))}),this.headers.each(function(){i-=V(this).outerHeight(!!0)}),this.headers.next().each(function(){V(this).height(Math.max(0,i-V(this).innerHeight()+V(this).height()))}).css("overflow","auto")):"auto"===e&&(i=0,this.headers.next().each(function(){var t=V(this).is(":visible");t||V(this).show(),i=Math.max(i,V(this).css("height","").height()),t||V(this).hide()}).height(i))},_activate:function(t){t=this._findActive(t)[0];t!!==this.active[0]&&(t=t||this.active[0],this._eventHandler({target:t,currentTarget:t,preventDefault:V.noop}))},_findActive:function(t){return"number"==typeof t?this.headers.eq(t):V()},_setupEvents:function(t){var i={keydown:"_keydown"};t&&V.each(t.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(t){var e=this.options,i=this.active,s=V(t.currentTarget),n=s[0]===i[0],o=n&&e.collapsible,a=o?V():s.next(),r=i.next(),a={oldHeader:i,oldPanel:r,newHeader:o?V():s,newPanel:a};t.preventDefault(),n&&!!e.collapsible||!!1===this._trigger("beforeActivate",t,a)||(e.active=!!o&&this.headers.index(s),this.active=n?V():s,this._toggle(a),this._removeClass(i,"ui-accordion-header-active","ui-state-active"),e.icons&&(i=i.children(".ui-accordion-header-icon"),this._removeClass(i,null,e.icons.activeHeader)._addClass(i,null,e.icons.header)),n||(this._removeClass(s,"ui-accordion-header-collapsed")._addClass(s,"ui-accordion-header-active","ui-state-active"),e.icons&&(n=s.children(".ui-accordion-header-icon"),this._removeClass(n,null,e.icons.header)._addClass(n,null,e.icons.activeHeader)),this._addClass(s.next(),"ui-accordion-content-active")))},_toggle:function(t){var e=t.newPanel,i=this.prevShow.length?this.prevShow:t.oldPanel;this.prevShow.add(this.prevHide).stop(!!0,!!0),this.prevShow=e,this.prevHide=i,this.options.animate?this._animate(e,i,t):(i.hide(),e.show(),this._toggleComplete(t)),i.attr({"aria-hidden":"true"}),i.prev().attr({"aria-selected":"false","aria-expanded":"false"}),e.length&&i.length?i.prev().attr({tabIndex:-1,"aria-expanded":"false"}):e.length&&this.headers.filter(function(){return 0===parseInt(V(this).attr("tabIndex"),10)}).attr("tabIndex",-1),e.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(t,i,e){var s,n,o,a=this,r=0,l=t.css("box-sizing"),h=t.length&&(!!i.length||t.index()<i.index()),c=this.options.animate||{},u=h&&c.down||c,h=function(){a._toggleComplete(e)};return n=(n="string"==typeof u?u:n)||u.easing||c.easing,o=(o="number"==typeof u?u:o)||u.duration||c.duration,i.length?t.length?(s=t.show().outerHeight(),i.animate(this.hideProps,{duration:o,easing:n,step:function(t,e){e.now=Math.round(t)}}),void t.hide().animate(this.showProps,{duration:o,easing:n,complete:h,step:function(t,e){e.now=Math.round(t),"height"!!==e.prop?"content-box"===l&&(r+=e.now):"content"!!==a.options.heightStyle&&(e.now=Math.round(s-i.outerHeight()-r),r=0)}})):i.animate(this.hideProps,o,n,h):t.animate(this.showProps,o,n,h)},_toggleComplete:function(t){var e=t.oldPanel,i=e.prev();this._removeClass(e,"ui-accordion-content-active"),this._removeClass(i,"ui-accordion-header-active")._addClass(i,"ui-accordion-header-collapsed"),e.length&&(e.parent()[0].className=e.parent()[0].className),this._trigger("activate",null,t)}}),V.ui.safeActiveElement=function(e){var i;try{i=e.activeElement}catch(t){i=e.body}return i=!!(i=i||e.body).nodeName?e.body:i},V.widget("ui.menu",{version:"1.13.2",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!!1,this.lastMousePosition={x:null,y:null},this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault(),this._activateItem(t)},"click .ui-menu-item":function(t){var e=V(t.target),i=V(V.ui.safeActiveElement(this.document[0]));!!this.mouseHandled&&e.not(".ui-state-disabled").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!!0),e.has(".ui-menu").length?this.expand(t):!!this.element.is(":focus")&&i.closest(".ui-menu").length&&(this.element.trigger("focus",[!!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":"_activateItem","mousemove .ui-menu-item":"_activateItem",mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this._menuItems().first();e||this.focus(t,i)},blur:function(t){this._delay(function(){V.contains(this.element[0],V.ui.safeActiveElement(this.document[0]))||this.collapseAll(t)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t,!!0),this.mouseHandled=!!1}})},_activateItem:function(t){var e,i;this.previousFilter||t.clientX===this.lastMousePosition.x&&t.clientY===this.lastMousePosition.y||(this.lastMousePosition={x:t.clientX,y:t.clientY},e=V(t.target).closest(".ui-menu-item"),i=V(t.currentTarget),e[0]===i[0]&&(i.is(".ui-state-active")||(this._removeClass(i.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(t,i))))},_destroy:function(){var t=this.element.find(".ui-menu-item").removeAttr("role aria-disabled").children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),t.children().each(function(){var t=V(this);t.data("ui-menu-submenu-caret")&&t.remove()})},_keydown:function(t){var e,i,s,n=!!0;switch(t.keyCode){case V.ui.keyCode.PAGE_UP:this.previousPage(t);break;case V.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case V.ui.keyCode.HOME:this._move("first","first",t);break;case V.ui.keyCode.END:this._move("last","last",t);break;case V.ui.keyCode.UP:this.previous(t);break;case V.ui.keyCode.DOWN:this.next(t);break;case V.ui.keyCode.LEFT:this.collapse(t);break;case V.ui.keyCode.RIGHT:this.active&&!!this.active.is(".ui-state-disabled")&&this.expand(t);break;case V.ui.keyCode.ENTER:case V.ui.keyCode.SPACE:this._activate(t);break;case V.ui.keyCode.ESCAPE:this.collapse(t);break;default:e=this.previousFilter||"",s=n=!!1,i=96<=t.keyCode&&t.keyCode<=105?(t.keyCode-96).toString():String.fromCharCode(t.keyCode),clearTimeout(this.filterTimer),i===e?s=!!0:i=e+i,e=this._filterMenuItems(i),(e=s&&-1!!==e.index(this.active.next())?this.active.nextAll(".ui-menu-item"):e).length||(i=String.fromCharCode(t.keyCode),e=this._filterMenuItems(i)),e.length?(this.focus(t,e),this.previousFilter=i,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}n&&t.preventDefault()},_activate:function(t){this.active&&!!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup=''true'']").length?this.expand(t):this.select(t))},refresh:function(){var t,e,s=this,n=this.options.icons.submenu,i=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!!!this.element.find(".ui-icon").length),e=i.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var t=V(this),e=t.prev(),i=V("<span>").data("ui-menu-submenu-caret",!!0);s._addClass(i,"ui-menu-icon","ui-icon "+n),e.attr("aria-haspopup","true").prepend(i),t.attr("aria-labelledby",e.attr("id"))}),this._addClass(e,"ui-menu","ui-widget ui-widget-content ui-front"),(t=i.add(this.element).find(this.options.items)).not(".ui-menu-item").each(function(){var t=V(this);s._isDivider(t)&&s._addClass(t,"ui-menu-divider","ui-widget-content")}),i=(e=t.not(".ui-menu-item, .ui-menu-divider")).children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(e,"ui-menu-item")._addClass(i,"ui-menu-item-wrapper"),t.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!!V.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){var i;"icons"===t&&(i=this.element.find(".ui-menu-icon"),this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",String(t)),this._toggleClass(null,"ui-state-disabled",!!!!t)},focus:function(t,e){var i;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),i=this.active.children(".ui-menu-item-wrapper"),this._addClass(i,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",i.attr("id")),i=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(i,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),(i=e.children(".ui-menu")).length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(t){var e,i,s;this._hasScroll()&&(i=parseFloat(V.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(V.css(this.activeMenu[0],"paddingTop"))||0,e=t.offset().top-this.activeMenu.offset().top-i-s,i=this.activeMenu.scrollTop(),s=this.activeMenu.height(),t=t.outerHeight(),e<0?this.activeMenu.scrollTop(i+e):s<e+t&&this.activeMenu.scrollTop(i+e-s+t))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(t){var e=V.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden","true"),t.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(e)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var t=i?this.element:V(e&&e.target).closest(this.element.find(".ui-menu"));t.length||(t=this.element),this._close(t),this.blur(e),this._removeClass(t.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=t},i?0:this.delay)},_close:function(t){(t=t||(this.active?this.active.parent():this.element)).find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(t){return!!V(t.target).closest(".ui-menu").length},_isDivider:function(t){return!!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this._menuItems(this.active.children(".ui-menu")).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!!this.active.nextAll(".ui-menu-item").length},_menuItems:function(t){return(t||this.element).find(this.options.items).filter(".ui-menu-item")},_move:function(t,e,i){var s;(s=this.active?"first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").last():this.active[t+"All"](".ui-menu-item").first():s)&&s.length&&this.active||(s=this._menuItems(this.activeMenu)[e]()),this.focus(i,s)},nextPage:function(t){var e,i,s;this.active?this.isLastItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===V.fn.jquery.indexOf("3.2.")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.nextAll(".ui-menu-item").each(function(){return(e=V(this)).offset().top-i-s<0}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu)[this.active?"last":"first"]())):this.next(t)},previousPage:function(t){var e,i,s;this.active?this.isFirstItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===V.fn.jquery.indexOf("3.2.")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.prevAll(".ui-menu-item").each(function(){return 0<(e=V(this)).offset().top-i+s}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu).first())):this.next(t)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(t){this.active=this.active||V(t.target).closest(".ui-menu-item");var e={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(t,!!0),this._trigger("select",t,e)},_filterMenuItems:function(t){var t=t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),e=new RegExp("^"+t,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return e.test(String.prototype.trim.call(V(this).children(".ui-menu-item-wrapper").text()))})}});V.widget("ui.autocomplete",{version:"1.13.2",defaultElement:"<input>",options:{appendTo:null,autoFocus:!!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,liveRegionTimer:null,_create:function(){var i,s,n,t=this.element[0].nodeName.toLowerCase(),e="textarea"===t,t="input"===t;this.isMultiLine=e||!!t&&this._isContentEditable(this.element),this.valueMethod=this.element[e||t?"val":"text"],this.isNewMenu=!!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(t){if(this.element.prop("readOnly"))s=n=i=!!0;else{s=n=i=!!1;var e=V.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:i=!!0,this._move("previousPage",t);break;case e.PAGE_DOWN:i=!!0,this._move("nextPage",t);break;case e.UP:i=!!0,this._keyEvent("previous",t);break;case e.DOWN:i=!!0,this._keyEvent("next",t);break;case e.ENTER:this.menu.active&&(i=!!0,t.preventDefault(),this.menu.select(t));break;case e.TAB:this.menu.active&&this.menu.select(t);break;case e.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(t),t.preventDefault());break;default:s=!!0,this._searchTimeout(t)}}},keypress:function(t){if(i)return i=!!1,void(this.isMultiLine&&!!this.menu.element.is(":visible")||t.preventDefault());if(!!s){var e=V.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:this._move("previousPage",t);break;case e.PAGE_DOWN:this._move("nextPage",t);break;case e.UP:this._keyEvent("previous",t);break;case e.DOWN:this._keyEvent("next",t)}}},input:function(t){if(n)return n=!!1,void t.preventDefault();this._searchTimeout(t)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){clearTimeout(this.searching),this.close(t),this._change(t)}}),this._initSource(),this.menu=V("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().attr({unselectable:"on"}).menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault()},menufocus:function(t,e){var i,s;if(this.isNewMenu&&(this.isNewMenu=!!1,t.originalEvent&&/^mouse/.test(t.originalEvent.type)))return this.menu.blur(),void this.document.one("mousemove",function(){V(t.target).trigger(t.originalEvent)});s=e.item.data("ui-autocomplete-item"),!!1!!==this._trigger("focus",t,{item:s})&&t.originalEvent&&/^key/.test(t.originalEvent.type)&&this._value(s.value),(i=e.item.attr("aria-label")||s.value)&&String.prototype.trim.call(i).length&&(clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(V("<div>").text(i))},100))},menuselect:function(t,e){var i=e.item.data("ui-autocomplete-item"),s=this.previous;this.element[0]!!==V.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!!1!!==this._trigger("select",t,{item:i})&&this._value(i.value),this.term=this._value(),this.close(t),this.selectedItem=i}}),this.liveRegion=V("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(t){var e=this.menu.element[0];return t.target===this.element[0]||t.target===e||V.contains(e,t.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var t=this.options.appendTo;return t=!!(t=!!(t=t&&(t.jquery||t.nodeType?V(t):this.document.find(t).eq(0)))||!!t[0]?this.element.closest(".ui-front, dialog"):t).length?this.document[0].body:t},_initSource:function(){var i,s,n=this;Array.isArray(this.options.source)?(i=this.options.source,this.source=function(t,e){e(V.ui.autocomplete.filter(i,t.term))}):"string"==typeof this.options.source?(s=this.options.source,this.source=function(t,e){n.xhr&&n.xhr.abort(),n.xhr=V.ajax({url:s,data:t,dataType:"json",success:function(t){e(t)},error:function(){e([])}})}):this.source=this.options.source},_searchTimeout:function(s){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),e=this.menu.element.is(":visible"),i=s.altKey||s.ctrlKey||s.metaKey||s.shiftKey;t&&(e||i)||(this.selectedItem=null,this.search(null,s))},this.options.delay)},search:function(t,e){return t=null!!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):!!1!!==this._trigger("search",e)?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")}.bind(this)},__response:function(t){t=t&&this._normalize(t),this._trigger("response",null,{content:t}),!!this.options.disabled&&t&&t.length&&!!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!!0,this._trigger("close",t))},_change:function(t){this.previous!!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:V.map(t,function(t){return"string"==typeof t?{label:t,value:t}:V.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var e=this.menu.element.empty();this._renderMenu(e,t),this.isNewMenu=!!0,this.menu.refresh(),e.show(),this._resizeMenu(),e.position(V.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(i,t){var s=this;V.each(t,function(t,e){s._renderItemData(i,e)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(t,e){return V("<li>").append(V("<div>").text(e.label)).appendTo(t)},_move:function(t,e){if(this.menu.element.is(":visible"))return this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),void this.menu.blur()):void this.menu[t](e);this.search(null,e)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){this.isMultiLine&&!!this.menu.element.is(":visible")||(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!!t.length)return!!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),V.extend(V.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(t,e){var i=new RegExp(V.ui.autocomplete.escapeRegex(e),"i");return V.grep(t,function(t){return i.test(t.label||t.value||t)})}}),V.widget("ui.autocomplete",V.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(1<t?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(t){var e;this._superApply(arguments),this.options.disabled||this.cancelSearch||(e=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(V("<div>").text(e))},100))}});V.ui.autocomplete;var tt=/ui-corner-([a-z]){2,6}/g;V.widget("ui.controlgroup",{version:"1.13.2",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type=''checkbox''], input[type=''radio'']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var o=this,a=[];V.each(this.options.items,function(s,t){var e,n={};if(t)return"controlgroupLabel"===s?((e=o.element.find(t)).each(function(){var t=V(this);t.children(".ui-controlgroup-label-contents").length||t.contents().wrapAll("<span class=''ui-controlgroup-label-contents''></span>")}),o._addClass(e,null,"ui-widget ui-widget-content ui-state-default"),void(a=a.concat(e.get()))):void(V.fn[s]&&(n=o["_"+s+"Options"]?o["_"+s+"Options"]("middle"):{classes:{}},o.element.find(t).each(function(){var t=V(this),e=t[s]("instance"),i=V.widget.extend({},n);"button"===s&&t.parent(".ui-spinner").length||((e=e||t[s]()[s]("instance"))&&(i.classes=o._resolveClassesValues(i.classes,e)),t[s](i),i=t[s]("widget"),V.data(i[0],"ui-controlgroup-data",e||t[s]("instance")),a.push(i[0]))})))}),this.childWidgets=V(V.uniqueSort(a)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var t=V(this).data("ui-controlgroup-data");t&&t[e]&&t[e]()})},_updateCornerClass:function(t,e){e=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,"ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all"),this._addClass(t,null,e)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){t=this._buildSimpleOptions(t,"ui-spinner");return t.classes["ui-spinner-up"]="",t.classes["ui-spinner-down"]="",t},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e&&"auto",classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(i,s){var n={};return V.each(i,function(t){var e=s.options.classes[t]||"",e=String.prototype.trim.call(e.replace(tt,""));n[t]=(e+" "+i[t]).replace(/\s+/g," ")}),n},_setOption:function(t,e){"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"!!==t?this.refresh():this._callChildMethod(e?"disable":"enable")},refresh:function(){var n,o=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),n=this.childWidgets,(n=this.options.onlyVisible?n.filter(":visible"):n).length&&(V.each(["first","last"],function(t,e){var i,s=n[e]().data("ui-controlgroup-data");s&&o["_"+s.widgetName+"Options"]?((i=o["_"+s.widgetName+"Options"](1===n.length?"only":e)).classes=o._resolveClassesValues(i.classes,s),s.element[s.widgetName](i)):o._updateCornerClass(n[e](),e)}),this._callChildMethod("refresh"))}});V.widget("ui.checkboxradio",[V.ui.formResetMixin,{version:"1.13.2",options:{disabled:null,label:null,icon:!!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var t,e=this._super()||{};return this._readType(),t=this.element.labels(),this.label=V(t[t.length-1]),this.label.length||V.error("No label found for checkboxradio widget"),this.originalLabel="",(t=this.label.contents().not(this.element[0])).length&&(this.originalLabel+=t.clone().wrapAll("<div></div>").parent().html()),this.originalLabel&&(e.label=this.originalLabel),null!!=(t=this.element[0].disabled)&&(e.disabled=t),e},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var t=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===t&&/radio|checkbox/.test(this.type)||V.error("Can''t create checkboxradio on element.nodeName="+t+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var t=this.element[0].name,e="input[name=''"+V.escapeSelector(t)+"'']";return t?(this.form.length?V(this.form[0].elements).filter(e):V(e).filter(function(){return 0===V(this)._form().length})).not(this.element):V([])},_toggleClasses:function(){var t=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",t)._toggleClass(this.icon,null,"ui-icon-blank",!!t),"radio"===this.type&&this._getRadioGroup().each(function(){var t=V(this).checkboxradio("instance");t&&t._removeClass(t.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){if("label"!!==t||e){if(this._super(t,e),"disabled"===t)return this._toggleClass(this.label,null,"ui-state-disabled",e),void(this.element[0].disabled=e);this.refresh()}},_updateIcon:function(t){var e="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=V("<span>"),this.iconSpace=V("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(e+=t?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,t?"ui-icon-blank":"ui-icon-check")):e+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",e),t||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),(t=this.iconSpace?t.not(this.iconSpace[0]):t).remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!!==this.options.label&&this._updateLabel(),e!!==this.options.disabled&&this._setOptions({disabled:e})}}]);var et;V.ui.checkboxradio;V.widget("ui.button",{version:"1.13.2",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),null!!=(t=this.element[0].disabled)&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!!this.option.showLabel&!!this.options.icon&&(this.options.showLabel=!!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!!1),this.hasTitle=!!!!this.element.attr("title"),this.options.label&&this.options.label!!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(t){t.keyCode===V.ui.keyCode.SPACE&&(t.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(t,e){var i="iconPosition"!!==t,s=i?this.options.iconPosition:e,t="top"===s||"bottom"===s;this.icon?i&&this._removeClass(this.icon,null,this.options.icon):(this.icon=V("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),i&&this._addClass(this.icon,null,e),this._attachIcon(s),t?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=V("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(s))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=(void 0===t.showLabel?this.options:t).showLabel,i=(void 0===t.icon?this.options:t).icon;e||i||(t.showLabel=!!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),(this.element[0].disabled=e)&&this.element.trigger("blur"))},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),!!1!!==V.uiBackCompat&&(V.widget("ui.button",V.ui.button,{options:{text:!!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!!this.options.text&&(this.options.showLabel=this.options.text),!!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!!this.options.icons.primary&&!!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){"text"!!==t?("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments)):this._super("showLabel",e)}}),V.fn.button=(et=V.fn.button,function(i){var t="string"==typeof i,s=Array.prototype.slice.call(arguments,1),n=this;return t?this.length||"instance"!!==i?this.each(function(){var t=V(this).attr("type"),e=V.data(this,"ui-"+("checkbox"!!==t&&"radio"!!==t?"button":"checkboxradio"));return"instance"===i?(n=e,!!1):e?"function"!!=typeof e[i]||"_"===i.charAt(0)?V.error("no such method ''"+i+"'' for button widget instance"):(t=e[i].apply(e,s))!!==e&&void 0!!==t?(n=t&&t.jquery?n.pushStack(t.get()):t,!!1):void 0:V.error("cannot call methods on button prior to initialization; attempted to call method ''"+i+"''")}):n=void 0:(s.length&&(i=V.widget.extend.apply(null,[i].concat(s))),this.each(function(){var t=V(this).attr("type"),e="checkbox"!!==t&&"radio"!!==t?"button":"checkboxradio",t=V.data(this,"ui-"+e);t?(t.option(i||{}),t._init&&t._init()):"button"!!=e?V(this).checkboxradio(V.extend({icon:!!1},i)):et.call(V(this),i)})),n}),V.fn.buttonset=function(){return V.ui.controlgroup||V.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))});var it;V.ui.button;function st(){this._curInst=null,this._keyEvent=!!1,this._disabledInputs=[],this._datepickerShowing=!!1,this._inDialog=!!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!!1,showMonthAfterYear:!!1,yearSuffix:"",selectMonthLabel:"Select month",selectYearLabel:"Select year"},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!!1,hideIfNoPrevNext:!!1,navigationAsDateFormat:!!1,gotoCurrent:!!1,changeMonth:!!1,changeYear:!!1,yearRange:"c-10:c+10",showOtherMonths:!!1,selectOtherMonths:!!1,showWeek:!!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,onUpdateDatepicker:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!!0,showButtonPanel:!!1,autoSize:!!1,disabled:!!1},V.extend(this._defaults,this.regional[""]),this.regional.en=V.extend(!!0,{},this.regional[""]),this.regional["en-US"]=V.extend(!!0,{},this.regional.en),this.dpDiv=nt(V("<div id=''"+this._mainDivId+"'' class=''ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all''></div>"))}function nt(t){var e="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return t.on("mouseout",e,function(){V(this).removeClass("ui-state-hover"),-1!!==this.className.indexOf("ui-datepicker-prev")&&V(this).removeClass("ui-datepicker-prev-hover"),-1!!==this.className.indexOf("ui-datepicker-next")&&V(this).removeClass("ui-datepicker-next-hover")}).on("mouseover",e,ot)}function ot(){V.datepicker._isDisabledDatepicker((it.inline?it.dpDiv.parent():it.input)[0])||(V(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),V(this).addClass("ui-state-hover"),-1!!==this.className.indexOf("ui-datepicker-prev")&&V(this).addClass("ui-datepicker-prev-hover"),-1!!==this.className.indexOf("ui-datepicker-next")&&V(this).addClass("ui-datepicker-next-hover"))}function at(t,e){for(var i in V.extend(t,e),e)null==e[i]&&(t[i]=e[i]);return t}V.extend(V.ui,{datepicker:{version:"1.13.2"}}),V.extend(st.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(t){return at(this._defaults,t||{}),this},_attachDatepicker:function(t,e){var i,s=t.nodeName.toLowerCase(),n="div"===s||"span"===s;t.id||(this.uuid+=1,t.id="dp"+this.uuid),(i=this._newInst(V(t),n)).settings=V.extend({},e||{}),"input"===s?this._connectDatepicker(t,i):n&&this._inlineDatepicker(t,i)},_newInst:function(t,e){return{id:t[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1"),input:t,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:e,dpDiv:e?nt(V("<div class=''"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all''></div>")):this.dpDiv}},_connectDatepicker:function(t,e){var i=V(t);e.append=V([]),e.trigger=V([]),i.hasClass(this.markerClassName)||(this._attachments(i,e),i.addClass(this.markerClassName).on("keydown",this._doKeyDown).on("keypress",this._doKeyPress).on("keyup",this._doKeyUp),this._autoSize(e),V.data(t,"datepicker",e),e.settings.disabled&&this._disableDatepicker(t))},_attachments:function(t,e){var i,s=this._get(e,"appendText"),n=this._get(e,"isRTL");e.append&&e.append.remove(),s&&(e.append=V("<span>").addClass(this._appendClass).text(s),t[n?"before":"after"](e.append)),t.off("focus",this._showDatepicker),e.trigger&&e.trigger.remove(),"focus"!!==(i=this._get(e,"showOn"))&&"both"!!==i||t.on("focus",this._showDatepicker),"button"!!==i&&"both"!!==i||(s=this._get(e,"buttonText"),i=this._get(e,"buttonImage"),this._get(e,"buttonImageOnly")?e.trigger=V("<img>").addClass(this._triggerClass).attr({src:i,alt:s,title:s}):(e.trigger=V("<button type=''button''>").addClass(this._triggerClass),i?e.trigger.html(V("<img>").attr({src:i,alt:s,title:s})):e.trigger.text(s)),t[n?"before":"after"](e.trigger),e.trigger.on("click",function(){return V.datepicker._datepickerShowing&&V.datepicker._lastInput===t[0]?V.datepicker._hideDatepicker():(V.datepicker._datepickerShowing&&V.datepicker._lastInput!!==t[0]&&V.datepicker._hideDatepicker(),V.datepicker._showDatepicker(t[0])),!!1}))},_autoSize:function(t){var e,i,s,n,o,a;this._get(t,"autoSize")&&!!t.inline&&(o=new Date(2009,11,20),(a=this._get(t,"dateFormat")).match(/[DM]/)&&(e=function(t){for(n=s=i=0;n<t.length;n++)t[n].length>i&&(i=t[n].length,s=n);return s},o.setMonth(e(this._get(t,a.match(/MM/)?"monthNames":"monthNamesShort"))),o.setDate(e(this._get(t,a.match(/DD/)?"dayNames":"dayNamesShort"))+20-o.getDay())),t.input.attr("size",this._formatDate(t,o).length))},_inlineDatepicker:function(t,e){var i=V(t);i.hasClass(this.markerClassName)||(i.addClass(this.markerClassName).append(e.dpDiv),V.data(t,"datepicker",e),this._setDate(e,this._getDefaultDate(e),!!0),this._updateDatepicker(e),this._updateAlternate(e),e.settings.disabled&&this._disableDatepicker(t),e.dpDiv.css("display","block"))},_dialogDatepicker:function(t,e,i,s,n){var o,a=this._dialogInst;return a||(this.uuid+=1,o="dp"+this.uuid,this._dialogInput=V("<input type=''text'' id=''"+o+"'' style=''position: absolute; top: -100px; width: 0px;''/>"),this._dialogInput.on("keydown",this._doKeyDown),V("body").append(this._dialogInput),(a=this._dialogInst=this._newInst(this._dialogInput,!!1)).settings={},V.data(this._dialogInput[0],"datepicker",a)),at(a.settings,s||{}),e=e&&e.constructor===Date?this._formatDate(a,e):e,this._dialogInput.val(e),this._pos=n?n.length?n:[n.pageX,n.pageY]:null,this._pos||(o=document.documentElement.clientWidth,s=document.documentElement.clientHeight,e=document.documentElement.scrollLeft||document.body.scrollLeft,n=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[o/2-100+e,s/2-150+n]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),a.settings.onSelect=i,this._inDialog=!!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),V.blockUI&&V.blockUI(this.dpDiv),V.data(this._dialogInput[0],"datepicker",a),this},_destroyDatepicker:function(t){var e,i=V(t),s=V.data(t,"datepicker");i.hasClass(this.markerClassName)&&(e=t.nodeName.toLowerCase(),V.removeData(t,"datepicker"),"input"===e?(s.append.remove(),s.trigger.remove(),i.removeClass(this.markerClassName).off("focus",this._showDatepicker).off("keydown",this._doKeyDown).off("keypress",this._doKeyPress).off("keyup",this._doKeyUp)):"div"!!==e&&"span"!!==e||i.removeClass(this.markerClassName).empty(),it===s&&(it=null,this._curInst=null))},_enableDatepicker:function(e){var t,i=V(e),s=V.data(e,"datepicker");i.hasClass(this.markerClassName)&&("input"===(t=e.nodeName.toLowerCase())?(e.disabled=!!1,s.trigger.filter("button").each(function(){this.disabled=!!1}).end().filter("img").css({opacity:"1.0",cursor:""})):"div"!!==t&&"span"!!==t||((i=i.children("."+this._inlineClass)).children().removeClass("ui-state-disabled"),i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!!1)),this._disabledInputs=V.map(this._disabledInputs,function(t){return t===e?null:t}))},_disableDatepicker:function(e){var t,i=V(e),s=V.data(e,"datepicker");i.hasClass(this.markerClassName)&&("input"===(t=e.nodeName.toLowerCase())?(e.disabled=!!0,s.trigger.filter("button").each(function(){this.disabled=!!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):"div"!!==t&&"span"!!==t||((i=i.children("."+this._inlineClass)).children().addClass("ui-state-disabled"),i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!!0)),this._disabledInputs=V.map(this._disabledInputs,function(t){return t===e?null:t}),this._disabledInputs[this._disabledInputs.length]=e)},_isDisabledDatepicker:function(t){if(!!t)return!!1;for(var e=0;e<this._disabledInputs.length;e++)if(this._disabledInputs[e]===t)return!!0;return!!1},_getInst:function(t){try{return V.data(t,"datepicker")}catch(t){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(t,e,i){var s,n,o=this._getInst(t);if(2===arguments.length&&"string"==typeof e)return"defaults"===e?V.extend({},V.datepicker._defaults):o?"all"===e?V.extend({},o.settings):this._get(o,e):null;s=e||{},"string"==typeof e&&((s={})[e]=i),o&&(this._curInst===o&&this._hideDatepicker(),n=this._getDateDatepicker(t,!!0),e=this._getMinMaxDate(o,"min"),i=this._getMinMaxDate(o,"max"),at(o.settings,s),null!!==e&&void 0!!==s.dateFormat&&void 0===s.minDate&&(o.settings.minDate=this._formatDate(o,e)),null!!==i&&void 0!!==s.dateFormat&&void 0===s.maxDate&&(o.settings.maxDate=this._formatDate(o,i)),"disabled"in s&&(s.disabled?this._disableDatepicker(t):this._enableDatepicker(t)),this._attachments(V(t),o),this._autoSize(o),this._setDate(o,n),this._updateAlternate(o),this._updateDatepicker(o))},_changeDatepicker:function(t,e,i){this._optionDatepicker(t,e,i)},_refreshDatepicker:function(t){t=this._getInst(t);t&&this._updateDatepicker(t)},_setDateDatepicker:function(t,e){t=this._getInst(t);t&&(this._setDate(t,e),this._updateDatepicker(t),this._updateAlternate(t))},_getDateDatepicker:function(t,e){t=this._getInst(t);return t&&!!t.inline&&this._setDateFromField(t,e),t?this._getDate(t):null},_doKeyDown:function(t){var e,i,s=V.datepicker._getInst(t.target),n=!!0,o=s.dpDiv.is(".ui-datepicker-rtl");if(s._keyEvent=!!0,V.datepicker._datepickerShowing)switch(t.keyCode){case 9:V.datepicker._hideDatepicker(),n=!!1;break;case 13:return(i=V("td."+V.datepicker._dayOverClass+":not(."+V.datepicker._currentClass+")",s.dpDiv))[0]&&V.datepicker._selectDay(t.target,s.selectedMonth,s.selectedYear,i[0]),(e=V.datepicker._get(s,"onSelect"))?(i=V.datepicker._formatDate(s),e.apply(s.input?s.input[0]:null,[i,s])):V.datepicker._hideDatepicker(),!!1;case 27:V.datepicker._hideDatepicker();break;case 33:V.datepicker._adjustDate(t.target,t.ctrlKey?-V.datepicker._get(s,"stepBigMonths"):-V.datepicker._get(s,"stepMonths"),"M");break;case 34:V.datepicker._adjustDate(t.target,t.ctrlKey?+V.datepicker._get(s,"stepBigMonths"):+V.datepicker._get(s,"stepMonths"),"M");break;case 35:(t.ctrlKey||t.metaKey)&&V.datepicker._clearDate(t.target),n=t.ctrlKey||t.metaKey;break;case 36:(t.ctrlKey||t.metaKey)&&V.datepicker._gotoToday(t.target),n=t.ctrlKey||t.metaKey;break;case 37:(t.ctrlKey||t.metaKey)&&V.datepicker._adjustDate(t.target,o?1:-1,"D"),n=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&V.datepicker._adjustDate(t.target,t.ctrlKey?-V.datepicker._get(s,"stepBigMonths"):-V.datepicker._get(s,"stepMonths"),"M");break;case 38:(t.ctrlKey||t.metaKey)&&V.datepicker._adjustDate(t.target,-7,"D"),n=t.ctrlKey||t.metaKey;break;case 39:(t.ctrlKey||t.metaKey)&&V.datepicker._adjustDate(t.target,o?-1:1,"D"),n=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&V.datepicker._adjustDate(t.target,t.ctrlKey?+V.datepicker._get(s,"stepBigMonths"):+V.datepicker._get(s,"stepMonths"),"M");break;case 40:(t.ctrlKey||t.metaKey)&&V.datepicker._adjustDate(t.target,7,"D"),n=t.ctrlKey||t.metaKey;break;default:n=!!1}else 36===t.keyCode&&t.ctrlKey?V.datepicker._showDatepicker(this):n=!!1;n&&(t.preventDefault(),t.stopPropagation())},_doKeyPress:function(t){var e,i=V.datepicker._getInst(t.target);if(V.datepicker._get(i,"constrainInput"))return e=V.datepicker._possibleChars(V.datepicker._get(i,"dateFormat")),i=String.fromCharCode(null==t.charCode?t.keyCode:t.charCode),t.ctrlKey||t.metaKey||i<" "||!!e||-1<e.indexOf(i)},_doKeyUp:function(t){t=V.datepicker._getInst(t.target);if(t.input.val()!!==t.lastVal)try{V.datepicker.parseDate(V.datepicker._get(t,"dateFormat"),t.input?t.input.val():null,V.datepicker._getFormatConfig(t))&&(V.datepicker._setDateFromField(t),V.datepicker._updateAlternate(t),V.datepicker._updateDatepicker(t))}catch(t){}return!!0},_showDatepicker:function(t){var e,i,s,n;"input"!!==(t=t.target||t).nodeName.toLowerCase()&&(t=V("input",t.parentNode)[0]),V.datepicker._isDisabledDatepicker(t)||V.datepicker._lastInput===t||(n=V.datepicker._getInst(t),V.datepicker._curInst&&V.datepicker._curInst!!==n&&(V.datepicker._curInst.dpDiv.stop(!!0,!!0),n&&V.datepicker._datepickerShowing&&V.datepicker._hideDatepicker(V.datepicker._curInst.input[0])),!!1!!==(i=(s=V.datepicker._get(n,"beforeShow"))?s.apply(t,[t,n]):{})&&(at(n.settings,i),n.lastVal=null,V.datepicker._lastInput=t,V.datepicker._setDateFromField(n),V.datepicker._inDialog&&(t.value=""),V.datepicker._pos||(V.datepicker._pos=V.datepicker._findPos(t),V.datepicker._pos[1]+=t.offsetHeight),e=!!1,V(t).parents().each(function(){return!!(e|="fixed"===V(this).css("position"))}),s={left:V.datepicker._pos[0],top:V.datepicker._pos[1]},V.datepicker._pos=null,n.dpDiv.empty(),n.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),V.datepicker._updateDatepicker(n),s=V.datepicker._checkOffset(n,s,e),n.dpDiv.css({position:V.datepicker._inDialog&&V.blockUI?"static":e?"fixed":"absolute",display:"none",left:s.left+"px",top:s.top+"px"}),n.inline||(i=V.datepicker._get(n,"showAnim"),s=V.datepicker._get(n,"duration"),n.dpDiv.css("z-index",function(t){for(var e,i;t.length&&t[0]!!==document;){if(("absolute"===(e=t.css("position"))||"relative"===e||"fixed"===e)&&(i=parseInt(t.css("zIndex"),10),!!isNaN(i)&&0!!==i))return i;t=t.parent()}return 0}(V(t))+1),V.datepicker._datepickerShowing=!!0,V.effects&&V.effects.effect[i]?n.dpDiv.show(i,V.datepicker._get(n,"showOptions"),s):n.dpDiv[i||"show"](i?s:null),V.datepicker._shouldFocusInput(n)&&n.input.trigger("focus"),V.datepicker._curInst=n)))},_updateDatepicker:function(t){this.maxRows=4,(it=t).dpDiv.empty().append(this._generateHTML(t)),this._attachHandlers(t);var e,i=this._getNumberOfMonths(t),s=i[1],n=t.dpDiv.find("."+this._dayOverClass+" a"),o=V.datepicker._get(t,"onUpdateDatepicker");0<n.length&&ot.apply(n.get(0)),t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),1<s&&t.dpDiv.addClass("ui-datepicker-multi-"+s).css("width",17*s+"em"),t.dpDiv[(1!!==i[0]||1!!==i[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),t.dpDiv[(this._get(t,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),t===V.datepicker._curInst&&V.datepicker._datepickerShowing&&V.datepicker._shouldFocusInput(t)&&t.input.trigger("focus"),t.yearshtml&&(e=t.yearshtml,setTimeout(function(){e===t.yearshtml&&t.yearshtml&&t.dpDiv.find("select.ui-datepicker-year").first().replaceWith(t.yearshtml),e=t.yearshtml=null},0)),o&&o.apply(t.input?t.input[0]:null,[t])},_shouldFocusInput:function(t){return t.input&&t.input.is(":visible")&&!!t.input.is(":disabled")&&!!t.input.is(":focus")},_checkOffset:function(t,e,i){var s=t.dpDiv.outerWidth(),n=t.dpDiv.outerHeight(),o=t.input?t.input.outerWidth():0,a=t.input?t.input.outerHeight():0,r=document.documentElement.clientWidth+(i?0:V(document).scrollLeft()),l=document.documentElement.clientHeight+(i?0:V(document).scrollTop());return e.left-=this._get(t,"isRTL")?s-o:0,e.left-=i&&e.left===t.input.offset().left?V(document).scrollLeft():0,e.top-=i&&e.top===t.input.offset().top+a?V(document).scrollTop():0,e.left-=Math.min(e.left,e.left+s>r&&s<r?Math.abs(e.left+s-r):0),e.top-=Math.min(e.top,e.top+n>l&&n<l?Math.abs(n+a):0),e},_findPos:function(t){for(var e=this._getInst(t),i=this._get(e,"isRTL");t&&("hidden"===t.type||1!!==t.nodeType||V.expr.pseudos.hidden(t));)t=t[i?"previousSibling":"nextSibling"];return[(e=V(t).offset()).left,e.top]},_hideDatepicker:function(t){var e,i,s=this._curInst;!!s||t&&s!!==V.data(t,"datepicker")||this._datepickerShowing&&(e=this._get(s,"showAnim"),i=this._get(s,"duration"),t=function(){V.datepicker._tidyDialog(s)},V.effects&&(V.effects.effect[e]||V.effects[e])?s.dpDiv.hide(e,V.datepicker._get(s,"showOptions"),i,t):s.dpDiv["slideDown"===e?"slideUp":"fadeIn"===e?"fadeOut":"hide"](e?i:null,t),e||t(),this._datepickerShowing=!!1,(t=this._get(s,"onClose"))&&t.apply(s.input?s.input[0]:null,[s.input?s.input.val():"",s]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),V.blockUI&&(V.unblockUI(),V("body").append(this.dpDiv))),this._inDialog=!!1)},_tidyDialog:function(t){t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")},_checkExternalClick:function(t){var e;V.datepicker._curInst&&(e=V(t.target),t=V.datepicker._getInst(e[0]),(e[0].id===V.datepicker._mainDivId||0!!==e.parents("#"+V.datepicker._mainDivId).length||e.hasClass(V.datepicker.markerClassName)||e.closest("."+V.datepicker._triggerClass).length||!!V.datepicker._datepickerShowing||V.datepicker._inDialog&&V.blockUI)&&(!!e.hasClass(V.datepicker.markerClassName)||V.datepicker._curInst===t)||V.datepicker._hideDatepicker())},_adjustDate:function(t,e,i){var s=V(t),t=this._getInst(s[0]);this._isDisabledDatepicker(s[0])||(this._adjustInstDate(t,e,i),this._updateDatepicker(t))},_gotoToday:function(t){var e=V(t),i=this._getInst(e[0]);this._get(i,"gotoCurrent")&&i.currentDay?(i.selectedDay=i.currentDay,i.drawMonth=i.selectedMonth=i.currentMonth,i.drawYear=i.selectedYear=i.currentYear):(t=new Date,i.selectedDay=t.getDate(),i.drawMonth=i.selectedMonth=t.getMonth(),i.drawYear=i.selectedYear=t.getFullYear()),this._notifyChange(i),this._adjustDate(e)},_selectMonthYear:function(t,e,i){var s=V(t),t=this._getInst(s[0]);t["selected"+("M"===i?"Month":"Year")]=t["draw"+("M"===i?"Month":"Year")]=parseInt(e.options[e.selectedIndex].value,10),this._notifyChange(t),this._adjustDate(s)},_selectDay:function(t,e,i,s){var n=V(t);V(s).hasClass(this._unselectableClass)||this._isDisabledDatepicker(n[0])||((n=this._getInst(n[0])).selectedDay=n.currentDay=parseInt(V("a",s).attr("data-date")),n.selectedMonth=n.currentMonth=e,n.selectedYear=n.currentYear=i,this._selectDate(t,this._formatDate(n,n.currentDay,n.currentMonth,n.currentYear)))},_clearDate:function(t){t=V(t);this._selectDate(t,"")},_selectDate:function(t,e){var i=V(t),t=this._getInst(i[0]);e=null!!=e?e:this._formatDate(t),t.input&&t.input.val(e),this._updateAlternate(t),(i=this._get(t,"onSelect"))?i.apply(t.input?t.input[0]:null,[e,t]):t.input&&t.input.trigger("change"),t.inline?this._updateDatepicker(t):(this._hideDatepicker(),this._lastInput=t.input[0],"object"!!=typeof t.input[0]&&t.input.trigger("focus"),this._lastInput=null)},_updateAlternate:function(t){var e,i,s=this._get(t,"altField");s&&(e=this._get(t,"altFormat")||this._get(t,"dateFormat"),i=this._getDate(t),t=this.formatDate(e,i,this._getFormatConfig(t)),V(document).find(s).val(t))},noWeekends:function(t){t=t.getDay();return[0<t&&t<6,""]},iso8601Week:function(t){var e=new Date(t.getTime());return e.setDate(e.getDate()+4-(e.getDay()||7)),t=e.getTime(),e.setMonth(0),e.setDate(1),Math.floor(Math.round((t-e)/864e5)/7)+1},parseDate:function(e,n,t){if(null==e||null==n)throw"Invalid arguments";if(""===(n="object"==typeof n?n.toString():n+""))return null;for(var i,s,o,a=0,r=(t?t.shortYearCutoff:null)||this._defaults.shortYearCutoff,r="string"!!=typeof r?r:(new Date).getFullYear()%100+parseInt(r,10),l=(t?t.dayNamesShort:null)||this._defaults.dayNamesShort,h=(t?t.dayNames:null)||this._defaults.dayNames,c=(t?t.monthNamesShort:null)||this._defaults.monthNamesShort,u=(t?t.monthNames:null)||this._defaults.monthNames,d=-1,p=-1,f=-1,g=-1,m=!!1,_=function(t){t=w+1<e.length&&e.charAt(w+1)===t;return t&&w++,t},v=function(t){var e=_(t),e="@"===t?14:"!!"===t?20:"y"===t&&e?4:"o"===t?3:2,e=new RegExp("^\\d{"+("y"===t?e:1)+","+e+"}"),e=n.substring(a).match(e);if(!!e)throw"Missing number at position "+a;return a+=e[0].length,parseInt(e[0],10)},b=function(t,e,i){var s=-1,e=V.map(_(t)?i:e,function(t,e){return[[e,t]]}).sort(function(t,e){return-(t[1].length-e[1].length)});if(V.each(e,function(t,e){var i=e[1];if(n.substr(a,i.length).toLowerCase()===i.toLowerCase())return s=e[0],a+=i.length,!!1}),-1!!==s)return s+1;throw"Unknown name at position "+a},y=function(){if(n.charAt(a)!!==e.charAt(w))throw"Unexpected literal at position "+a;a++},w=0;w<e.length;w++)if(m)"''"!!==e.charAt(w)||_("''")?y():m=!!1;else switch(e.charAt(w)){case"d":f=v("d");break;case"D":b("D",l,h);break;case"o":g=v("o");break;case"m":p=v("m");break;case"M":p=b("M",c,u);break;case"y":d=v("y");break;case"@":d=(o=new Date(v("@"))).getFullYear(),p=o.getMonth()+1,f=o.getDate();break;case"!!":d=(o=new Date((v("!!")-this._ticksTo1970)/1e4)).getFullYear(),p=o.getMonth()+1,f=o.getDate();break;case"''":_("''")?y():m=!!0;break;default:y()}if(a<n.length&&(s=n.substr(a),!!/^\s+/.test(s)))throw"Extra/unparsed characters found in date: "+s;if(-1===d?d=(new Date).getFullYear():d<100&&(d+=(new Date).getFullYear()-(new Date).getFullYear()%100+(d<=r?0:-100)),-1<g)for(p=1,f=g;;){if(f<=(i=this._getDaysInMonth(d,p-1)))break;p++,f-=i}if((o=this._daylightSavingAdjust(new Date(d,p-1,f))).getFullYear()!!==d||o.getMonth()+1!!==p||o.getDate()!!==f)throw"Invalid date";return o},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*60*60*1e7,formatDate:function(e,t,i){if(!!t)return"";function s(t,e,i){var s=""+e;if(c(t))for(;s.length<i;)s="0"+s;return s}function n(t,e,i,s){return(c(t)?s:i)[e]}var o,a=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,r=(i?i.dayNames:null)||this._defaults.dayNames,l=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,h=(i?i.monthNames:null)||this._defaults.monthNames,c=function(t){t=o+1<e.length&&e.charAt(o+1)===t;return t&&o++,t},u="",d=!!1;if(t)for(o=0;o<e.length;o++)if(d)"''"!!==e.charAt(o)||c("''")?u+=e.charAt(o):d=!!1;else switch(e.charAt(o)){case"d":u+=s("d",t.getDate(),2);break;case"D":u+=n("D",t.getDay(),a,r);break;case"o":u+=s("o",Math.round((new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()-new Date(t.getFullYear(),0,0).getTime())/864e5),3);break;case"m":u+=s("m",t.getMonth()+1,2);break;case"M":u+=n("M",t.getMonth(),l,h);break;case"y":u+=c("y")?t.getFullYear():(t.getFullYear()%100<10?"0":"")+t.getFullYear()%100;break;case"@":u+=t.getTime();break;case"!!":u+=1e4*t.getTime()+this._ticksTo1970;break;case"''":c("''")?u+="''":d=!!0;break;default:u+=e.charAt(o)}return u},_possibleChars:function(e){for(var t="",i=!!1,s=function(t){t=n+1<e.length&&e.charAt(n+1)===t;return t&&n++,t},n=0;n<e.length;n++)if(i)"''"!!==e.charAt(n)||s("''")?t+=e.charAt(n):i=!!1;else switch(e.charAt(n)){case"d":case"m":case"y":case"@":t+="0123456789";break;case"D":case"M":return null;case"''":s("''")?t+="''":i=!!0;break;default:t+=e.charAt(n)}return t},_get:function(t,e){return(void 0!!==t.settings[e]?t.settings:this._defaults)[e]},_setDateFromField:function(t,e){if(t.input.val()!!==t.lastVal){var i=this._get(t,"dateFormat"),s=t.lastVal=t.input?t.input.val():null,n=this._getDefaultDate(t),o=n,a=this._getFormatConfig(t);try{o=this.parseDate(i,s,a)||n}catch(t){s=e?"":s}t.selectedDay=o.getDate(),t.drawMonth=t.selectedMonth=o.getMonth(),t.drawYear=t.selectedYear=o.getFullYear(),t.currentDay=s?o.getDate():0,t.currentMonth=s?o.getMonth():0,t.currentYear=s?o.getFullYear():0,this._adjustInstDate(t)}},_getDefaultDate:function(t){return this._restrictMinMax(t,this._determineDate(t,this._get(t,"defaultDate"),new Date))},_determineDate:function(r,t,e){var i,s,t=null==t||""===t?e:"string"==typeof t?function(t){try{return V.datepicker.parseDate(V.datepicker._get(r,"dateFormat"),t,V.datepicker._getFormatConfig(r))}catch(t){}for(var e=(t.toLowerCase().match(/^c/)?V.datepicker._getDate(r):null)||new Date,i=e.getFullYear(),s=e.getMonth(),n=e.getDate(),o=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,a=o.exec(t);a;){switch(a[2]||"d"){case"d":case"D":n+=parseInt(a[1],10);break;case"w":case"W":n+=7*parseInt(a[1],10);break;case"m":case"M":s+=parseInt(a[1],10),n=Math.min(n,V.datepicker._getDaysInMonth(i,s));break;case"y":case"Y":i+=parseInt(a[1],10),n=Math.min(n,V.datepicker._getDaysInMonth(i,s))}a=o.exec(t)}return new Date(i,s,n)}(t):"number"==typeof t?isNaN(t)?e:(i=t,(s=new Date).setDate(s.getDate()+i),s):new Date(t.getTime());return(t=t&&"Invalid Date"===t.toString()?e:t)&&(t.setHours(0),t.setMinutes(0),t.setSeconds(0),t.setMilliseconds(0)),this._daylightSavingAdjust(t)},_daylightSavingAdjust:function(t){return t?(t.setHours(12<t.getHours()?t.getHours()+2:0),t):null},_setDate:function(t,e,i){var s=!!e,n=t.selectedMonth,o=t.selectedYear,e=this._restrictMinMax(t,this._determineDate(t,e,new Date));t.selectedDay=t.currentDay=e.getDate(),t.drawMonth=t.selectedMonth=t.currentMonth=e.getMonth(),t.drawYear=t.selectedYear=t.currentYear=e.getFullYear(),n===t.selectedMonth&&o===t.selectedYear||i||this._notifyChange(t),this._adjustInstDate(t),t.input&&t.input.val(s?"":this._formatDate(t))},_getDate:function(t){return!!t.currentYear||t.input&&""===t.input.val()?null:this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay))},_attachHandlers:function(t){var e=this._get(t,"stepMonths"),i="#"+t.id.replace(/\\\\/g,"\\");t.dpDiv.find("[data-handler]").map(function(){var t={prev:function(){V.datepicker._adjustDate(i,-e,"M")},next:function(){V.datepicker._adjustDate(i,+e,"M")},hide:function(){V.datepicker._hideDatepicker()},today:function(){V.datepicker._gotoToday(i)},selectDay:function(){return V.datepicker._selectDay(i,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!!1},selectMonth:function(){return V.datepicker._selectMonthYear(i,this,"M"),!!1},selectYear:function(){return V.datepicker._selectMonthYear(i,this,"Y"),!!1}};V(this).on(this.getAttribute("data-event"),t[this.getAttribute("data-handler")])})},_generateHTML:function(t){var e,i,s,n,o,a,r,l,h,c,u,d,p,f,g,m,_,v,b,y,w,x,k,C,D,I,T,P,M,S,H,z,A=new Date,O=this._daylightSavingAdjust(new Date(A.getFullYear(),A.getMonth(),A.getDate())),N=this._get(t,"isRTL"),E=this._get(t,"showButtonPanel"),W=this._get(t,"hideIfNoPrevNext"),F=this._get(t,"navigationAsDateFormat"),L=this._getNumberOfMonths(t),R=this._get(t,"showCurrentAtPos"),A=this._get(t,"stepMonths"),Y=1!!==L[0]||1!!==L[1],B=this._daylightSavingAdjust(t.currentDay?new Date(t.currentYear,t.currentMonth,t.currentDay):new Date(9999,9,9)),j=this._getMinMaxDate(t,"min"),q=this._getMinMaxDate(t,"max"),K=t.drawMonth-R,U=t.drawYear;if(K<0&&(K+=12,U--),q)for(e=this._daylightSavingAdjust(new Date(q.getFullYear(),q.getMonth()-L[0]*L[1]+1,q.getDate())),e=j&&e<j?j:e;this._daylightSavingAdjust(new Date(U,K,1))>e;)--K<0&&(K=11,U--);for(t.drawMonth=K,t.drawYear=U,R=this._get(t,"prevText"),R=F?this.formatDate(R,this._daylightSavingAdjust(new Date(U,K-A,1)),this._getFormatConfig(t)):R,i=this._canAdjustMonth(t,-1,U,K)?V("<a>").attr({class:"ui-datepicker-prev ui-corner-all","data-handler":"prev","data-event":"click",title:R}).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-"+(N?"e":"w")).text(R))[0].outerHTML:W?"":V("<a>").attr({class:"ui-datepicker-prev ui-corner-all ui-state-disabled",title:R}).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-"+(N?"e":"w")).text(R))[0].outerHTML,R=this._get(t,"nextText"),R=F?this.formatDate(R,this._daylightSavingAdjust(new Date(U,K+A,1)),this._getFormatConfig(t)):R,s=this._canAdjustMonth(t,1,U,K)?V("<a>").attr({class:"ui-datepicker-next ui-corner-all","data-handler":"next","data-event":"click",title:R}).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-"+(N?"w":"e")).text(R))[0].outerHTML:W?"":V("<a>").attr({class:"ui-datepicker-next ui-corner-all ui-state-disabled",title:R}).append(V("<span>").attr("class","ui-icon ui-icon-circle-triangle-"+(N?"w":"e")).text(R))[0].outerHTML,A=this._get(t,"currentText"),W=this._get(t,"gotoCurrent")&&t.currentDay?B:O,A=F?this.formatDate(A,W,this._getFormatConfig(t)):A,R="",t.inline||(R=V("<button>").attr({type:"button",class:"ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all","data-handler":"hide","data-event":"click"}).text(this._get(t,"closeText"))[0].outerHTML),F="",E&&(F=V("<div class=''ui-datepicker-buttonpane ui-widget-content''>").append(N?R:"").append(this._isInRange(t,W)?V("<button>").attr({type:"button",class:"ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all","data-handler":"today","data-event":"click"}).text(A):"").append(N?"":R)[0].outerHTML),n=parseInt(this._get(t,"firstDay"),10),n=isNaN(n)?0:n,o=this._get(t,"showWeek"),a=this._get(t,"dayNames"),r=this._get(t,"dayNamesMin"),l=this._get(t,"monthNames"),h=this._get(t,"monthNamesShort"),c=this._get(t,"beforeShowDay"),u=this._get(t,"showOtherMonths"),d=this._get(t,"selectOtherMonths"),p=this._getDefaultDate(t),f="",m=0;m<L[0];m++){for(_="",this.maxRows=4,v=0;v<L[1];v++){if(b=this._daylightSavingAdjust(new Date(U,K,t.selectedDay)),y=" ui-corner-all",w="",Y){if(w+="<div class=''ui-datepicker-group",1<L[1])switch(v){case 0:w+=" ui-datepicker-group-first",y=" ui-corner-"+(N?"right":"left");break;case L[1]-1:w+=" ui-datepicker-group-last",y=" ui-corner-"+(N?"left":"right");break;default:w+=" ui-datepicker-group-middle",y=""}w+="''>"}for(w+="<div class=''ui-datepicker-header ui-widget-header ui-helper-clearfix"+y+"''>"+(/all|left/.test(y)&&0===m?N?s:i:"")+(/all|right/.test(y)&&0===m?N?i:s:"")+this._generateMonthYearHeader(t,K,U,j,q,0<m||0<v,l,h)+"</div><table class=''ui-datepicker-calendar''><thead><tr>",x=o?"<th class=''ui-datepicker-week-col''>"+this._get(t,"weekHeader")+"</th>":"",g=0;g<7;g++)x+="<th scope=''col''"+(5<=(g+n+6)%7?" class=''ui-datepicker-week-end''":"")+"><span title=''"+a[k=(g+n)%7]+"''>"+r[k]+"</span></th>";for(w+=x+"</tr></thead><tbody>",D=this._getDaysInMonth(U,K),U===t.selectedYear&&K===t.selectedMonth&&(t.selectedDay=Math.min(t.selectedDay,D)),C=(this._getFirstDayOfMonth(U,K)-n+7)%7,D=Math.ceil((C+D)/7),I=Y&&this.maxRows>D?this.maxRows:D,this.maxRows=I,T=this._daylightSavingAdjust(new Date(U,K,1-C)),P=0;P<I;P++){for(w+="<tr>",M=o?"<td class=''ui-datepicker-week-col''>"+this._get(t,"calculateWeek")(T)+"</td>":"",g=0;g<7;g++)S=c?c.apply(t.input?t.input[0]:null,[T]):[!!0,""],z=(H=T.getMonth()!!==K)&&!!d||!!S[0]||j&&T<j||q&&q<T,M+="<td class=''"+(5<=(g+n+6)%7?" ui-datepicker-week-end":"")+(H?" ui-datepicker-other-month":"")+(T.getTime()===b.getTime()&&K===t.selectedMonth&&t._keyEvent||p.getTime()===T.getTime()&&p.getTime()===b.getTime()?" "+this._dayOverClass:"")+(z?" "+this._unselectableClass+" ui-state-disabled":"")+(H&&!!u?"":" "+S[1]+(T.getTime()===B.getTime()?" "+this._currentClass:"")+(T.getTime()===O.getTime()?" ui-datepicker-today":""))+"''"+(H&&!!u||!!S[2]?"":" title=''"+S[2].replace(/''/g,"&#39;")+"''")+(z?"":" data-handler=''selectDay'' data-event=''click'' data-month=''"+T.getMonth()+"'' data-year=''"+T.getFullYear()+"''")+">"+(H&&!!u?"&#xa0;":z?"<span class=''ui-state-default''>"+T.getDate()+"</span>":"<a class=''ui-state-default"+(T.getTime()===O.getTime()?" ui-state-highlight":"")+(T.getTime()===B.getTime()?" ui-state-active":"")+(H?" ui-priority-secondary":"")+"'' href=''#'' aria-current=''"+(T.getTime()===B.getTime()?"true":"false")+"'' data-date=''"+T.getDate()+"''>"+T.getDate()+"</a>")+"</td>",T.setDate(T.getDate()+1),T=this._daylightSavingAdjust(T);w+=M+"</tr>"}11<++K&&(K=0,U++),_+=w+="</tbody></table>"+(Y?"</div>"+(0<L[0]&&v===L[1]-1?"<div class=''ui-datepicker-row-break''></div>":""):"")}f+=_}return f+=F,t._keyEvent=!!1,f},_generateMonthYearHeader:function(t,e,i,s,n,o,a,r){var l,h,c,u,d,p,f=this._get(t,"changeMonth"),g=this._get(t,"changeYear"),m=this._get(t,"showMonthAfterYear"),_=this._get(t,"selectMonthLabel"),v=this._get(t,"selectYearLabel"),b="<div class=''ui-datepicker-title''>",y="";if(o||!!f)y+="<span class=''ui-datepicker-month''>"+a[e]+"</span>";else{for(l=s&&s.getFullYear()===i,h=n&&n.getFullYear()===i,y+="<select class=''ui-datepicker-month'' aria-label=''"+_+"'' data-handler=''selectMonth'' data-event=''change''>",c=0;c<12;c++)(!!l||c>=s.getMonth())&&(!!h||c<=n.getMonth())&&(y+="<option value=''"+c+"''"+(c===e?" selected=''selected''":"")+">"+r[c]+"</option>");y+="</select>"}if(m||(b+=y+(!!o&&f&&g?"":"&#xa0;")),!!t.yearshtml)if(t.yearshtml="",o||!!g)b+="<span class=''ui-datepicker-year''>"+i+"</span>";else{for(a=this._get(t,"yearRange").split(":"),u=(new Date).getFullYear(),d=(_=function(t){t=t.match(/c[+\-].*/)?i+parseInt(t.substring(1),10):t.match(/[+\-].*/)?u+parseInt(t,10):parseInt(t,10);return isNaN(t)?u:t})(a[0]),p=Math.max(d,_(a[1]||"")),d=s?Math.max(d,s.getFullYear()):d,p=n?Math.min(p,n.getFullYear()):p,t.yearshtml+="<select class=''ui-datepicker-year'' aria-label=''"+v+"'' data-handler=''selectYear'' data-event=''change''>";d<=p;d++)t.yearshtml+="<option value=''"+d+"''"+(d===i?" selected=''selected''":"")+">"+d+"</option>";t.yearshtml+="</select>",b+=t.yearshtml,t.yearshtml=null}return b+=this._get(t,"yearSuffix"),m&&(b+=(!!o&&f&&g?"":"&#xa0;")+y),b+="</div>"},_adjustInstDate:function(t,e,i){var s=t.selectedYear+("Y"===i?e:0),n=t.selectedMonth+("M"===i?e:0),e=Math.min(t.selectedDay,this._getDaysInMonth(s,n))+("D"===i?e:0),e=this._restrictMinMax(t,this._daylightSavingAdjust(new Date(s,n,e)));t.selectedDay=e.getDate(),t.drawMonth=t.selectedMonth=e.getMonth(),t.drawYear=t.selectedYear=e.getFullYear(),"M"!!==i&&"Y"!!==i||this._notifyChange(t)},_restrictMinMax:function(t,e){var i=this._getMinMaxDate(t,"min"),t=this._getMinMaxDate(t,"max"),e=i&&e<i?i:e;return t&&t<e?t:e},_notifyChange:function(t){var e=this._get(t,"onChangeMonthYear");e&&e.apply(t.input?t.input[0]:null,[t.selectedYear,t.selectedMonth+1,t])},_getNumberOfMonths:function(t){t=this._get(t,"numberOfMonths");return null==t?[1,1]:"number"==typeof t?[1,t]:t},_getMinMaxDate:function(t,e){return this._determineDate(t,this._get(t,e+"Date"),null)},_getDaysInMonth:function(t,e){return 32-this._daylightSavingAdjust(new Date(t,e,32)).getDate()},_getFirstDayOfMonth:function(t,e){return new Date(t,e,1).getDay()},_canAdjustMonth:function(t,e,i,s){var n=this._getNumberOfMonths(t),n=this._daylightSavingAdjust(new Date(i,s+(e<0?e:n[0]*n[1]),1));return e<0&&n.setDate(this._getDaysInMonth(n.getFullYear(),n.getMonth())),this._isInRange(t,n)},_isInRange:function(t,e){var i=this._getMinMaxDate(t,"min"),s=this._getMinMaxDate(t,"max"),n=null,o=null,a=this._get(t,"yearRange");return a&&(t=a.split(":"),a=(new Date).getFullYear(),n=parseInt(t[0],10),o=parseInt(t[1],10),t[0].match(/[+\-].*/)&&(n+=a),t[1].match(/[+\-].*/)&&(o+=a)),(!!i||e.getTime()>=i.getTime())&&(!!s||e.getTime()<=s.getTime())&&(!!n||e.getFullYear()>=n)&&(!!o||e.getFullYear()<=o)},_getFormatConfig:function(t){var e=this._get(t,"shortYearCutoff");return{shortYearCutoff:e="string"!!=typeof e?e:(new Date).getFullYear()%100+parseInt(e,10),dayNamesShort:this._get(t,"dayNamesShort"),dayNames:this._get(t,"dayNames"),monthNamesShort:this._get(t,"monthNamesShort"),monthNames:this._get(t,"monthNames")}},_formatDate:function(t,e,i,s){e||(t.currentDay=t.selectedDay,t.currentMonth=t.selectedMonth,t.currentYear=t.selectedYear);e=e?"object"==typeof e?e:this._daylightSavingAdjust(new Date(s,i,e)):this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return this.formatDate(this._get(t,"dateFormat"),e,this._getFormatConfig(t))}}),V.fn.datepicker=function(t){if(!!this.length)return this;V.datepicker.initialized||(V(document).on("mousedown",V.datepicker._checkExternalClick),V.datepicker.initialized=!!0),0===V("#"+V.datepicker._mainDivId).length&&V("body").append(V.datepicker.dpDiv);var e=Array.prototype.slice.call(arguments,1);return"string"==typeof t&&("isDisabled"===t||"getDate"===t||"widget"===t)||"option"===t&&2===arguments.length&&"string"==typeof arguments[1]?V.datepicker["_"+t+"Datepicker"].apply(V.datepicker,[this[0]].concat(e)):this.each(function(){"string"==typeof t?V.datepicker["_"+t+"Datepicker"].apply(V.datepicker,[this].concat(e)):V.datepicker._attachDatepicker(this,t)})},V.datepicker=new st,V.datepicker.initialized=!!1,V.datepicker.uuid=(new Date).getTime(),V.datepicker.version="1.13.2";V.datepicker,V.ui.ie=!!!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var rt=!!1;V(document).on("mouseup",function(){rt=!!1});V.widget("ui.mouse",{version:"1.13.2",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(t){if(!!0===V.data(t.target,e.widgetName+".preventClickEvent"))return V.removeData(t.target,e.widgetName+".preventClickEvent"),t.stopImmediatePropagation(),!!1}),this.started=!!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(!!rt){this._mouseMoved=!!1,this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var e=this,i=1===t.which,s=!!("string"!!=typeof this.options.cancel||!!t.target.nodeName)&&V(t.target).closest(this.options.cancel).length;return i&&!!s&&this._mouseCapture(t)?(this.mouseDelayMet=!!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){e.mouseDelayMet=!!0},this.options.delay)),this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=!!1!!==this._mouseStart(t),!!this._mouseStarted)?(t.preventDefault(),!!0):(!!0===V.data(t.target,this.widgetName+".preventClickEvent")&&V.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return e._mouseMove(t)},this._mouseUpDelegate=function(t){return e._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),rt=!!0)):!!0}},_mouseMove:function(t){if(this._mouseMoved){if(V.ui.ie&&(!!document.documentMode||document.documentMode<9)&&!!t.button)return this._mouseUp(t);if(!!t.which)if(t.originalEvent.altKey||t.originalEvent.ctrlKey||t.originalEvent.metaKey||t.originalEvent.shiftKey)this.ignoreMissingWhich=!!0;else if(!!this.ignoreMissingWhich)return this._mouseUp(t)}return(t.which||t.button)&&(this._mouseMoved=!!0),this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=!!1!!==this._mouseStart(this._mouseDownEvent,t),this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!!this._mouseStarted)},_mouseUp:function(t){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!!1,t.target===this._mouseDownEvent.target&&V.data(t.target,this.widgetName+".preventClickEvent",!!0),this._mouseStop(t)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!!1,rt=!!1,t.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!!0}}),V.ui.plugin={add:function(t,e,i){var s,n=V.ui[t].prototype;for(s in i)n.plugins[s]=n.plugins[s]||[],n.plugins[s].push([e,i[s]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!!==t.element[0].parentNode.nodeType))for(n=0;n<o.length;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},V.ui.safeBlur=function(t){t&&"body"!!==t.nodeName.toLowerCase()&&V(t).trigger("blur")};V.widget("ui.draggable",V.ui.mouse,{version:"1.13.2",widgetEventPrefix:"drag",options:{addClasses:!!0,appendTo:"parent",axis:!!1,connectToSortable:!!1,containment:!!1,cursor:"auto",cursorAt:!!1,grid:!!1,handle:!!1,helper:"original",iframeFix:!!1,opacity:!!1,refreshPositions:!!1,revert:!!1,revertDuration:500,scope:"default",scroll:!!0,scrollSensitivity:20,scrollSpeed:20,snap:!!1,snapMode:"both",snapTolerance:20,stack:!!1,zIndex:!!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){(this.helper||this.element).is(".ui-draggable-dragging")?this.destroyOnClear=!!0:(this._removeHandleClassName(),this._mouseDestroy())},_mouseCapture:function(t){var e=this.options;return!!(this.helper||e.disabled||0<V(t.target).closest(".ui-resizable-handle").length)&&(this.handle=this._getHandle(t),!!!!this.handle&&(this._blurActiveElement(t),this._blockFrames(!!0===e.iframeFix?"iframe":e.iframeFix),!!0))},_blockFrames:function(t){this.iframeBlocks=this.document.find(t).map(function(){var t=V(this);return V("<div>").css("position","absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(t){var e=V.ui.safeActiveElement(this.document[0]);V(t.target).closest(e).length||V.ui.safeBlur(e)},_mouseStart:function(t){var e=this.options;return this.helper=this._createHelper(t),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),V.ui.ddmanager&&(V.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=0<this.helper.parents().filter(function(){return"fixed"===V(this).css("position")}).length,this.positionAbs=this.element.offset(),this._refreshOffsets(t),this.originalPosition=this.position=this._generatePosition(t,!!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,e.cursorAt&&this._adjustOffsetFromHelper(e.cursorAt),this._setContainment(),!!1===this._trigger("start",t)?(this._clear(),!!1):(this._cacheHelperProportions(),V.ui.ddmanager&&!!e.dropBehaviour&&V.ui.ddmanager.prepareOffsets(this,t),this._mouseDrag(t,!!0),V.ui.ddmanager&&V.ui.ddmanager.dragStart(this,t),!!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(t,e){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!!0),this.positionAbs=this._convertPositionTo("absolute"),!!e){e=this._uiHash();if(!!1===this._trigger("drag",t,e))return this._mouseUp(new V.Event("mouseup",t)),!!1;this.position=e.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",V.ui.ddmanager&&V.ui.ddmanager.drag(this,t),!!1},_mouseStop:function(t){var e=this,i=!!1;return V.ui.ddmanager&&!!this.options.dropBehaviour&&(i=V.ui.ddmanager.drop(this,t)),this.dropped&&(i=this.dropped,this.dropped=!!1),"invalid"===this.options.revert&&!!i||"valid"===this.options.revert&&i||!!0===this.options.revert||"function"==typeof this.options.revert&&this.options.revert.call(this.element,i)?V(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){!!1!!==e._trigger("stop",t)&&e._clear()}):!!1!!==this._trigger("stop",t)&&this._clear(),!!1},_mouseUp:function(t){return this._unblockFrames(),V.ui.ddmanager&&V.ui.ddmanager.dragStop(this,t),this.handleElement.is(t.target)&&this.element.trigger("focus"),V.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new V.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(t){return!!this.options.handle||!!!!V(t.target).closest(this.element.find(this.options.handle)).length},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(t){var e=this.options,i="function"==typeof e.helper,t=i?V(e.helper.apply(this.element[0],[t])):"clone"===e.helper?this.element.clone().removeAttr("id"):this.element;return t.parents("body").length||t.appendTo("parent"===e.appendTo?this.element[0].parentNode:e.appendTo),i&&t[0]===this.element[0]&&this._setPositionRelative(),t[0]===this.element[0]||/(fixed|absolute)/.test(t.css("position"))||t.css("position","absolute"),t},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),"left"in(t=Array.isArray(t)?{left:+t[0],top:+t[1]||0}:t)&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),e=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!!==e&&V.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),{top:(t=this._isRootNode(this.offsetParent[0])?{top:0,left:0}:t).top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,e,i,s=this.options,n=this.document[0];this.relativeContainer=null,s.containment?"window"!!==s.containment?"document"!!==s.containment?s.containment.constructor!!==Array?("parent"===s.containment&&(s.containment=this.helper[0].parentNode),(i=(e=V(s.containment))[0])&&(t=/(scroll|auto)/.test(e.css("overflow")),this.containment=[(parseInt(e.css("borderLeftWidth"),10)||0)+(parseInt(e.css("paddingLeft"),10)||0),(parseInt(e.css("borderTopWidth"),10)||0)+(parseInt(e.css("paddingTop"),10)||0),(t?Math.max(i.scrollWidth,i.offsetWidth):i.offsetWidth)-(parseInt(e.css("borderRightWidth"),10)||0)-(parseInt(e.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(i.scrollHeight,i.offsetHeight):i.offsetHeight)-(parseInt(e.css("borderBottomWidth"),10)||0)-(parseInt(e.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=e)):this.containment=s.containment:this.containment=[0,0,V(n).width()-this.helperProportions.width-this.margins.left,(V(n).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]:this.containment=[V(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,V(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,V(window).scrollLeft()+V(window).width()-this.helperProportions.width-this.margins.left,V(window).scrollTop()+(V(window).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]:this.containment=null},_convertPositionTo:function(t,e){e=e||this.position;var i="absolute"===t?1:-1,t=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:t?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:t?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s=this.options,n=this._isRootNode(this.scrollParent[0]),o=t.pageX,a=t.pageY;return n&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(i=this.relativeContainer?(i=this.relativeContainer.offset(),[this.containment[0]+i.left,this.containment[1]+i.top,this.containment[2]+i.left,this.containment[3]+i.top]):this.containment,t.pageX-this.offset.click.left<i[0]&&(o=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(a=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(o=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(a=i[3]+this.offset.click.top)),s.grid&&(t=s.grid[1]?this.originalPageY+Math.round((a-this.originalPageY)/s.grid[1])*s.grid[1]:this.originalPageY,a=!!i||t-this.offset.click.top>=i[1]||t-this.offset.click.top>i[3]?t:t-this.offset.click.top>=i[1]?t-s.grid[1]:t+s.grid[1],t=s.grid[0]?this.originalPageX+Math.round((o-this.originalPageX)/s.grid[0])*s.grid[0]:this.originalPageX,o=!!i||t-this.offset.click.left>=i[0]||t-this.offset.click.left>i[2]?t:t-this.offset.click.left>=i[0]?t-s.grid[0]:t+s.grid[0]),"y"===s.axis&&(o=this.originalPageX),"x"===s.axis&&(a=this.originalPageY)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:n?0:this.offset.scroll.top),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:n?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!!1,this.destroyOnClear&&this.destroy()},_trigger:function(t,e,i){return i=i||this._uiHash(),V.ui.plugin.call(this,t,[e,i,this],!!0),/^(drag|start|stop)/.test(t)&&(this.positionAbs=this._convertPositionTo("absolute"),i.offset=this.positionAbs),V.Widget.prototype._trigger.call(this,t,e,i)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),V.ui.plugin.add("draggable","connectToSortable",{start:function(e,t,i){var s=V.extend({},t,{item:i.element});i.sortables=[],V(i.options.connectToSortable).each(function(){var t=V(this).sortable("instance");t&&!!t.options.disabled&&(i.sortables.push(t),t.refreshPositions(),t._trigger("activate",e,s))})},stop:function(e,t,i){var s=V.extend({},t,{item:i.element});i.cancelHelperRemoval=!!1,V.each(i.sortables,function(){var t=this;t.isOver?(t.isOver=0,i.cancelHelperRemoval=!!0,t.cancelHelperRemoval=!!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!!0,t._trigger("deactivate",e,s))})},drag:function(i,s,n){V.each(n.sortables,function(){var t=!!1,e=this;e.positionAbs=n.positionAbs,e.helperProportions=n.helperProportions,e.offset.click=n.offset.click,e._intersectsWith(e.containerCache)&&(t=!!0,V.each(n.sortables,function(){return this.positionAbs=n.positionAbs,this.helperProportions=n.helperProportions,this.offset.click=n.offset.click,t=this!!==e&&this._intersectsWith(this.containerCache)&&V.contains(e.element[0],this.element[0])?!!1:t})),t?(e.isOver||(e.isOver=1,n._parent=s.helper.parent(),e.currentItem=s.helper.appendTo(e.element).data("ui-sortable-item",!!0),e.options._helper=e.options.helper,e.options.helper=function(){return s.helper[0]},i.target=e.currentItem[0],e._mouseCapture(i,!!0),e._mouseStart(i,!!0,!!0),e.offset.click.top=n.offset.click.top,e.offset.click.left=n.offset.click.left,e.offset.parent.left-=n.offset.parent.left-e.offset.parent.left,e.offset.parent.top-=n.offset.parent.top-e.offset.parent.top,n._trigger("toSortable",i),n.dropped=e.element,V.each(n.sortables,function(){this.refreshPositions()}),n.currentItem=n.element,e.fromOutside=n),e.currentItem&&(e._mouseDrag(i),s.position=e.position)):e.isOver&&(e.isOver=0,e.cancelHelperRemoval=!!0,e.options._revert=e.options.revert,e.options.revert=!!1,e._trigger("out",i,e._uiHash(e)),e._mouseStop(i,!!0),e.options.revert=e.options._revert,e.options.helper=e.options._helper,e.placeholder&&e.placeholder.remove(),s.helper.appendTo(n._parent),n._refreshOffsets(i),s.position=n._generatePosition(i,!!0),n._trigger("fromSortable",i),n.dropped=!!1,V.each(n.sortables,function(){this.refreshPositions()}))})}}),V.ui.plugin.add("draggable","cursor",{start:function(t,e,i){var s=V("body"),i=i.options;s.css("cursor")&&(i._cursor=s.css("cursor")),s.css("cursor",i.cursor)},stop:function(t,e,i){i=i.options;i._cursor&&V("body").css("cursor",i._cursor)}}),V.ui.plugin.add("draggable","opacity",{start:function(t,e,i){e=V(e.helper),i=i.options;e.css("opacity")&&(i._opacity=e.css("opacity")),e.css("opacity",i.opacity)},stop:function(t,e,i){i=i.options;i._opacity&&V(e.helper).css("opacity",i._opacity)}}),V.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!!1)),i.scrollParentNotHidden[0]!!==i.document[0]&&"HTML"!!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(t,e,i){var s=i.options,n=!!1,o=i.scrollParentNotHidden[0],a=i.document[0];o!!==a&&"HTML"!!==o.tagName?(s.axis&&"x"===s.axis||(i.overflowOffset.top+o.offsetHeight-t.pageY<s.scrollSensitivity?o.scrollTop=n=o.scrollTop+s.scrollSpeed:t.pageY-i.overflowOffset.top<s.scrollSensitivity&&(o.scrollTop=n=o.scrollTop-s.scrollSpeed)),s.axis&&"y"===s.axis||(i.overflowOffset.left+o.offsetWidth-t.pageX<s.scrollSensitivity?o.scrollLeft=n=o.scrollLeft+s.scrollSpeed:t.pageX-i.overflowOffset.left<s.scrollSensitivity&&(o.scrollLeft=n=o.scrollLeft-s.scrollSpeed))):(s.axis&&"x"===s.axis||(t.pageY-V(a).scrollTop()<s.scrollSensitivity?n=V(a).scrollTop(V(a).scrollTop()-s.scrollSpeed):V(window).height()-(t.pageY-V(a).scrollTop())<s.scrollSensitivity&&(n=V(a).scrollTop(V(a).scrollTop()+s.scrollSpeed))),s.axis&&"y"===s.axis||(t.pageX-V(a).scrollLeft()<s.scrollSensitivity?n=V(a).scrollLeft(V(a).scrollLeft()-s.scrollSpeed):V(window).width()-(t.pageX-V(a).scrollLeft())<s.scrollSensitivity&&(n=V(a).scrollLeft(V(a).scrollLeft()+s.scrollSpeed)))),!!1!!==n&&V.ui.ddmanager&&!!s.dropBehaviour&&V.ui.ddmanager.prepareOffsets(i,t)}}),V.ui.plugin.add("draggable","snap",{start:function(t,e,i){var s=i.options;i.snapElements=[],V(s.snap.constructor!!==String?s.snap.items||":data(ui-draggable)":s.snap).each(function(){var t=V(this),e=t.offset();this!!==i.element[0]&&i.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:e.top,left:e.left})})},drag:function(t,e,i){for(var s,n,o,a,r,l,h,c,u,d=i.options,p=d.snapTolerance,f=e.offset.left,g=f+i.helperProportions.width,m=e.offset.top,_=m+i.helperProportions.height,v=i.snapElements.length-1;0<=v;v--)l=(r=i.snapElements[v].left-i.margins.left)+i.snapElements[v].width,c=(h=i.snapElements[v].top-i.margins.top)+i.snapElements[v].height,g<r-p||l+p<f||_<h-p||c+p<m||!!V.contains(i.snapElements[v].item.ownerDocument,i.snapElements[v].item)?(i.snapElements[v].snapping&&i.options.snap.release&&i.options.snap.release.call(i.element,t,V.extend(i._uiHash(),{snapItem:i.snapElements[v].item})),i.snapElements[v].snapping=!!1):("inner"!!==d.snapMode&&(s=Math.abs(h-_)<=p,n=Math.abs(c-m)<=p,o=Math.abs(r-g)<=p,a=Math.abs(l-f)<=p,s&&(e.position.top=i._convertPositionTo("relative",{top:h-i.helperProportions.height,left:0}).top),n&&(e.position.top=i._convertPositionTo("relative",{top:c,left:0}).top),o&&(e.position.left=i._convertPositionTo("relative",{top:0,left:r-i.helperProportions.width}).left),a&&(e.position.left=i._convertPositionTo("relative",{top:0,left:l}).left)),u=s||n||o||a,"outer"!!==d.snapMode&&(s=Math.abs(h-m)<=p,n=Math.abs(c-_)<=p,o=Math.abs(r-f)<=p,a=Math.abs(l-g)<=p,s&&(e.position.top=i._convertPositionTo("relative",{top:h,left:0}).top),n&&(e.position.top=i._convertPositionTo("relative",{top:c-i.helperProportions.height,left:0}).top),o&&(e.position.left=i._convertPositionTo("relative",{top:0,left:r}).left),a&&(e.position.left=i._convertPositionTo("relative",{top:0,left:l-i.helperProportions.width}).left)),!!i.snapElements[v].snapping&&(s||n||o||a||u)&&i.options.snap.snap&&i.options.snap.snap.call(i.element,t,V.extend(i._uiHash(),{snapItem:i.snapElements[v].item})),i.snapElements[v].snapping=s||n||o||a||u)}}),V.ui.plugin.add("draggable","stack",{start:function(t,e,i){var s,i=i.options,i=V.makeArray(V(i.stack)).sort(function(t,e){return(parseInt(V(t).css("zIndex"),10)||0)-(parseInt(V(e).css("zIndex"),10)||0)});i.length&&(s=parseInt(V(i[0]).css("zIndex"),10)||0,V(i).each(function(t){V(this).css("zIndex",s+t)}),this.css("zIndex",s+i.length))}}),V.ui.plugin.add("draggable","zIndex",{start:function(t,e,i){e=V(e.helper),i=i.options;e.css("zIndex")&&(i._zIndex=e.css("zIndex")),e.css("zIndex",i.zIndex)},stop:function(t,e,i){i=i.options;i._zIndex&&V(e.helper).css("zIndex",i._zIndex)}});V.ui.draggable;V.widget("ui.resizable",V.ui.mouse,{version:"1.13.2",widgetEventPrefix:"resize",options:{alsoResize:!!1,animate:!!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!!1,autoHide:!!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!!1,ghost:!!1,grid:!!1,handles:"e,s,se",helper:!!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!!isNaN(parseFloat(t))},_hasScroll:function(t,e){if("hidden"===V(t).css("overflow"))return!!1;var i=e&&"left"===e?"scrollLeft":"scrollTop",e=!!1;if(0<t[i])return!!0;try{t[i]=1,e=0<t[i],t[i]=0}catch(t){}return e},_create:function(){var t,e=this.options,i=this;this._addClass("ui-resizable"),V.extend(this,{_aspectRatio:!!!!e.aspectRatio,aspectRatio:e.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:e.helper||e.ghost||e.animate?e.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(V("<div class=''ui-wrapper''></div>").css({overflow:"hidden",position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!!0,t={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(t),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(t),this._proportionallyResize()),this._setupHandles(),e.autoHide&&V(this.element).on("mouseenter",function(){e.disabled||(i._removeClass("ui-resizable-autohide"),i._handles.show())}).on("mouseleave",function(){e.disabled||i.resizing||(i._addClass("ui-resizable-autohide"),i._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy(),this._addedHandles.remove();function t(t){V(t).removeData("resizable").removeData("ui-resizable").off(".resizable")}var e;return this.elementIsWrapper&&(t(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),t(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;case"aspectRatio":this._aspectRatio=!!!!e}},_setupHandles:function(){var t,e,i,s,n,o=this.options,a=this;if(this.handles=o.handles||(V(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=V(),this._addedHandles=V(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),i=this.handles.split(","),this.handles={},e=0;e<i.length;e++)s="ui-resizable-"+(t=String.prototype.trim.call(i[e])),n=V("<div>"),this._addClass(n,"ui-resizable-handle "+s),n.css({zIndex:o.zIndex}),this.handles[t]=".ui-resizable-"+t,this.element.children(this.handles[t]).length||(this.element.append(n),this._addedHandles=this._addedHandles.add(n));this._renderAxis=function(t){var e,i,s;for(e in t=t||this.element,this.handles)this.handles[e].constructor===String?this.handles[e]=this.element.children(this.handles[e]).first().show():(this.handles[e].jquery||this.handles[e].nodeType)&&(this.handles[e]=V(this.handles[e]),this._on(this.handles[e],{mousedown:a._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(i=V(this.handles[e],this.element),s=/sw|ne|nw|se|n|s/.test(e)?i.outerHeight():i.outerWidth(),i=["padding",/ne|nw|n/.test(e)?"Top":/se|sw|s/.test(e)?"Bottom":/^e$/.test(e)?"Right":"Left"].join(""),t.css(i,s),this._proportionallyResize()),this._handles=this._handles.add(this.handles[e])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){a.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),a.axis=n&&n[1]?n[1]:"se")}),o.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._addedHandles.remove()},_mouseCapture:function(t){var e,i,s=!!1;for(e in this.handles)(i=V(this.handles[e])[0])!!==t.target&&!!V.contains(i,t.target)||(s=!!0);return!!this.options.disabled&&s},_mouseStart:function(t){var e,i,s=this.options,n=this.element;return this.resizing=!!0,this._renderProxy(),e=this._num(this.helper.css("left")),i=this._num(this.helper.css("top")),s.containment&&(e+=V(s.containment).scrollLeft()||0,i+=V(s.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:e,top:i},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:n.width(),height:n.height()},this.originalSize=this._helper?{width:n.outerWidth(),height:n.outerHeight()}:{width:n.width(),height:n.height()},this.sizeDiff={width:n.outerWidth()-n.width(),height:n.outerHeight()-n.height()},this.originalPosition={left:e,top:i},this.originalMousePosition={left:t.pageX,top:t.pageY},this.aspectRatio="number"==typeof s.aspectRatio?s.aspectRatio:this.originalSize.width/this.originalSize.height||1,s=V(".ui-resizable-"+this.axis).css("cursor"),V("body").css("cursor","auto"===s?this.axis+"-resize":s),this._addClass("ui-resizable-resizing"),this._propagate("start",t),!!0},_mouseDrag:function(t){var e=this.originalMousePosition,i=this.axis,s=t.pageX-e.left||0,e=t.pageY-e.top||0,i=this._change[i];return this._updatePrevProperties(),i&&(e=i.apply(this,[t,s,e]),this._updateVirtualBoundaries(t.shiftKey),(this._aspectRatio||t.shiftKey)&&(e=this._updateRatio(e,t)),e=this._respectSize(e,t),this._updateCache(e),this._propagate("resize",t),e=this._applyChanges(),!!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),V.isEmptyObject(e)||(this._updatePrevProperties(),this._trigger("resize",t,this.ui()),this._applyChanges())),!!1},_mouseStop:function(t){this.resizing=!!1;var e,i,s,n=this.options,o=this;return this._helper&&(s=(e=(i=this._proportionallyResizeElements).length&&/textarea/i.test(i[0].nodeName))&&this._hasScroll(i[0],"left")?0:o.sizeDiff.height,i=e?0:o.sizeDiff.width,e={width:o.helper.width()-i,height:o.helper.height()-s},i=parseFloat(o.element.css("left"))+(o.position.left-o.originalPosition.left)||null,s=parseFloat(o.element.css("top"))+(o.position.top-o.originalPosition.top)||null,n.animate||this.element.css(V.extend(e,{top:s,left:i})),o.helper.height(o.size.height),o.helper.width(o.size.width),this._helper&&!!n.animate&&this._proportionallyResize()),V("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s=this.options,n={minWidth:this._isNumber(s.minWidth)?s.minWidth:0,maxWidth:this._isNumber(s.maxWidth)?s.maxWidth:1/0,minHeight:this._isNumber(s.minHeight)?s.minHeight:0,maxHeight:this._isNumber(s.maxHeight)?s.maxHeight:1/0};(this._aspectRatio||t)&&(e=n.minHeight*this.aspectRatio,i=n.minWidth/this.aspectRatio,s=n.maxHeight*this.aspectRatio,t=n.maxWidth/this.aspectRatio,e>n.minWidth&&(n.minWidth=e),i>n.minHeight&&(n.minHeight=i),s<n.maxWidth&&(n.maxWidth=s),t<n.maxHeight&&(n.maxHeight=t)),this._vBoundaries=n},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,l=this.originalPosition.top+this.originalSize.height,h=/sw|nw|w/.test(i),i=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&h&&(t.left=r-e.minWidth),s&&h&&(t.left=r-e.maxWidth),a&&i&&(t.top=l-e.minHeight),n&&i&&(t.top=l-e.maxHeight),t.width||t.height||t.left||!!t.top?t.width||t.height||t.top||!!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];e<4;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;e<this._proportionallyResizeElements.length;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var t=this.element,e=this.options;this.elementOffset=t.offset(),this._helper?(this.helper=this.helper||V("<div></div>").css({overflow:"hidden"}),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++e.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize;return{left:this.originalPosition.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize;return{top:this.originalPosition.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(t,e,i){return V.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,e,i]))},sw:function(t,e,i){return V.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,e,i]))},ne:function(t,e,i){return V.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,e,i]))},nw:function(t,e,i){return V.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,e,i]))}},_propagate:function(t,e){V.ui.plugin.call(this,t,[e,this.ui()]),"resize"!!==t&&this._trigger(t,e,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),V.ui.plugin.add("resizable","animate",{stop:function(e){var i=V(this).resizable("instance"),t=i.options,s=i._proportionallyResizeElements,n=s.length&&/textarea/i.test(s[0].nodeName),o=n&&i._hasScroll(s[0],"left")?0:i.sizeDiff.height,a=n?0:i.sizeDiff.width,n={width:i.size.width-a,height:i.size.height-o},a=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,o=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(V.extend(n,o&&a?{top:o,left:a}:{}),{duration:t.animateDuration,easing:t.animateEasing,step:function(){var t={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};s&&s.length&&V(s[0]).css({width:t.width,height:t.height}),i._updateCache(t),i._propagate("resize",e)}})}}),V.ui.plugin.add("resizable","containment",{start:function(){var i,s,n=V(this).resizable("instance"),t=n.options,e=n.element,o=t.containment,a=o instanceof V?o.get(0):/parent/.test(o)?e.parent().get(0):o;a&&(n.containerElement=V(a),/document/.test(o)||o===document?(n.containerOffset={left:0,top:0},n.containerPosition={left:0,top:0},n.parentData={element:V(document),left:0,top:0,width:V(document).width(),height:V(document).height()||document.body.parentNode.scrollHeight}):(i=V(a),s=[],V(["Top","Right","Left","Bottom"]).each(function(t,e){s[t]=n._num(i.css("padding"+e))}),n.containerOffset=i.offset(),n.containerPosition=i.position(),n.containerSize={height:i.innerHeight()-s[3],width:i.innerWidth()-s[1]},t=n.containerOffset,e=n.containerSize.height,o=n.containerSize.width,o=n._hasScroll(a,"left")?a.scrollWidth:o,e=n._hasScroll(a)?a.scrollHeight:e,n.parentData={element:a,left:t.left,top:t.top,width:o,height:e}))},resize:function(t){var e=V(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.position,o=e._aspectRatio||t.shiftKey,a={top:0,left:0},r=e.containerElement,t=!!0;r[0]!!==document&&/static/.test(r.css("position"))&&(a=s),n.left<(e._helper?s.left:0)&&(e.size.width=e.size.width+(e._helper?e.position.left-s.left:e.position.left-a.left),o&&(e.size.height=e.size.width/e.aspectRatio,t=!!1),e.position.left=i.helper?s.left:0),n.top<(e._helper?s.top:0)&&(e.size.height=e.size.height+(e._helper?e.position.top-s.top:e.position.top),o&&(e.size.width=e.size.height*e.aspectRatio,t=!!1),e.position.top=e._helper?s.top:0),i=e.containerElement.get(0)===e.element.parent().get(0),n=/relative|absolute/.test(e.containerElement.css("position")),i&&n?(e.offset.left=e.parentData.left+e.position.left,e.offset.top=e.parentData.top+e.position.top):(e.offset.left=e.element.offset().left,e.offset.top=e.element.offset().top),n=Math.abs(e.sizeDiff.width+(e._helper?e.offset.left-a.left:e.offset.left-s.left)),s=Math.abs(e.sizeDiff.height+(e._helper?e.offset.top-a.top:e.offset.top-s.top)),n+e.size.width>=e.parentData.width&&(e.size.width=e.parentData.width-n,o&&(e.size.height=e.size.width/e.aspectRatio,t=!!1)),s+e.size.height>=e.parentData.height&&(e.size.height=e.parentData.height-s,o&&(e.size.width=e.size.height*e.aspectRatio,t=!!1)),t||(e.position.left=e.prevPosition.left,e.position.top=e.prevPosition.top,e.size.width=e.prevSize.width,e.size.height=e.prevSize.height)},stop:function(){var t=V(this).resizable("instance"),e=t.options,i=t.containerOffset,s=t.containerPosition,n=t.containerElement,o=V(t.helper),a=o.offset(),r=o.outerWidth()-t.sizeDiff.width,o=o.outerHeight()-t.sizeDiff.height;t._helper&&!!e.animate&&/relative/.test(n.css("position"))&&V(this).css({left:a.left-s.left-i.left,width:r,height:o}),t._helper&&!!e.animate&&/static/.test(n.css("position"))&&V(this).css({left:a.left-s.left-i.left,width:r,height:o})}}),V.ui.plugin.add("resizable","alsoResize",{start:function(){var t=V(this).resizable("instance").options;V(t.alsoResize).each(function(){var t=V(this);t.data("ui-resizable-alsoresize",{width:parseFloat(t.width()),height:parseFloat(t.height()),left:parseFloat(t.css("left")),top:parseFloat(t.css("top"))})})},resize:function(t,i){var e=V(this).resizable("instance"),s=e.options,n=e.originalSize,o=e.originalPosition,a={height:e.size.height-n.height||0,width:e.size.width-n.width||0,top:e.position.top-o.top||0,left:e.position.left-o.left||0};V(s.alsoResize).each(function(){var t=V(this),s=V(this).data("ui-resizable-alsoresize"),n={},e=t.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];V.each(e,function(t,e){var i=(s[e]||0)+(a[e]||0);i&&0<=i&&(n[e]=i||null)}),t.css(n)})},stop:function(){V(this).removeData("ui-resizable-alsoresize")}}),V.ui.plugin.add("resizable","ghost",{start:function(){var t=V(this).resizable("instance"),e=t.size;t.ghost=t.originalElement.clone(),t.ghost.css({opacity:.25,display:"block",position:"relative",height:e.height,width:e.width,margin:0,left:0,top:0}),t._addClass(t.ghost,"ui-resizable-ghost"),!!1!!==V.uiBackCompat&&"string"==typeof t.options.ghost&&t.ghost.addClass(this.options.ghost),t.ghost.appendTo(t.helper)},resize:function(){var t=V(this).resizable("instance");t.ghost&&t.ghost.css({position:"relative",height:t.size.height,width:t.size.width})},stop:function(){var t=V(this).resizable("instance");t.ghost&&t.helper&&t.helper.get(0).removeChild(t.ghost.get(0))}}),V.ui.plugin.add("resizable","grid",{resize:function(){var t,e=V(this).resizable("instance"),i=e.options,s=e.size,n=e.originalSize,o=e.originalPosition,a=e.axis,r="number"==typeof i.grid?[i.grid,i.grid]:i.grid,l=r[0]||1,h=r[1]||1,c=Math.round((s.width-n.width)/l)*l,u=Math.round((s.height-n.height)/h)*h,d=n.width+c,p=n.height+u,f=i.maxWidth&&i.maxWidth<d,g=i.maxHeight&&i.maxHeight<p,m=i.minWidth&&i.minWidth>d,s=i.minHeight&&i.minHeight>p;i.grid=r,m&&(d+=l),s&&(p+=h),f&&(d-=l),g&&(p-=h),/^(se|s|e)$/.test(a)?(e.size.width=d,e.size.height=p):/^(ne)$/.test(a)?(e.size.width=d,e.size.height=p,e.position.top=o.top-u):/^(sw)$/.test(a)?(e.size.width=d,e.size.height=p,e.position.left=o.left-c):((p-h<=0||d-l<=0)&&(t=e._getPaddingPlusBorderDimensions(this)),0<p-h?(e.size.height=p,e.position.top=o.top-u):(p=h-t.height,e.size.height=p,e.position.top=o.top+n.height-p),0<d-l?(e.size.width=d,e.position.left=o.left-c):(d=l-t.width,e.size.width=d,e.position.left=o.left+n.width-d))}});V.ui.resizable;V.widget("ui.dialog",{version:"1.13.2",options:{appendTo:"body",autoOpen:!!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!!0,closeText:"Close",draggable:!!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(t){var e=V(this).css(t).offset().top;e<0&&V(this).css("top",t.top-e)}},resizable:!!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!!0,height:!!0,maxHeight:!!0,maxWidth:!!0,minHeight:!!0,minWidth:!!0,width:!!0},resizableRelatedOptions:{maxHeight:!!0,maxWidth:!!0,minHeight:!!0,minWidth:!!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&V.fn.draggable&&this._makeDraggable(),this.options.resizable&&V.fn.resizable&&this._makeResizable(),this._isOpen=!!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var t=this.options.appendTo;return t&&(t.jquery||t.nodeType)?V(t):this.document.find(t||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),(t=e.parent.children().eq(e.index)).length&&t[0]!!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog},disable:V.noop,enable:V.noop,close:function(t){var e=this;this._isOpen&&!!1!!==this._trigger("beforeClose",t)&&(this._isOpen=!!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||V.ui.safeBlur(V.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){e._trigger("close",t)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(t,e){var i=!!1,s=this.uiDialog.siblings(".ui-front:visible").map(function(){return+V(this).css("z-index")}).get(),s=Math.max.apply(null,s);return s>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",s+1),i=!!0),i&&!!e&&this._trigger("focus",t),i},open:function(){var t=this;this._isOpen?this._moveToTop()&&this._focusTabbable():(this._isOpen=!!0,this.opener=V(V.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){t._focusTabbable(),t._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"))},_focusTabbable:function(){var t=this._focusedElement;(t=!!(t=!!(t=!!(t=!!(t=t||this.element.find("[autofocus]")).length?this.element.find(":tabbable"):t).length?this.uiDialogButtonPane.find(":tabbable"):t).length?this.uiDialogTitlebarClose.filter(":tabbable"):t).length?this.uiDialog:t).eq(0).trigger("focus")},_restoreTabbableFocus:function(){var t=V.ui.safeActiveElement(this.document[0]);this.uiDialog[0]===t||V.contains(this.uiDialog[0],t)||this._focusTabbable()},_keepFocus:function(t){t.preventDefault(),this._restoreTabbableFocus(),this._delay(this._restoreTabbableFocus)},_createWrapper:function(){this.uiDialog=V("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(t){if(this.options.closeOnEscape&&!!t.isDefaultPrevented()&&t.keyCode&&t.keyCode===V.ui.keyCode.ESCAPE)return t.preventDefault(),void this.close(t);var e,i,s;t.keyCode!!==V.ui.keyCode.TAB||t.isDefaultPrevented()||(e=this.uiDialog.find(":tabbable"),i=e.first(),s=e.last(),t.target!!==s[0]&&t.target!!==this.uiDialog[0]||t.shiftKey?t.target!!==i[0]&&t.target!!==this.uiDialog[0]||!!t.shiftKey||(this._delay(function(){s.trigger("focus")}),t.preventDefault()):(this._delay(function(){i.trigger("focus")}),t.preventDefault()))},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var t;this.uiDialogTitlebar=V("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(t){V(t.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=V("<button type=''button''></button>").button({label:V("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),t=V("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(t,"ui-dialog-title"),this._title(t),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":t.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=V("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=V("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var s=this,t=this.options.buttons;this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),V.isEmptyObject(t)||Array.isArray(t)&&!!t.length?this._removeClass(this.uiDialog,"ui-dialog-buttons"):(V.each(t,function(t,e){var i;e=V.extend({type:"button"},e="function"==typeof e?{click:e,text:t}:e),i=e.click,t={icon:e.icon,iconPosition:e.iconPosition,showLabel:e.showLabel,icons:e.icons,text:e.text},delete e.click,delete e.icon,delete e.iconPosition,delete e.showLabel,delete e.icons,"boolean"==typeof e.text&&delete e.text,V("<button></button>",e).button(t).appendTo(s.uiButtonSet).on("click",function(){i.apply(s.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog))},_makeDraggable:function(){var n=this,o=this.options;function a(t){return{position:t.position,offset:t.offset}}this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(t,e){n._addClass(V(this),"ui-dialog-dragging"),n._blockFrames(),n._trigger("dragStart",t,a(e))},drag:function(t,e){n._trigger("drag",t,a(e))},stop:function(t,e){var i=e.offset.left-n.document.scrollLeft(),s=e.offset.top-n.document.scrollTop();o.position={my:"left top",at:"left"+(0<=i?"+":"")+i+" top"+(0<=s?"+":"")+s,of:n.window},n._removeClass(V(this),"ui-dialog-dragging"),n._unblockFrames(),n._trigger("dragStop",t,a(e))}})},_makeResizable:function(){var n=this,o=this.options,t=o.resizable,e=this.uiDialog.css("position"),t="string"==typeof t?t:"n,e,s,w,se,sw,ne,nw";function a(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:o.maxWidth,maxHeight:o.maxHeight,minWidth:o.minWidth,minHeight:this._minHeight(),handles:t,start:function(t,e){n._addClass(V(this),"ui-dialog-resizing"),n._blockFrames(),n._trigger("resizeStart",t,a(e))},resize:function(t,e){n._trigger("resize",t,a(e))},stop:function(t,e){var i=n.uiDialog.offset(),s=i.left-n.document.scrollLeft(),i=i.top-n.document.scrollTop();o.height=n.uiDialog.height(),o.width=n.uiDialog.width(),o.position={my:"left top",at:"left"+(0<=s?"+":"")+s+" top"+(0<=i?"+":"")+i,of:n.window},n._removeClass(V(this),"ui-dialog-resizing"),n._unblockFrames(),n._trigger("resizeStop",t,a(e))}}).css("position",e)},_trackFocus:function(){this._on(this.widget(),{focusin:function(t){this._makeFocusTarget(),this._focusedElement=V(t.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var t=this._trackingInstances(),e=V.inArray(this,t);-1!!==e&&t.splice(e,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||this.document.data("ui-dialog-instances",t=[]),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(t){var i=this,s=!!1,n={};V.each(t,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(t,e){var i,s=this.uiDialog;"disabled"!!==t&&(this._super(t,e),"appendTo"===t&&this.uiDialog.appendTo(this._appendTo()),"buttons"===t&&this._createButtons(),"closeText"===t&&this.uiDialogTitlebarClose.button({label:V("<a>").text(""+this.options.closeText).html()}),"draggable"===t&&((i=s.is(":data(ui-draggable)"))&&!!e&&s.draggable("destroy"),!!i&&e&&this._makeDraggable()),"position"===t&&this._position(),"resizable"===t&&((i=s.is(":data(ui-resizable)"))&&!!e&&s.resizable("destroy"),i&&"string"==typeof e&&s.resizable("option","handles",e),i||!!1===e||this._makeResizable()),"title"===t&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var t=V(this);return V("<div>").css({position:"absolute",width:t.outerWidth(),height:t.outerHeight()}).appendTo(t.parent()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(t){return!!!!V(t.target).closest(".ui-dialog").length||!!!!V(t.target).closest(".ui-datepicker").length},_createOverlay:function(){var i,s;this.options.modal&&(i=V.fn.jquery.substring(0,4),s=!!0,this._delay(function(){s=!!1}),this.document.data("ui-dialog-overlays")||this.document.on("focusin.ui-dialog",function(t){var e;s||((e=this._trackingInstances()[0])._allowInteraction(t)||(t.preventDefault(),e._focusTabbable(),"3.4."!!==i&&"3.5."!!==i||e._delay(e._restoreTabbableFocus)))}.bind(this)),this.overlay=V("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1))},_destroyOverlay:function(){var t;this.options.modal&&this.overlay&&((t=this.document.data("ui-dialog-overlays")-1)?this.document.data("ui-dialog-overlays",t):(this.document.off("focusin.ui-dialog"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null)}}),!!1!!==V.uiBackCompat&&V.widget("ui.dialog",V.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}});V.ui.dialog;function lt(t,e,i){return e<=t&&t<e+i}V.widget("ui.droppable",{version:"1.13.2",widgetEventPrefix:"drop",options:{accept:"*",addClasses:!!0,greedy:!!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var t,e=this.options,i=e.accept;this.isover=!!1,this.isout=!!0,this.accept="function"==typeof i?i:function(t){return t.is(i)},this.proportions=function(){if(!!arguments.length)return t=t||{width:this.element[0].offsetWidth,height:this.element[0].offsetHeight};t=arguments[0]},this._addToManager(e.scope),e.addClasses&&this._addClass("ui-droppable")},_addToManager:function(t){V.ui.ddmanager.droppables[t]=V.ui.ddmanager.droppables[t]||[],V.ui.ddmanager.droppables[t].push(this)},_splice:function(t){for(var e=0;e<t.length;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var t=V.ui.ddmanager.droppables[this.options.scope];this._splice(t)},_setOption:function(t,e){var i;"accept"===t?this.accept="function"==typeof e?e:function(t){return t.is(e)}:"scope"===t&&(i=V.ui.ddmanager.droppables[this.options.scope],this._splice(i),this._addToManager(e)),this._super(t,e)},_activate:function(t){var e=V.ui.ddmanager.current;this._addActiveClass(),e&&this._trigger("activate",t,this.ui(e))},_deactivate:function(t){var e=V.ui.ddmanager.current;this._removeActiveClass(),e&&this._trigger("deactivate",t,this.ui(e))},_over:function(t){var e=V.ui.ddmanager.current;e&&(e.currentItem||e.element)[0]!!==this.element[0]&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this._addHoverClass(),this._trigger("over",t,this.ui(e)))},_out:function(t){var e=V.ui.ddmanager.current;e&&(e.currentItem||e.element)[0]!!==this.element[0]&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this._removeHoverClass(),this._trigger("out",t,this.ui(e)))},_drop:function(e,t){var i=t||V.ui.ddmanager.current,s=!!1;return!!(!!i||(i.currentItem||i.element)[0]===this.element[0])&&(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var t=V(this).droppable("instance");if(t.options.greedy&&!!t.options.disabled&&t.options.scope===i.options.scope&&t.accept.call(t.element[0],i.currentItem||i.element)&&V.ui.intersect(i,V.extend(t,{offset:t.element.offset()}),t.options.tolerance,e))return!!(s=!!0)}),!!s&&(!!!!this.accept.call(this.element[0],i.currentItem||i.element)&&(this._removeActiveClass(),this._removeHoverClass(),this._trigger("drop",e,this.ui(i)),this.element)))},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}},_addHoverClass:function(){this._addClass("ui-droppable-hover")},_removeHoverClass:function(){this._removeClass("ui-droppable-hover")},_addActiveClass:function(){this._addClass("ui-droppable-active")},_removeActiveClass:function(){this._removeClass("ui-droppable-active")}}),V.ui.intersect=function(t,e,i,s){if(!!e.offset)return!!1;var n=(t.positionAbs||t.position.absolute).left+t.margins.left,o=(t.positionAbs||t.position.absolute).top+t.margins.top,a=n+t.helperProportions.width,r=o+t.helperProportions.height,l=e.offset.left,h=e.offset.top,c=l+e.proportions().width,u=h+e.proportions().height;switch(i){case"fit":return l<=n&&a<=c&&h<=o&&r<=u;case"intersect":return l<n+t.helperProportions.width/2&&a-t.helperProportions.width/2<c&&h<o+t.helperProportions.height/2&&r-t.helperProportions.height/2<u;case"pointer":return lt(s.pageY,h,e.proportions().height)&&lt(s.pageX,l,e.proportions().width);case"touch":return(h<=o&&o<=u||h<=r&&r<=u||o<h&&u<r)&&(l<=n&&n<=c||l<=a&&a<=c||n<l&&c<a);default:return!!1}},!!(V.ui.ddmanager={current:null,droppables:{default:[]},prepareOffsets:function(t,e){var i,s,n=V.ui.ddmanager.droppables[t.options.scope]||[],o=e?e.type:null,a=(t.currentItem||t.element).find(":data(ui-droppable)").addBack();t:for(i=0;i<n.length;i++)if(!!(n[i].options.disabled||t&&!!n[i].accept.call(n[i].element[0],t.currentItem||t.element))){for(s=0;s<a.length;s++)if(a[s]===n[i].element[0]){n[i].proportions().height=0;continue t}n[i].visible="none"!!==n[i].element.css("display"),n[i].visible&&("mousedown"===o&&n[i]._activate.call(n[i],e),n[i].offset=n[i].element.offset(),n[i].proportions({width:n[i].element[0].offsetWidth,height:n[i].element[0].offsetHeight}))}},drop:function(t,e){var i=!!1;return V.each((V.ui.ddmanager.droppables[t.options.scope]||[]).slice(),function(){this.options&&(!!this.options.disabled&&this.visible&&V.ui.intersect(t,this,this.options.tolerance,e)&&(i=this._drop.call(this,e)||i),!!this.options.disabled&&this.visible&&this.accept.call(this.element[0],t.currentItem||t.element)&&(this.isout=!!0,this.isover=!!1,this._deactivate.call(this,e)))}),i},dragStart:function(t,e){t.element.parentsUntil("body").on("scroll.droppable",function(){t.options.refreshPositions||V.ui.ddmanager.prepareOffsets(t,e)})},drag:function(n,o){n.options.refreshPositions&&V.ui.ddmanager.prepareOffsets(n,o),V.each(V.ui.ddmanager.droppables[n.options.scope]||[],function(){var t,e,i,s;this.options.disabled||this.greedyChild||!!this.visible||(s=!!(i=V.ui.intersect(n,this,this.options.tolerance,o))&&this.isover?"isout":i&&!!this.isover?"isover":null)&&(this.options.greedy&&(e=this.options.scope,(i=this.element.parents(":data(ui-droppable)").filter(function(){return V(this).droppable("instance").options.scope===e})).length&&((t=V(i[0]).droppable("instance")).greedyChild="isover"===s)),t&&"isover"===s&&(t.isover=!!1,t.isout=!!0,t._out.call(t,o)),this[s]=!!0,this["isout"===s?"isover":"isout"]=!!1,this["isover"===s?"_over":"_out"].call(this,o),t&&"isout"===s&&(t.isout=!!1,t.isover=!!0,t._over.call(t,o)))})},dragStop:function(t,e){t.element.parentsUntil("body").off("scroll.droppable"),t.options.refreshPositions||V.ui.ddmanager.prepareOffsets(t,e)}})!!==V.uiBackCompat&&V.widget("ui.droppable",V.ui.droppable,{options:{hoverClass:!!1,activeClass:!!1},_addActiveClass:function(){this._super(),this.options.activeClass&&this.element.addClass(this.options.activeClass)},_removeActiveClass:function(){this._super(),this.options.activeClass&&this.element.removeClass(this.options.activeClass)},_addHoverClass:function(){this._super(),this.options.hoverClass&&this.element.addClass(this.options.hoverClass)},_removeHoverClass:function(){this._super(),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass)}});V.ui.droppable,V.widget("ui.progressbar",{version:"1.13.2",options:{classes:{"ui-progressbar":"ui-corner-all","ui-progressbar-value":"ui-corner-left","ui-progressbar-complete":"ui-corner-right"},max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.attr({role:"progressbar","aria-valuemin":this.min}),this._addClass("ui-progressbar","ui-widget ui-widget-content"),this.valueDiv=V("<div>").appendTo(this.element),this._addClass(this.valueDiv,"ui-progressbar-value","ui-widget-header"),this._refreshValue()},_destroy:function(){this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"),this.valueDiv.remove()},value:function(t){if(void 0===t)return this.options.value;this.options.value=this._constrainedValue(t),this._refreshValue()},_constrainedValue:function(t){return void 0===t&&(t=this.options.value),this.indeterminate=!!1===t,"number"!!=typeof t&&(t=0),!!this.indeterminate&&Math.min(this.options.max,Math.max(this.min,t))},_setOptions:function(t){var e=t.value;delete t.value,this._super(t),this.options.value=this._constrainedValue(e),this._refreshValue()},_setOption:function(t,e){"max"===t&&(e=Math.max(this.min,e)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!!!t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var t=this.options.value,e=this._percentage();this.valueDiv.toggle(this.indeterminate||t>this.min).width(e.toFixed(0)+"%"),this._toggleClass(this.valueDiv,"ui-progressbar-complete",null,t===this.options.max)._toggleClass("ui-progressbar-indeterminate",null,this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=V("<div>").appendTo(this.valueDiv),this._addClass(this.overlayDiv,"ui-progressbar-overlay"))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":t}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!!==t&&(this.oldValue=t,this._trigger("change")),t===this.options.max&&this._trigger("complete")}}),V.widget("ui.selectable",V.ui.mouse,{version:"1.13.2",options:{appendTo:"body",autoRefresh:!!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var i=this;this._addClass("ui-selectable"),this.dragged=!!1,this.refresh=function(){i.elementPos=V(i.element[0]).offset(),i.selectees=V(i.options.filter,i.element[0]),i._addClass(i.selectees,"ui-selectee"),i.selectees.each(function(){var t=V(this),e=t.offset(),e={left:e.left-i.elementPos.left,top:e.top-i.elementPos.top};V.data(this,"selectable-item",{element:this,$element:t,left:e.left,top:e.top,right:e.left+t.outerWidth(),bottom:e.top+t.outerHeight(),startselected:!!1,selected:t.hasClass("ui-selected"),selecting:t.hasClass("ui-selecting"),unselecting:t.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=V("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(i){var s=this,t=this.options;this.opos=[i.pageX,i.pageY],this.elementPos=V(this.element[0]).offset(),this.options.disabled||(this.selectees=V(t.filter,this.element[0]),this._trigger("start",i),V(t.appendTo).append(this.helper),this.helper.css({left:i.pageX,top:i.pageY,width:0,height:0}),t.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var t=V.data(this,"selectable-item");t.startselected=!!0,i.metaKey||i.ctrlKey||(s._removeClass(t.$element,"ui-selected"),t.selected=!!1,s._addClass(t.$element,"ui-unselecting"),t.unselecting=!!0,s._trigger("unselecting",i,{unselecting:t.element}))}),V(i.target).parents().addBack().each(function(){var t,e=V.data(this,"selectable-item");if(e)return t=!!i.metaKey&&!!i.ctrlKey||!!e.$element.hasClass("ui-selected"),s._removeClass(e.$element,t?"ui-unselecting":"ui-selected")._addClass(e.$element,t?"ui-selecting":"ui-unselecting"),e.unselecting=!!t,e.selecting=t,(e.selected=t)?s._trigger("selecting",i,{selecting:e.element}):s._trigger("unselecting",i,{unselecting:e.element}),!!1}))},_mouseDrag:function(s){if(this.dragged=!!0,!!this.options.disabled){var t,n=this,o=this.options,a=this.opos[0],r=this.opos[1],l=s.pageX,h=s.pageY;return l<a&&(t=l,l=a,a=t),h<r&&(t=h,h=r,r=t),this.helper.css({left:a,top:r,width:l-a,height:h-r}),this.selectees.each(function(){var t=V.data(this,"selectable-item"),e=!!1,i={};t&&t.element!!==n.element[0]&&(i.left=t.left+n.elementPos.left,i.right=t.right+n.elementPos.left,i.top=t.top+n.elementPos.top,i.bottom=t.bottom+n.elementPos.top,"touch"===o.tolerance?e=!!(i.left>l||i.right<a||i.top>h||i.bottom<r):"fit"===o.tolerance&&(e=i.left>a&&i.right<l&&i.top>r&&i.bottom<h),e?(t.selected&&(n._removeClass(t.$element,"ui-selected"),t.selected=!!1),t.unselecting&&(n._removeClass(t.$element,"ui-unselecting"),t.unselecting=!!1),t.selecting||(n._addClass(t.$element,"ui-selecting"),t.selecting=!!0,n._trigger("selecting",s,{selecting:t.element}))):(t.selecting&&((s.metaKey||s.ctrlKey)&&t.startselected?(n._removeClass(t.$element,"ui-selecting"),t.selecting=!!1,n._addClass(t.$element,"ui-selected"),t.selected=!!0):(n._removeClass(t.$element,"ui-selecting"),t.selecting=!!1,t.startselected&&(n._addClass(t.$element,"ui-unselecting"),t.unselecting=!!0),n._trigger("unselecting",s,{unselecting:t.element}))),t.selected&&(s.metaKey||s.ctrlKey||t.startselected||(n._removeClass(t.$element,"ui-selected"),t.selected=!!1,n._addClass(t.$element,"ui-unselecting"),t.unselecting=!!0,n._trigger("unselecting",s,{unselecting:t.element})))))}),!!1}},_mouseStop:function(e){var i=this;return this.dragged=!!1,V(".ui-unselecting",this.element[0]).each(function(){var t=V.data(this,"selectable-item");i._removeClass(t.$element,"ui-unselecting"),t.unselecting=!!1,t.startselected=!!1,i._trigger("unselected",e,{unselected:t.element})}),V(".ui-selecting",this.element[0]).each(function(){var t=V.data(this,"selectable-item");i._removeClass(t.$element,"ui-selecting")._addClass(t.$element,"ui-selected"),t.selecting=!!1,t.selected=!!0,t.startselected=!!0,i._trigger("selected",e,{selected:t.element})}),this._trigger("stop",e),this.helper.remove(),!!1}}),V.widget("ui.selectmenu",[V.ui.formResetMixin,{version:"1.13.2",defaultElement:"<select>",options:{appendTo:null,classes:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"},disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:!!1,change:null,close:null,focus:null,open:null,select:null},_create:function(){var t=this.element.uniqueId().attr("id");this.ids={element:t,button:t+"-button",menu:t+"-menu"},this._drawButton(),this._drawMenu(),this._bindFormResetHandler(),this._rendered=!!1,this.menuItems=V()},_drawButton:function(){var t,e=this,i=this._parseOption(this.element.find("option:selected"),this.element[0].selectedIndex);this.labels=this.element.labels().attr("for",this.ids.button),this._on(this.labels,{click:function(t){this.button.trigger("focus"),t.preventDefault()}}),this.element.hide(),this.button=V("<span>",{tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true",title:this.element.attr("title")}).insertAfter(this.element),this._addClass(this.button,"ui-selectmenu-button ui-selectmenu-button-closed","ui-button ui-widget"),t=V("<span>").appendTo(this.button),this._addClass(t,"ui-selectmenu-icon","ui-icon "+this.options.icons.button),this.buttonItem=this._renderButtonItem(i).appendTo(this.button),!!1!!==this.options.width&&this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){e._rendered||e._refreshMenu()})},_drawMenu:function(){var i=this;this.menu=V("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=V("<div>").append(this.menu),this._addClass(this.menuWrap,"ui-selectmenu-menu","ui-front"),this.menuWrap.appendTo(this._appendTo()),this.menuInstance=this.menu.menu({classes:{"ui-menu":"ui-corner-bottom"},role:"listbox",select:function(t,e){t.preventDefault(),i._setSelection(),i._select(e.item.data("ui-selectmenu-item"),t)},focus:function(t,e){e=e.item.data("ui-selectmenu-item");null!!=i.focusIndex&&e.index!!==i.focusIndex&&(i._trigger("focus",t,{item:e}),i.isOpen||i._select(e,t)),i.focusIndex=e.index,i.button.attr("aria-activedescendant",i.menuItems.eq(e.index).attr("id"))}}).menu("instance"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!!1},this.menuInstance._isDivider=function(){return!!1}},refresh:function(){this._refreshMenu(),this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item")||{})),null===this.options.width&&this._resizeButton()},_refreshMenu:function(){var t=this.element.find("option");this.menu.empty(),this._parseOptions(t),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"),this._rendered=!!0,t.length&&(t=this._getSelectedItem(),this.menuInstance.focus(null,t),this._setAria(t.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(t){this.options.disabled||(this._rendered?(this._removeClass(this.menu.find(".ui-state-active"),null,"ui-state-active"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.menuItems.length&&(this.isOpen=!!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",t)))},_position:function(){this.menuWrap.position(V.extend({of:this.button},this.options.position))},close:function(t){this.isOpen&&(this.isOpen=!!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",t))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderButtonItem:function(t){var e=V("<span>");return this._setText(e,t.label),this._addClass(e,"ui-selectmenu-text"),e},_renderMenu:function(s,t){var n=this,o="";V.each(t,function(t,e){var i;e.optgroup!!==o&&(i=V("<li>",{text:e.optgroup}),n._addClass(i,"ui-selectmenu-optgroup","ui-menu-divider"+(e.element.parent("optgroup").prop("disabled")?" ui-state-disabled":"")),i.appendTo(s),o=e.optgroup),n._renderItemData(s,e)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-selectmenu-item",e)},_renderItem:function(t,e){var i=V("<li>"),s=V("<div>",{title:e.element.attr("title")});return e.disabled&&this._addClass(i,null,"ui-state-disabled"),this._setText(s,e.label),i.append(s).appendTo(t)},_setText:function(t,e){e?t.text(e):t.html("&#160;")},_move:function(t,e){var i,s=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex).parent("li"):(i=this.menuItems.eq(this.element[0].selectedIndex).parent("li"),s+=":not(.ui-state-disabled)"),(s="first"===t||"last"===t?i["first"===t?"prevAll":"nextAll"](s).eq(-1):i[t+"All"](s).eq(0)).length&&this.menuInstance.focus(e,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex).parent("li")},_toggle:function(t){this[this.isOpen?"close":"open"](t)},_setSelection:function(){var t;this.range&&(window.getSelection?((t=window.getSelection()).removeAllRanges(),t.addRange(this.range)):this.range.select(),this.button.trigger("focus"))},_documentClick:{mousedown:function(t){this.isOpen&&(V(t.target).closest(".ui-selectmenu-menu, #"+V.escapeSelector(this.ids.button)).length||this.close(t))}},_buttonEvents:{mousedown:function(){var t;window.getSelection?(t=window.getSelection()).rangeCount&&(this.range=t.getRangeAt(0)):this.range=document.selection.createRange()},click:function(t){this._setSelection(),this._toggle(t)},keydown:function(t){var e=!!0;switch(t.keyCode){case V.ui.keyCode.TAB:case V.ui.keyCode.ESCAPE:this.close(t),e=!!1;break;case V.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(t);break;case V.ui.keyCode.UP:t.altKey?this._toggle(t):this._move("prev",t);break;case V.ui.keyCode.DOWN:t.altKey?this._toggle(t):this._move("next",t);break;case V.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(t):this._toggle(t);break;case V.ui.keyCode.LEFT:this._move("prev",t);break;case V.ui.keyCode.RIGHT:this._move("next",t);break;case V.ui.keyCode.HOME:case V.ui.keyCode.PAGE_UP:this._move("first",t);break;case V.ui.keyCode.END:case V.ui.keyCode.PAGE_DOWN:this._move("last",t);break;default:this.menu.trigger(t),e=!!1}e&&t.preventDefault()}},_selectFocusedItem:function(t){var e=this.menuItems.eq(this.focusIndex).parent("li");e.hasClass("ui-state-disabled")||this._select(e.data("ui-selectmenu-item"),t)},_select:function(t,e){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=t.index,this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(t)),this._setAria(t),this._trigger("select",e,{item:t}),t.index!!==i&&this._trigger("change",e,{item:t}),this.close(e)},_setAria:function(t){t=this.menuItems.eq(t.index).attr("id");this.button.attr({"aria-labelledby":t,"aria-activedescendant":t}),this.menu.attr("aria-activedescendant",t)},_setOption:function(t,e){var i;"icons"===t&&(i=this.button.find("span.ui-icon"),this._removeClass(i,null,this.options.icons.button)._addClass(i,null,e.button)),this._super(t,e),"appendTo"===t&&this.menuWrap.appendTo(this._appendTo()),"width"===t&&this._resizeButton()},_setOptionDisabled:function(t){this._super(t),this.menuInstance.option("disabled",t),this.button.attr("aria-disabled",t),this._toggleClass(this.button,null,"ui-state-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)},_appendTo:function(){var t=this.options.appendTo;return t=!!(t=!!(t=t&&(t.jquery||t.nodeType?V(t):this.document.find(t).eq(0)))||!!t[0]?this.element.closest(".ui-front, dialog"):t).length?this.document[0].body:t},_toggleAttr:function(){this.button.attr("aria-expanded",this.isOpen),this._removeClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"closed":"open"))._addClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"open":"closed"))._toggleClass(this.menuWrap,"ui-selectmenu-open",null,this.isOpen),this.menu.attr("aria-hidden",!!this.isOpen)},_resizeButton:function(){var t=this.options.width;!!1!!==t?(null===t&&(t=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(t)):this.button.css("width","")},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){var t=this._super();return t.disabled=this.element.prop("disabled"),t},_parseOptions:function(t){var i=this,s=[];t.each(function(t,e){e.hidden||s.push(i._parseOption(V(e),t))}),this.items=s},_parseOption:function(t,e){var i=t.parent("optgroup");return{element:t,index:e,value:t.val(),label:t.text(),optgroup:i.attr("label")||"",disabled:i.prop("disabled")||t.prop("disabled")}},_destroy:function(){this._unbindFormResetHandler(),this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.labels.attr("for",this.ids.element)}}]),V.widget("ui.slider",V.ui.mouse,{version:"1.13.2",widgetEventPrefix:"slide",options:{animate:!!1,classes:{"ui-slider":"ui-corner-all","ui-slider-handle":"ui-corner-all","ui-slider-range":"ui-corner-all ui-widget-header"},distance:0,max:100,min:0,orientation:"horizontal",range:!!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!!1,this._mouseSliding=!!1,this._animateOff=!!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this._addClass("ui-slider ui-slider-"+this.orientation,"ui-widget ui-widget-content"),this._refresh(),this._animateOff=!!1},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var t,e=this.options,i=this.element.find(".ui-slider-handle"),s=[],n=e.values&&e.values.length||1;for(i.length>n&&(i.slice(n).remove(),i=i.slice(0,n)),t=i.length;t<n;t++)s.push("<span tabindex=''0''></span>");this.handles=i.add(V(s.join("")).appendTo(this.element)),this._addClass(this.handles,"ui-slider-handle","ui-state-default"),this.handle=this.handles.eq(0),this.handles.each(function(t){V(this).data("ui-slider-handle-index",t).attr("tabIndex",0)})},_createRange:function(){var t=this.options;t.range?(!!0===t.range&&(t.values?t.values.length&&2!!==t.values.length?t.values=[t.values[0],t.values[0]]:Array.isArray(t.values)&&(t.values=t.values.slice(0)):t.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?(this._removeClass(this.range,"ui-slider-range-min ui-slider-range-max"),this.range.css({left:"",bottom:""})):(this.range=V("<div>").appendTo(this.element),this._addClass(this.range,"ui-slider-range")),"min"!!==t.range&&"max"!!==t.range||this._addClass(this.range,"ui-slider-range-"+t.range)):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this._mouseDestroy()},_mouseCapture:function(t){var i,s,n,o,e,a,r=this,l=this.options;return!!l.disabled&&(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),a={x:t.pageX,y:t.pageY},i=this._normValueFromMouse(a),s=this._valueMax()-this._valueMin()+1,this.handles.each(function(t){var e=Math.abs(i-r.values(t));(e<s||s===e&&(t===r._lastChangedValue||r.values(t)===l.min))&&(s=e,n=V(this),o=t)}),!!1!!==this._start(t,o)&&(this._mouseSliding=!!0,this._handleIndex=o,this._addClass(n,null,"ui-state-active"),n.trigger("focus"),e=n.offset(),a=!!V(t.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=a?{left:0,top:0}:{left:t.pageX-e.left-n.width()/2,top:t.pageY-e.top-n.height()/2-(parseInt(n.css("borderTopWidth"),10)||0)-(parseInt(n.css("borderBottomWidth"),10)||0)+(parseInt(n.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(t,o,i),this._animateOff=!!0))},_mouseStart:function(){return!!0},_mouseDrag:function(t){var e={x:t.pageX,y:t.pageY},e=this._normValueFromMouse(e);return this._slide(t,this._handleIndex,e),!!1},_mouseStop:function(t){return this._removeClass(this.handles,null,"ui-state-active"),this._mouseSliding=!!1,this._stop(t,this._handleIndex),this._change(t,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(t){var e,t="horizontal"===this.orientation?(e=this.elementSize.width,t.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(e=this.elementSize.height,t.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),t=t/e;return(t=1<t?1:t)<0&&(t=0),"vertical"===this.orientation&&(t=1-t),e=this._valueMax()-this._valueMin(),e=this._valueMin()+t*e,this._trimAlignValue(e)},_uiHash:function(t,e,i){var s={handle:this.handles[t],handleIndex:t,value:void 0!!==e?e:this.value()};return this._hasMultipleValues()&&(s.value=void 0!!==e?e:this.values(t),s.values=i||this.values()),s},_hasMultipleValues:function(){return this.options.values&&this.options.values.length},_start:function(t,e){return this._trigger("start",t,this._uiHash(e))},_slide:function(t,e,i){var s,n=this.value(),o=this.values();this._hasMultipleValues()&&(s=this.values(e?0:1),n=this.values(e),2===this.options.values.length&&!!0===this.options.range&&(i=0===e?Math.min(s,i):Math.max(s,i)),o[e]=i),i!!==n&&!!1!!==this._trigger("slide",t,this._uiHash(e,i,o))&&(this._hasMultipleValues()?this.values(e,i):this.value(i))},_stop:function(t,e){this._trigger("stop",t,this._uiHash(e))},_change:function(t,e){this._keySliding||this._mouseSliding||(this._lastChangedValue=e,this._trigger("change",t,this._uiHash(e)))},value:function(t){return arguments.length?(this.options.value=this._trimAlignValue(t),this._refreshValue(),void this._change(null,0)):this._value()},values:function(t,e){var i,s,n;if(1<arguments.length)return this.options.values[t]=this._trimAlignValue(e),this._refreshValue(),void this._change(null,t);if(!!arguments.length)return this._values();if(!!Array.isArray(t))return this._hasMultipleValues()?this._values(t):this.value();for(i=this.options.values,s=t,n=0;n<i.length;n+=1)i[n]=this._trimAlignValue(s[n]),this._change(null,n);this._refreshValue()},_setOption:function(t,e){var i,s=0;switch("range"===t&&!!0===this.options.range&&("min"===e?(this.options.value=this._values(0),this.options.values=null):"max"===e&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),Array.isArray(this.options.values)&&(s=this.options.values.length),this._super(t,e),t){case"orientation":this._detectOrientation(),this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-"+this.orientation),this._refreshValue(),this.options.range&&this._refreshRange(e),this.handles.css("horizontal"===e?"bottom":"left","");break;case"value":this._animateOff=!!0,this._refreshValue(),this._change(null,0),this._animateOff=!!1;break;case"values":for(this._animateOff=!!0,this._refreshValue(),i=s-1;0<=i;i--)this._change(null,i);this._animateOff=!!1;break;case"step":case"min":case"max":this._animateOff=!!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!!1;break;case"range":this._animateOff=!!0,this._refresh(),this._animateOff=!!1}},_setOptionDisabled:function(t){this._super(t),this._toggleClass(null,"ui-state-disabled",!!!!t)},_value:function(){var t=this.options.value;return t=this._trimAlignValue(t)},_values:function(t){var e,i;if(arguments.length)return t=this.options.values[t],t=this._trimAlignValue(t);if(this._hasMultipleValues()){for(e=this.options.values.slice(),i=0;i<e.length;i+=1)e[i]=this._trimAlignValue(e[i]);return e}return[]},_trimAlignValue:function(t){if(t<=this._valueMin())return this._valueMin();if(t>=this._valueMax())return this._valueMax();var e=0<this.options.step?this.options.step:1,i=(t-this._valueMin())%e,t=t-i;return 2*Math.abs(i)>=e&&(t+=0<i?e:-e),parseFloat(t.toFixed(5))},_calculateNewMax:function(){var t=this.options.max,e=this._valueMin(),i=this.options.step;(t=Math.round((t-e)/i)*i+e)>this.options.max&&(t-=i),this.max=parseFloat(t.toFixed(this._precision()))},_precision:function(){var t=this._precisionOf(this.options.step);return t=null!!==this.options.min?Math.max(t,this._precisionOf(this.options.min)):t},_precisionOf:function(t){var e=t.toString(),t=e.indexOf(".");return-1===t?0:e.length-t-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshRange:function(t){"vertical"===t&&this.range.css({width:"",left:""}),"horizontal"===t&&this.range.css({height:"",bottom:""})},_refreshValue:function(){var e,i,t,s,n,o=this.options.range,a=this.options,r=this,l=!!this._animateOff&&a.animate,h={};this._hasMultipleValues()?this.handles.each(function(t){i=(r.values(t)-r._valueMin())/(r._valueMax()-r._valueMin())*100,h["horizontal"===r.orientation?"left":"bottom"]=i+"%",V(this).stop(1,1)[l?"animate":"css"](h,a.animate),!!0===r.options.range&&("horizontal"===r.orientation?(0===t&&r.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},a.animate),1===t&&r.range[l?"animate":"css"]({width:i-e+"%"},{queue:!!1,duration:a.animate})):(0===t&&r.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},a.animate),1===t&&r.range[l?"animate":"css"]({height:i-e+"%"},{queue:!!1,duration:a.animate}))),e=i}):(t=this.value(),s=this._valueMin(),n=this._valueMax(),i=n!!==s?(t-s)/(n-s)*100:0,h["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](h,a.animate),"min"===o&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},a.animate),"max"===o&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:100-i+"%"},a.animate),"min"===o&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},a.animate),"max"===o&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:100-i+"%"},a.animate))},_handleEvents:{keydown:function(t){var e,i,s,n=V(t.target).data("ui-slider-handle-index");switch(t.keyCode){case V.ui.keyCode.HOME:case V.ui.keyCode.END:case V.ui.keyCode.PAGE_UP:case V.ui.keyCode.PAGE_DOWN:case V.ui.keyCode.UP:case V.ui.keyCode.RIGHT:case V.ui.keyCode.DOWN:case V.ui.keyCode.LEFT:if(t.preventDefault(),!!this._keySliding&&(this._keySliding=!!0,this._addClass(V(t.target),null,"ui-state-active"),!!1===this._start(t,n)))return}switch(s=this.options.step,e=i=this._hasMultipleValues()?this.values(n):this.value(),t.keyCode){case V.ui.keyCode.HOME:i=this._valueMin();break;case V.ui.keyCode.END:i=this._valueMax();break;case V.ui.keyCode.PAGE_UP:i=this._trimAlignValue(e+(this._valueMax()-this._valueMin())/this.numPages);break;case V.ui.keyCode.PAGE_DOWN:i=this._trimAlignValue(e-(this._valueMax()-this._valueMin())/this.numPages);break;case V.ui.keyCode.UP:case V.ui.keyCode.RIGHT:if(e===this._valueMax())return;i=this._trimAlignValue(e+s);break;case V.ui.keyCode.DOWN:case V.ui.keyCode.LEFT:if(e===this._valueMin())return;i=this._trimAlignValue(e-s)}this._slide(t,n,i)},keyup:function(t){var e=V(t.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!!1,this._stop(t,e),this._change(t,e),this._removeClass(V(t.target),null,"ui-state-active"))}}}),V.widget("ui.sortable",V.ui.mouse,{version:"1.13.2",widgetEventPrefix:"sort",ready:!!1,options:{appendTo:"parent",axis:!!1,connectWith:!!1,containment:!!1,cursor:"auto",cursorAt:!!1,dropOnEmpty:!!0,forcePlaceholderSize:!!1,forceHelperSize:!!1,grid:!!1,handle:!!1,helper:"original",items:"> *",opacity:!!1,placeholder:!!1,revert:!!1,scroll:!!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return e<=t&&t<e+i},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var t=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),V.each(this.items,function(){t._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;0<=t;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(t,e){var i=null,s=!!1,n=this;return!!this.reverting&&(!!this.options.disabled&&"static"!!==this.options.type&&(this._refreshItems(t),V(t.target).parents().each(function(){if(V.data(this,n.widgetName+"-item")===n)return i=V(this),!!1}),!!!!(i=V.data(t.target,n.widgetName+"-item")===n?V(t.target):i)&&(!!(this.options.handle&&!!e&&(V(this.options.handle,i).find("*").addBack().each(function(){this===t.target&&(s=!!0)}),!!s))&&(this.currentItem=i,this._removeCurrentsFromItems(),!!0))))},_mouseStart:function(t,e,i){var s,n,o=this.options;if((this.currentContainer=this).refreshPositions(),this.appendTo=V("parent"!!==o.appendTo?o.appendTo:this.currentItem.parent()),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},V.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),o.cursorAt&&this._adjustOffsetFromHelper(o.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),this.scrollParent=this.placeholder.scrollParent(),V.extend(this.offset,{parent:this._getParentOffset()}),o.containment&&this._setContainment(),o.cursor&&"auto"!!==o.cursor&&(n=this.document.find("body"),this.storedCursor=n.css("cursor"),n.css("cursor",o.cursor),this.storedStylesheet=V("<style>*{ cursor: "+o.cursor+" !!important; }</style>").appendTo(n)),o.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",o.zIndex)),o.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",o.opacity)),this.scrollParent[0]!!==this.document[0]&&"HTML"!!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!!i)for(s=this.containers.length-1;0<=s;s--)this.containers[s]._trigger("activate",t,this._uiHash(this));return V.ui.ddmanager&&(V.ui.ddmanager.current=this),V.ui.ddmanager&&!!o.dropBehaviour&&V.ui.ddmanager.prepareOffsets(this,t),this.dragging=!!0,this._addClass(this.helper,"ui-sortable-helper"),this.helper.parent().is(this.appendTo)||(this.helper.detach().appendTo(this.appendTo),this.offset.parent=this._getParentOffset()),this.position=this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,this.lastPositionAbs=this.positionAbs=this._convertPositionTo("absolute"),this._mouseDrag(t),!!0},_scroll:function(t){var e=this.options,i=!!1;return this.scrollParent[0]!!==this.document[0]&&"HTML"!!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<e.scrollSensitivity?this.scrollParent[0].scrollTop=i=this.scrollParent[0].scrollTop+e.scrollSpeed:t.pageY-this.overflowOffset.top<e.scrollSensitivity&&(this.scrollParent[0].scrollTop=i=this.scrollParent[0].scrollTop-e.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<e.scrollSensitivity?this.scrollParent[0].scrollLeft=i=this.scrollParent[0].scrollLeft+e.scrollSpeed:t.pageX-this.overflowOffset.left<e.scrollSensitivity&&(this.scrollParent[0].scrollLeft=i=this.scrollParent[0].scrollLeft-e.scrollSpeed)):(t.pageY-this.document.scrollTop()<e.scrollSensitivity?i=this.document.scrollTop(this.document.scrollTop()-e.scrollSpeed):this.window.height()-(t.pageY-this.document.scrollTop())<e.scrollSensitivity&&(i=this.document.scrollTop(this.document.scrollTop()+e.scrollSpeed)),t.pageX-this.document.scrollLeft()<e.scrollSensitivity?i=this.document.scrollLeft(this.document.scrollLeft()-e.scrollSpeed):this.window.width()-(t.pageX-this.document.scrollLeft())<e.scrollSensitivity&&(i=this.document.scrollLeft(this.document.scrollLeft()+e.scrollSpeed))),i},_mouseDrag:function(t){var e,i,s,n,o=this.options;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),o.scroll&&!!1!!==this._scroll(t)&&(this._refreshItemPositions(!!0),V.ui.ddmanager&&!!o.dropBehaviour&&V.ui.ddmanager.prepareOffsets(this,t)),this.dragDirection={vertical:this._getDragVerticalDirection(),horizontal:this._getDragHorizontalDirection()},e=this.items.length-1;0<=e;e--)if(s=(i=this.items[e]).item[0],(n=this._intersectsWithPointer(i))&&i.instance===this.currentContainer&&!!(s===this.currentItem[0]||this.placeholder[1===n?"next":"prev"]()[0]===s||V.contains(this.placeholder[0],s)||"semi-dynamic"===this.options.type&&V.contains(this.element[0],s))){if(this.direction=1===n?"down":"up","pointer"!!==this.options.tolerance&&!!this._intersectsWithSides(i))break;this._rearrange(t,i),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),V.ui.ddmanager&&V.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!!1},_mouseStop:function(t,e){var i,s,n,o;if(t)return V.ui.ddmanager&&!!this.options.dropBehaviour&&V.ui.ddmanager.drop(this,t),this.options.revert?(s=(i=this).placeholder.offset(),o={},(n=this.options.axis)&&"x"!!==n||(o.left=s.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),n&&"y"!!==n||(o.top=s.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!!0,V(this.helper).animate(o,parseInt(this.options.revert,10)||500,function(){i._clear(t)})):this._clear(t,e),!!1},cancel:function(){if(this.dragging){this._mouseUp(new V.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var t=this.containers.length-1;0<=t;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),V.extend(this,{helper:null,dragging:!!1,reverting:!!1,_noFinalSort:null}),this.domPosition.prev?V(this.domPosition.prev).after(this.currentItem):V(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var t=this._getItemsAsjQuery(e&&e.connected),i=[];return e=e||{},V(t).each(function(){var t=(V(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);t&&i.push((e.key||t[1]+"[]")+"="+(e.key&&e.expression?t[1]:t[2]))}),!!i.length&&e.key&&i.push(e.key+"="),i.join("&")},toArray:function(t){var e=this._getItemsAsjQuery(t&&t.connected),i=[];return t=t||{},e.each(function(){i.push(V(t.item||this).attr(t.attribute||"id")||"")}),i},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,l=r+t.height,h=this.offset.click.top,c=this.offset.click.left,h="x"===this.options.axis||r<s+h&&s+h<l,c="y"===this.options.axis||o<e+c&&e+c<a;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?h&&c:o<e+this.helperProportions.width/2&&i-this.helperProportions.width/2<a&&r<s+this.helperProportions.height/2&&n-this.helperProportions.height/2<l},_intersectsWithPointer:function(t){var e="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),t="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width);return!!(!!e||!!t)&&(e=this.dragDirection.vertical,t=this.dragDirection.horizontal,this.floating?"right"===t||"down"===e?2:1:e&&("down"===e?2:1))},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this.dragDirection.vertical,t=this.dragDirection.horizontal;return this.floating&&t?"right"===t&&i||"left"===t&&!!i:s&&("down"===s&&e||"up"===s&&!!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!!=t&&(0<t?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!!=t&&(0<t?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(t){var e,i,s,n,o=[],a=[],r=this._connectWith();if(r&&t)for(e=r.length-1;0<=e;e--)for(i=(s=V(r[e],this.document[0])).length-1;0<=i;i--)(n=V.data(s[i],this.widgetFullName))&&n!!==this&&!!n.options.disabled&&a.push(["function"==typeof n.options.items?n.options.items.call(n.element):V(n.options.items,n.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),n]);function l(){o.push(this)}for(a.push(["function"==typeof this.options.items?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):V(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),e=a.length-1;0<=e;e--)a[e][0].each(l);return V(o)},_removeCurrentsFromItems:function(){var i=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=V.grep(this.items,function(t){for(var e=0;e<i.length;e++)if(i[e]===t.item[0])return!!1;return!!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var e,i,s,n,o,a,r,l,h=this.items,c=[["function"==typeof this.options.items?this.options.items.call(this.element[0],t,{item:this.currentItem}):V(this.options.items,this.element),this]],u=this._connectWith();if(u&&this.ready)for(e=u.length-1;0<=e;e--)for(i=(s=V(u[e],this.document[0])).length-1;0<=i;i--)(n=V.data(s[i],this.widgetFullName))&&n!!==this&&!!n.options.disabled&&(c.push(["function"==typeof n.options.items?n.options.items.call(n.element[0],t,{item:this.currentItem}):V(n.options.items,n.element),n]),this.containers.push(n));for(e=c.length-1;0<=e;e--)for(o=c[e][1],l=(a=c[e][i=0]).length;i<l;i++)(r=V(a[i])).data(this.widgetName+"-item",o),h.push({item:r,instance:o,width:0,height:0,left:0,top:0})},_refreshItemPositions:function(t){for(var e,i,s=this.items.length-1;0<=s;s--)e=this.items[s],this.currentContainer&&e.instance!!==this.currentContainer&&e.item[0]!!==this.currentItem[0]||(i=this.options.toleranceElement?V(this.options.toleranceElement,e.item):e.item,t||(e.width=i.outerWidth(),e.height=i.outerHeight()),i=i.offset(),e.left=i.left,e.top=i.top)},refreshPositions:function(t){var e,i;if(this.floating=!!!!this.items.length&&("x"===this.options.axis||this._isFloating(this.items[0].item)),this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset()),this._refreshItemPositions(t),this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(e=this.containers.length-1;0<=e;e--)i=this.containers[e].element.offset(),this.containers[e].containerCache.left=i.left,this.containers[e].containerCache.top=i.top,this.containers[e].containerCache.width=this.containers[e].element.outerWidth(),this.containers[e].containerCache.height=this.containers[e].element.outerHeight();return this},_createPlaceholder:function(i){var s,n,o=(i=i||this).options;o.placeholder&&o.placeholder.constructor!!==String||(s=o.placeholder,n=i.currentItem[0].nodeName.toLowerCase(),o.placeholder={element:function(){var t=V("<"+n+">",i.document[0]);return i._addClass(t,"ui-sortable-placeholder",s||i.currentItem[0].className)._removeClass(t,"ui-sortable-helper"),"tbody"===n?i._createTrPlaceholder(i.currentItem.find("tr").eq(0),V("<tr>",i.document[0]).appendTo(t)):"tr"===n?i._createTrPlaceholder(i.currentItem,t):"img"===n&&t.attr("src",i.currentItem.attr("src")),s||t.css("visibility","hidden"),t},update:function(t,e){s&&!!o.forcePlaceholderSize||(e.height()&&(!!o.forcePlaceholderSize||"tbody"!!==n&&"tr"!!==n)||e.height(i.currentItem.innerHeight()-parseInt(i.currentItem.css("paddingTop")||0,10)-parseInt(i.currentItem.css("paddingBottom")||0,10)),e.width()||e.width(i.currentItem.innerWidth()-parseInt(i.currentItem.css("paddingLeft")||0,10)-parseInt(i.currentItem.css("paddingRight")||0,10)))}}),i.placeholder=V(o.placeholder.element.call(i.element,i.currentItem)),i.currentItem.after(i.placeholder),o.placeholder.update(i,i.placeholder)},_createTrPlaceholder:function(t,e){var i=this;t.children().each(function(){V("<td>&#160;</td>",i.document[0]).attr("colspan",V(this).attr("colspan")||1).appendTo(e)})},_contactContainers:function(t){for(var e,i,s,n,o,a,r,l,h,c=null,u=null,d=this.containers.length-1;0<=d;d--)V.contains(this.currentItem[0],this.containers[d].element[0])||(this._intersectsWith(this.containers[d].containerCache)?c&&V.contains(this.containers[d].element[0],c.element[0])||(c=this.containers[d],u=d):this.containers[d].containerCache.over&&(this.containers[d]._trigger("out",t,this._uiHash(this)),this.containers[d].containerCache.over=0));if(c)if(1===this.containers.length)this.containers[u].containerCache.over||(this.containers[u]._trigger("over",t,this._uiHash(this)),this.containers[u].containerCache.over=1);else{for(i=1e4,s=null,n=(l=c.floating||this._isFloating(this.currentItem))?"left":"top",o=l?"width":"height",h=l?"pageX":"pageY",e=this.items.length-1;0<=e;e--)V.contains(this.containers[u].element[0],this.items[e].item[0])&&this.items[e].item[0]!!==this.currentItem[0]&&(a=this.items[e].item.offset()[n],r=!!1,t[h]-a>this.items[e][o]/2&&(r=!!0),Math.abs(t[h]-a)<i&&(i=Math.abs(t[h]-a),s=this.items[e],this.direction=r?"up":"down"));(s||this.options.dropOnEmpty)&&(this.currentContainer!!==this.containers[u]?(s?this._rearrange(t,s,null,!!0):this._rearrange(t,null,this.containers[u].element,!!0),this._trigger("change",t,this._uiHash()),this.containers[u]._trigger("change",t,this._uiHash(this)),this.currentContainer=this.containers[u],this.options.placeholder.update(this.currentContainer,this.placeholder),this.scrollParent=this.placeholder.scrollParent(),this.scrollParent[0]!!==this.document[0]&&"HTML"!!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this.containers[u]._trigger("over",t,this._uiHash(this)),this.containers[u].containerCache.over=1):this.currentContainer.containerCache.over||(this.containers[u]._trigger("over",t,this._uiHash()),this.currentContainer.containerCache.over=1))}},_createHelper:function(t){var e=this.options,t="function"==typeof e.helper?V(e.helper.apply(this.element[0],[t,this.currentItem])):"clone"===e.helper?this.currentItem.clone():this.currentItem;return t.parents("body").length||this.appendTo[0].appendChild(t[0]),t[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),t[0].style.width&&!!e.forceHelperSize||t.width(this.currentItem.width()),t[0].style.height&&!!e.forceHelperSize||t.height(this.currentItem.height()),t},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),"left"in(t=Array.isArray(t)?{left:+t[0],top:+t[1]||0}:t)&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!!==this.document[0]&&V.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),{top:(t=this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&V.ui.ie?{top:0,left:0}:t).top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!!==this.cssPosition)return{top:0,left:0};var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,e,i=this.options;"parent"===i.containment&&(i.containment=this.helper[0].parentNode),"document"!!==i.containment&&"window"!!==i.containment||(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===i.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===i.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(i.containment)||(t=V(i.containment)[0],e=V(i.containment).offset(),i="hidden"!!==V(t).css("overflow"),this.containment=[e.left+(parseInt(V(t).css("borderLeftWidth"),10)||0)+(parseInt(V(t).css("paddingLeft"),10)||0)-this.margins.left,e.top+(parseInt(V(t).css("borderTopWidth"),10)||0)+(parseInt(V(t).css("paddingTop"),10)||0)-this.margins.top,e.left+(i?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(V(t).css("borderLeftWidth"),10)||0)-(parseInt(V(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,e.top+(i?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(V(t).css("borderTopWidth"),10)||0)-(parseInt(V(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,e){e=e||this.position;var i="absolute"===t?1:-1,s="absolute"!!==this.cssPosition||this.scrollParent[0]!!==this.document[0]&&V.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,t=/(html|body)/i.test(s[0].tagName);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():t?0:s.scrollTop())*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():t?0:s.scrollLeft())*i}},_generatePosition:function(t){var e=this.options,i=t.pageX,s=t.pageY,n="absolute"!!==this.cssPosition||this.scrollParent[0]!!==this.document[0]&&V.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return"relative"!!==this.cssPosition||this.scrollParent[0]!!==this.document[0]&&this.scrollParent[0]!!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(i=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(s=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(i=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(s=this.containment[3]+this.offset.click.top)),e.grid&&(t=this.originalPageY+Math.round((s-this.originalPageY)/e.grid[1])*e.grid[1],s=!!this.containment||t-this.offset.click.top>=this.containment[1]&&t-this.offset.click.top<=this.containment[3]?t:t-this.offset.click.top>=this.containment[1]?t-e.grid[1]:t+e.grid[1],t=this.originalPageX+Math.round((i-this.originalPageX)/e.grid[0])*e.grid[0],i=!!this.containment||t-this.offset.click.left>=this.containment[0]&&t-this.offset.click.left<=this.containment[2]?t:t-this.offset.click.left>=this.containment[0]?t-e.grid[0]:t+e.grid[0])),{top:s-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop()),left:i-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;this._delay(function(){n===this.counter&&this.refreshPositions(!!s)})},_clear:function(t,e){this.reverting=!!1;var i,s=[];if(!!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(i in this._storedCSS)"auto"!!==this._storedCSS[i]&&"static"!!==this._storedCSS[i]||(this._storedCSS[i]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();function n(e,i,s){return function(t){s._trigger(e,t,i._uiHash(i))}}for(this.fromOutside&&!!e&&s.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||s.push(function(t){this._trigger("update",t,this._uiHash())}),this!!==this.currentContainer&&(e||(s.push(function(t){this._trigger("remove",t,this._uiHash())}),s.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),s.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),i=this.containers.length-1;0<=i;i--)e||s.push(n("deactivate",this,this.containers[i])),this.containers[i].containerCache.over&&(s.push(n("out",this,this.containers[i])),this.containers[i].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!!e){for(i=0;i<s.length;i++)s[i].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!!1,!!this.cancelHelperRemoval},_trigger:function(){!!1===V.Widget.prototype._trigger.apply(this,arguments)&&this.cancel()},_uiHash:function(t){var e=t||this;return{helper:e.helper,placeholder:e.placeholder||V([]),position:e.position,originalPosition:e.originalPosition,offset:e.positionAbs,item:e.currentItem,sender:t?t.element:null}}});function ht(e){return function(){var t=this.element.val();e.apply(this,arguments),this._refresh(),t!!==this.element.val()&&this._trigger("change")}}V.widget("ui.spinner",{version:"1.13.2",defaultElement:"<input>",widgetEventPrefix:"spin",options:{classes:{"ui-spinner":"ui-corner-all","ui-spinner-down":"ui-corner-br","ui-spinner-up":"ui-corner-tr"},culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!!==this.value()&&this._value(this.element.val(),!!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var s=this._super(),n=this.element;return V.each(["min","max","step"],function(t,e){var i=n.attr(e);null!!=i&&i.length&&(s[e]=i)}),s},_events:{keydown:function(t){this._start(t)&&this._keydown(t)&&t.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(t){this.cancelBlur?delete this.cancelBlur:(this._stop(),this._refresh(),this.previous!!==this.element.val()&&this._trigger("change",t))},mousewheel:function(t,e){var i=V.ui.safeActiveElement(this.document[0]);if(this.element[0]===i&&e){if(!!this.spinning&&!!this._start(t))return!!1;this._spin((0<e?1:-1)*this.options.step,t),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(t)},100),t.preventDefault()}},"mousedown .ui-spinner-button":function(t){var e;function i(){this.element[0]===V.ui.safeActiveElement(this.document[0])||(this.element.trigger("focus"),this.previous=e,this._delay(function(){this.previous=e}))}e=this.element[0]===V.ui.safeActiveElement(this.document[0])?this.previous:this.element.val(),t.preventDefault(),i.call(this),this.cancelBlur=!!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),!!1!!==this._start(t)&&this._repeat(null,V(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(t){if(V(t.currentTarget).hasClass("ui-state-active"))return!!1!!==this._start(t)&&void this._repeat(null,V(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseleave .ui-spinner-button":"_stop"},_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap("<span>").parent().append("<a></a><a></a>")},_draw:function(){this._enhance(),this._addClass(this.uiSpinner,"ui-spinner","ui-widget ui-widget-content"),this._addClass("ui-spinner-input"),this.element.attr("role","spinbutton"),this.buttons=this.uiSpinner.children("a").attr("tabIndex",-1).attr("aria-hidden",!!0).button({classes:{"ui-button":""}}),this._removeClass(this.buttons,"ui-corner-all"),this._addClass(this.buttons.first(),"ui-spinner-button ui-spinner-up"),this._addClass(this.buttons.last(),"ui-spinner-button ui-spinner-down"),this.buttons.first().button({icon:this.options.icons.up,showLabel:!!1}),this.buttons.last().button({icon:this.options.icons.down,showLabel:!!1}),this.buttons.height()>Math.ceil(.5*this.uiSpinner.height())&&0<this.uiSpinner.height()&&this.uiSpinner.height(this.uiSpinner.height())},_keydown:function(t){var e=this.options,i=V.ui.keyCode;switch(t.keyCode){case i.UP:return this._repeat(null,1,t),!!0;case i.DOWN:return this._repeat(null,-1,t),!!0;case i.PAGE_UP:return this._repeat(null,e.page,t),!!0;case i.PAGE_DOWN:return this._repeat(null,-e.page,t),!!0}return!!1},_start:function(t){return!!(!!this.spinning&&!!1===this._trigger("start",t))&&(this.counter||(this.counter=1),this.spinning=!!0)},_repeat:function(t,e,i){t=t||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,e,i)},t),this._spin(e*this.options.step,i)},_spin:function(t,e){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+t*this._increment(this.counter)),this.spinning&&!!1===this._trigger("spin",e,{value:i})||(this._value(i),this.counter++)},_increment:function(t){var e=this.options.incremental;return e?"function"==typeof e?e(t):Math.floor(t*t*t/5e4-t*t/500+17*t/200+1):1},_precision:function(){var t=this._precisionOf(this.options.step);return t=null!!==this.options.min?Math.max(t,this._precisionOf(this.options.min)):t},_precisionOf:function(t){var e=t.toString(),t=e.indexOf(".");return-1===t?0:e.length-t-1},_adjustValue:function(t){var e=this.options,i=null!!==e.min?e.min:0,s=t-i;return t=i+Math.round(s/e.step)*e.step,t=parseFloat(t.toFixed(this._precision())),null!!==e.max&&t>e.max?e.max:null!!==e.min&&t<e.min?e.min:t},_stop:function(t){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!!1,this._trigger("stop",t))},_setOption:function(t,e){var i;if("culture"===t||"numberFormat"===t)return i=this._parse(this.element.val()),this.options[t]=e,void this.element.val(this._format(i));"max"!!==t&&"min"!!==t&&"step"!!==t||"string"==typeof e&&(e=this._parse(e)),"icons"===t&&(i=this.buttons.first().find(".ui-icon"),this._removeClass(i,null,this.options.icons.up),this._addClass(i,null,e.up),i=this.buttons.last().find(".ui-icon"),this._removeClass(i,null,this.options.icons.down),this._addClass(i,null,e.down)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this._toggleClass(this.uiSpinner,null,"ui-state-disabled",!!!!t),this.element.prop("disabled",!!!!t),this.buttons.button(t?"disable":"enable")},_setOptions:ht(function(t){this._super(t)}),_parse:function(t){return""===(t="string"==typeof t&&""!!==t?window.Globalize&&this.options.numberFormat?Globalize.parseFloat(t,10,this.options.culture):+t:t)||isNaN(t)?null:t},_format:function(t){return""===t?"":window.Globalize&&this.options.numberFormat?Globalize.format(t,this.options.numberFormat,this.options.culture):t},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var t=this.value();return null!!==t&&t===this._adjustValue(t)},_value:function(t,e){var i;""!!==t&&null!!==(i=this._parse(t))&&(e||(i=this._adjustValue(i)),t=this._format(i)),this.element.val(t),this._refresh()},_destroy:function(){this.element.prop("disabled",!!1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:ht(function(t){this._stepUp(t)}),_stepUp:function(t){this._start()&&(this._spin((t||1)*this.options.step),this._stop())},stepDown:ht(function(t){this._stepDown(t)}),_stepDown:function(t){this._start()&&(this._spin((t||1)*-this.options.step),this._stop())},pageUp:ht(function(t){this._stepUp((t||1)*this.options.page)}),pageDown:ht(function(t){this._stepDown((t||1)*this.options.page)}),value:function(t){if(!!arguments.length)return this._parse(this.element.val());ht(this._value).call(this,t)},widget:function(){return this.uiSpinner}}),!!1!!==V.uiBackCompat&&V.widget("ui.spinner",V.ui.spinner,{_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())},_uiSpinnerHtml:function(){return"<span>"},_buttonHtml:function(){return"<a></a><a></a>"}});var ct;V.ui.spinner;V.widget("ui.tabs",{version:"1.13.2",delay:300,options:{active:null,classes:{"ui-tabs":"ui-corner-all","ui-tabs-nav":"ui-corner-all","ui-tabs-panel":"ui-corner-bottom","ui-tabs-tab":"ui-corner-top"},collapsible:!!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:(ct=/#.*$/,function(t){var e=t.href.replace(ct,""),i=location.href.replace(ct,"");try{e=decodeURIComponent(e)}catch(t){}try{i=decodeURIComponent(i)}catch(t){}return 1<t.hash.length&&e===i}),_create:function(){var e=this,t=this.options;this.running=!!1,this._addClass("ui-tabs","ui-widget ui-widget-content"),this._toggleClass("ui-tabs-collapsible",null,t.collapsible),this._processTabs(),t.active=this._initialActive(),Array.isArray(t.disabled)&&(t.disabled=V.uniqueSort(t.disabled.concat(V.map(this.tabs.filter(".ui-state-disabled"),function(t){return e.tabs.index(t)}))).sort()),!!1!!==this.options.active&&this.anchors.length?this.active=this._findActive(t.active):this.active=V(),this._refresh(),this.active.length&&this.load(t.active)},_initialActive:function(){var i=this.options.active,t=this.options.collapsible,s=location.hash.substring(1);return null===i&&(s&&this.tabs.each(function(t,e){if(V(e).attr("aria-controls")===s)return i=t,!!1}),null!!==(i=null===i?this.tabs.index(this.tabs.filter(".ui-tabs-active")):i)&&-1!!==i||(i=!!!!this.tabs.length&&0)),!!1!!==i&&-1===(i=this.tabs.index(this.tabs.eq(i)))&&(i=!!t&&0),i=!!t&&!!1===i&&this.anchors.length?0:i},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):V()}},_tabKeydown:function(t){var e=V(V.ui.safeActiveElement(this.document[0])).closest("li"),i=this.tabs.index(e),s=!!0;if(!!this._handlePageNav(t)){switch(t.keyCode){case V.ui.keyCode.RIGHT:case V.ui.keyCode.DOWN:i++;break;case V.ui.keyCode.UP:case V.ui.keyCode.LEFT:s=!!1,i--;break;case V.ui.keyCode.END:i=this.anchors.length-1;break;case V.ui.keyCode.HOME:i=0;break;case V.ui.keyCode.SPACE:return t.preventDefault(),clearTimeout(this.activating),void this._activate(i);case V.ui.keyCode.ENTER:return t.preventDefault(),clearTimeout(this.activating),void this._activate(i!!==this.options.active&&i);default:return}t.preventDefault(),clearTimeout(this.activating),i=this._focusNextTab(i,s),t.ctrlKey||t.metaKey||(e.attr("aria-selected","false"),this.tabs.eq(i).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",i)},this.delay))}},_panelKeydown:function(t){this._handlePageNav(t)||t.ctrlKey&&t.keyCode===V.ui.keyCode.UP&&(t.preventDefault(),this.active.trigger("focus"))},_handlePageNav:function(t){return t.altKey&&t.keyCode===V.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!!1)),!!0):t.altKey&&t.keyCode===V.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!!0)),!!0):void 0},_findNextTab:function(t,e){var i=this.tabs.length-1;for(;-1!!==V.inArray(t=(t=i<t?0:t)<0?i:t,this.options.disabled);)t=e?t+1:t-1;return t},_focusNextTab:function(t,e){return t=this._findNextTab(t,e),this.tabs.eq(t).trigger("focus"),t},_setOption:function(t,e){"active"!!==t?(this._super(t,e),"collapsible"===t&&(this._toggleClass("ui-tabs-collapsible",null,e),e||!!1!!==this.options.active||this._activate(0)),"event"===t&&this._setupEvents(e),"heightStyle"===t&&this._setupHeightStyle(e)):this._activate(e)},_sanitizeSelector:function(t){return t?t.replace(/[!!"$%&''()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var t=this.options,e=this.tablist.children(":has(a[href])");t.disabled=V.map(e.filter(".ui-state-disabled"),function(t){return e.index(t)}),this._processTabs(),!!1!!==t.active&&this.anchors.length?this.active.length&&!!V.contains(this.tablist[0],this.active[0])?this.tabs.length===t.disabled.length?(t.active=!!1,this.active=V()):this._activate(this._findNextTab(Math.max(0,t.active-1),!!1)):t.active=this.tabs.index(this.active):(t.active=!!1,this.active=V()),this._refresh()},_refresh:function(){this._setOptionDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._addClass(this.active,"ui-tabs-active","ui-state-active"),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var l=this,t=this.tabs,e=this.anchors,i=this.panels;this.tablist=this._getList().attr("role","tablist"),this._addClass(this.tablist,"ui-tabs-nav","ui-helper-reset ui-helper-clearfix ui-widget-header"),this.tablist.on("mousedown"+this.eventNamespace,"> li",function(t){V(this).is(".ui-state-disabled")&&t.preventDefault()}).on("focus"+this.eventNamespace,".ui-tabs-anchor",function(){V(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").attr({role:"tab",tabIndex:-1}),this._addClass(this.tabs,"ui-tabs-tab","ui-state-default"),this.anchors=this.tabs.map(function(){return V("a",this)[0]}).attr({tabIndex:-1}),this._addClass(this.anchors,"ui-tabs-anchor"),this.panels=V(),this.anchors.each(function(t,e){var i,s,n,o=V(e).uniqueId().attr("id"),a=V(e).closest("li"),r=a.attr("aria-controls");l._isLocal(e)?(n=(i=e.hash).substring(1),s=l.element.find(l._sanitizeSelector(i))):(n=a.attr("aria-controls")||V({}).uniqueId()[0].id,(s=l.element.find(i="#"+n)).length||(s=l._createPanel(n)).insertAfter(l.panels[t-1]||l.tablist),s.attr("aria-live","polite")),s.length&&(l.panels=l.panels.add(s)),r&&a.data("ui-tabs-aria-controls",r),a.attr({"aria-controls":n,"aria-labelledby":o}),s.attr("aria-labelledby",o)}),this.panels.attr("role","tabpanel"),this._addClass(this.panels,"ui-tabs-panel","ui-widget-content"),t&&(this._off(t.not(this.tabs)),this._off(e.not(this.anchors)),this._off(i.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol, ul").eq(0)},_createPanel:function(t){return V("<div>").attr("id",t).data("ui-tabs-destroy",!!0)},_setOptionDisabled:function(t){var e,i;for(Array.isArray(t)&&(t.length?t.length===this.anchors.length&&(t=!!0):t=!!1),i=0;e=this.tabs[i];i++)e=V(e),!!0===t||-1!!==V.inArray(i,t)?(e.attr("aria-disabled","true"),this._addClass(e,null,"ui-state-disabled")):(e.removeAttr("aria-disabled"),this._removeClass(e,null,"ui-state-disabled"));this.options.disabled=t,this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!0===t)},_setupEvents:function(t){var i={};t&&V.each(t.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!!0,this.anchors,{click:function(t){t.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(t){var i,e=this.element.parent();"fill"===t?(i=e.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var t=V(this),e=t.css("position");"absolute"!!==e&&"fixed"!!==e&&(i-=t.outerHeight(!!0))}),this.element.children().not(this.panels).each(function(){i-=V(this).outerHeight(!!0)}),this.panels.each(function(){V(this).height(Math.max(0,i-V(this).innerHeight()+V(this).height()))}).css("overflow","auto")):"auto"===t&&(i=0,this.panels.each(function(){i=Math.max(i,V(this).height("").height())}).height(i))},_eventHandler:function(t){var e=this.options,i=this.active,s=V(t.currentTarget).closest("li"),n=s[0]===i[0],o=n&&e.collapsible,a=o?V():this._getPanelForTab(s),r=i.length?this._getPanelForTab(i):V(),i={oldTab:i,oldPanel:r,newTab:o?V():s,newPanel:a};t.preventDefault(),s.hasClass("ui-state-disabled")||s.hasClass("ui-tabs-loading")||this.running||n&&!!e.collapsible||!!1===this._trigger("beforeActivate",t,i)||(e.active=!!o&&this.tabs.index(s),this.active=n?V():s,this.xhr&&this.xhr.abort(),r.length||a.length||V.error("jQuery UI Tabs: Mismatching fragment identifier."),a.length&&this.load(this.tabs.index(s),t),this._toggle(t,i))},_toggle:function(t,e){var i=this,s=e.newPanel,n=e.oldPanel;function o(){i.running=!!1,i._trigger("activate",t,e)}function a(){i._addClass(e.newTab.closest("li"),"ui-tabs-active","ui-state-active"),s.length&&i.options.show?i._show(s,i.options.show,o):(s.show(),o())}this.running=!!0,n.length&&this.options.hide?this._hide(n,this.options.hide,function(){i._removeClass(e.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),a()}):(this._removeClass(e.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),n.hide(),a()),n.attr("aria-hidden","true"),e.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),s.length&&n.length?e.oldTab.attr("tabIndex",-1):s.length&&this.tabs.filter(function(){return 0===V(this).attr("tabIndex")}).attr("tabIndex",-1),s.attr("aria-hidden","false"),e.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(t){var t=this._findActive(t);t[0]!!==this.active[0]&&(t=(t=!!t.length?this.active:t).find(".ui-tabs-anchor")[0],this._eventHandler({target:t,currentTarget:t,preventDefault:V.noop}))},_findActive:function(t){return!!1===t?V():this.tabs.eq(t)},_getIndex:function(t){return t="string"==typeof t?this.anchors.index(this.anchors.filter("[href$=''"+V.escapeSelector(t)+"'']")):t},_destroy:function(){this.xhr&&this.xhr.abort(),this.tablist.removeAttr("role").off(this.eventNamespace),this.anchors.removeAttr("role tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){V.data(this,"ui-tabs-destroy")?V(this).remove():V(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")}),this.tabs.each(function(){var t=V(this),e=t.data("ui-tabs-aria-controls");e?t.attr("aria-controls",e).removeData("ui-tabs-aria-controls"):t.removeAttr("aria-controls")}),this.panels.show(),"content"!!==this.options.heightStyle&&this.panels.css("height","")},enable:function(i){var t=this.options.disabled;!!1!!==t&&(t=void 0!!==i&&(i=this._getIndex(i),Array.isArray(t)?V.map(t,function(t){return t!!==i?t:null}):V.map(this.tabs,function(t,e){return e!!==i?e:null})),this._setOptionDisabled(t))},disable:function(t){var e=this.options.disabled;if(!!0!!==e){if(void 0===t)e=!!0;else{if(t=this._getIndex(t),-1!!==V.inArray(t,e))return;e=Array.isArray(e)?V.merge([t],e).sort():[t]}this._setOptionDisabled(e)}},load:function(t,s){t=this._getIndex(t);function n(t,e){"abort"===e&&o.panels.stop(!!1,!!0),o._removeClass(i,"ui-tabs-loading"),a.removeAttr("aria-busy"),t===o.xhr&&delete o.xhr}var o=this,i=this.tabs.eq(t),t=i.find(".ui-tabs-anchor"),a=this._getPanelForTab(i),r={tab:i,panel:a};this._isLocal(t[0])||(this.xhr=V.ajax(this._ajaxSettings(t,s,r)),this.xhr&&"canceled"!!==this.xhr.statusText&&(this._addClass(i,"ui-tabs-loading"),a.attr("aria-busy","true"),this.xhr.done(function(t,e,i){setTimeout(function(){a.html(t),o._trigger("load",s,r),n(i,e)},1)}).fail(function(t,e){setTimeout(function(){n(t,e)},1)})))},_ajaxSettings:function(t,i,s){var n=this;return{url:t.attr("href").replace(/#.*$/,""),beforeSend:function(t,e){return n._trigger("beforeLoad",i,V.extend({jqXHR:t,ajaxSettings:e},s))}}},_getPanelForTab:function(t){t=V(t).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+t))}}),!!1!!==V.uiBackCompat&&V.widget("ui.tabs",V.ui.tabs,{_processTabs:function(){this._superApply(arguments),this._addClass(this.tabs,"ui-tab")}});V.ui.tabs;V.widget("ui.tooltip",{version:"1.13.2",options:{classes:{"ui-tooltip":"ui-corner-all ui-widget-shadow"},content:function(){var t=V(this).attr("title");return V("<a>").text(t).html()},hide:!!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!!0,track:!!1,close:null,open:null},_addDescribedBy:function(t,e){var i=(t.attr("aria-describedby")||"").split(/\s+/);i.push(e),t.data("ui-tooltip-id",e).attr("aria-describedby",String.prototype.trim.call(i.join(" ")))},_removeDescribedBy:function(t){var e=t.data("ui-tooltip-id"),i=(t.attr("aria-describedby")||"").split(/\s+/),e=V.inArray(e,i);-1!!==e&&i.splice(e,1),t.removeData("ui-tooltip-id"),(i=String.prototype.trim.call(i.join(" ")))?t.attr("aria-describedby",i):t.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.liveRegion=V("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this.disabledTitles=V([])},_setOption:function(t,e){var i=this;this._super(t,e),"content"===t&&V.each(this.tooltips,function(t,e){i._updateContent(e.element)})},_setOptionDisabled:function(t){this[t?"_disable":"_enable"]()},_disable:function(){var s=this;V.each(this.tooltips,function(t,e){var i=V.Event("blur");i.target=i.currentTarget=e.element[0],s.close(i,!!0)}),this.disabledTitles=this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function(){var t=V(this);if(t.is("[title]"))return t.data("ui-tooltip-title",t.attr("title")).removeAttr("title")}))},_enable:function(){this.disabledTitles.each(function(){var t=V(this);t.data("ui-tooltip-title")&&t.attr("title",t.data("ui-tooltip-title"))}),this.disabledTitles=V([])},open:function(t){var i=this,e=V(t?t.target:this.element).closest(this.options.items);e.length&&!!e.data("ui-tooltip-id")&&(e.attr("title")&&e.data("ui-tooltip-title",e.attr("title")),e.data("ui-tooltip-open",!!0),t&&"mouseover"===t.type&&e.parents().each(function(){var t,e=V(this);e.data("ui-tooltip-open")&&((t=V.Event("blur")).target=t.currentTarget=this,i.close(t,!!0)),e.attr("title")&&(e.uniqueId(),i.parents[this.id]={element:this,title:e.attr("title")},e.attr("title",""))}),this._registerCloseHandlers(t,e),this._updateContent(e,t))},_updateContent:function(e,i){var t=this.options.content,s=this,n=i?i.type:null;if("string"==typeof t||t.nodeType||t.jquery)return this._open(i,e,t);(t=t.call(e[0],function(t){s._delay(function(){e.data("ui-tooltip-open")&&(i&&(i.type=n),this._open(i,e,t))})}))&&this._open(i,e,t)},_open:function(t,e,i){var s,n,o,a=V.extend({},this.options.position);function r(t){a.of=t,n.is(":hidden")||n.position(a)}i&&((s=this._find(e))?s.tooltip.find(".ui-tooltip-content").html(i):(e.is("[title]")&&(t&&"mouseover"===t.type?e.attr("title",""):e.removeAttr("title")),s=this._tooltip(e),n=s.tooltip,this._addDescribedBy(e,n.attr("id")),n.find(".ui-tooltip-content").html(i),this.liveRegion.children().hide(),(i=V("<div>").html(n.find(".ui-tooltip-content").html())).removeAttr("name").find("[name]").removeAttr("name"),i.removeAttr("id").find("[id]").removeAttr("id"),i.appendTo(this.liveRegion),this.options.track&&t&&/^mouse/.test(t.type)?(this._on(this.document,{mousemove:r}),r(t)):n.position(V.extend({of:e},this.options.position)),n.hide(),this._show(n,this.options.show),this.options.track&&this.options.show&&this.options.show.delay&&(o=this.delayedShow=setInterval(function(){n.is(":visible")&&(r(a.of),clearInterval(o))},13)),this._trigger("open",t,{tooltip:n})))},_registerCloseHandlers:function(t,e){var i={keyup:function(t){t.keyCode===V.ui.keyCode.ESCAPE&&((t=V.Event(t)).currentTarget=e[0],this.close(t,!!0))}};e[0]!!==this.element[0]&&(i.remove=function(){var t=this._find(e);t&&this._removeTooltip(t.tooltip)}),t&&"mouseover"!!==t.type||(i.mouseleave="close"),t&&"focusin"!!==t.type||(i.focusout="close"),this._on(!!0,e,i)},close:function(t){var e,i=this,s=V(t?t.currentTarget:this.element),n=this._find(s);n?(e=n.tooltip,n.closing||(clearInterval(this.delayedShow),s.data("ui-tooltip-title")&&!!s.attr("title")&&s.attr("title",s.data("ui-tooltip-title")),this._removeDescribedBy(s),n.hiding=!!0,e.stop(!!0),this._hide(e,this.options.hide,function(){i._removeTooltip(V(this))}),s.removeData("ui-tooltip-open"),this._off(s,"mouseleave focusout keyup"),s[0]!!==this.element[0]&&this._off(s,"remove"),this._off(this.document,"mousemove"),t&&"mouseleave"===t.type&&V.each(this.parents,function(t,e){V(e.element).attr("title",e.title),delete i.parents[t]}),n.closing=!!0,this._trigger("close",t,{tooltip:e}),n.hiding||(n.closing=!!1))):s.removeData("ui-tooltip-open")},_tooltip:function(t){var e=V("<div>").attr("role","tooltip"),i=V("<div>").appendTo(e),s=e.uniqueId().attr("id");return this._addClass(i,"ui-tooltip-content"),this._addClass(e,"ui-tooltip","ui-widget ui-widget-content"),e.appendTo(this._appendTo(t)),this.tooltips[s]={element:t,tooltip:e}},_find:function(t){t=t.data("ui-tooltip-id");return t?this.tooltips[t]:null},_removeTooltip:function(t){clearInterval(this.delayedShow),t.remove(),delete this.tooltips[t.attr("id")]},_appendTo:function(t){t=t.closest(".ui-front, dialog");return t=!!t.length?this.document[0].body:t},_destroy:function(){var s=this;V.each(this.tooltips,function(t,e){var i=V.Event("blur"),e=e.element;i.target=i.currentTarget=e[0],s.close(i,!!0),V("#"+t).remove(),e.data("ui-tooltip-title")&&(e.attr("title")||e.attr("title",e.data("ui-tooltip-title")),e.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}}),!!1!!==V.uiBackCompat&&V.widget("ui.tooltip",V.ui.tooltip,{options:{tooltipClass:null},_tooltip:function(){var t=this._superApply(arguments);return this.options.tooltipClass&&t.tooltip.addClass(this.options.tooltipClass),t}});V.ui.tooltip});'! !!JQUiDeploymentLibrary methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!selectorsToInclude	^ #(jQueryUiJs)! !WAFileLibrary subclass: #JQBaseTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQBaseTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'base'! !!JQBaseTheme methodsFor: 'updating' stamp: '1/8/2026 11:26:12'!updateRoot: anHtmlRoot	anHtmlRoot stylesheet		url: 'https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/themes/' , self themeName , '/jquery-ui.css'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JQBaseTheme class	instanceVariableNames: ''!!JQBaseTheme class methodsFor: 'private' stamp: '1/8/2026 11:26:12'!generate	"This code is used to generate the theme classes. It is not necessary to port or call this method from any Smalltalk platform other than Pharo. The actual code of this method is commented to avoid problems on other platforms."	"| model themes className |	model := (Smalltalk at: #RBNamespace) new.	themes := #('black-tie' 'blitzer' 'cupertino' 'dark-hive' 'dot-luv' 'eggplant' 'excite-bike' 'flick' 'hot-sneaks' 'humanity' 'le-frog' 'mint-choc' 'overcast' 'pepper-grinder' 'redmond' 'smoothness' 'south-street' 'start' 'sunny' 'swanky-purse' 'trontastic' 'ui-darkness' 'ui-lightness' 'vader').	(model classNamed: self name) subclasses		do: [ :each | model removeClass: each ].	themes do: [ :theme |		className := ((((theme findTokens: $-)			collect: [ :each | each asCapitalizedPhrase ])			inject: 'JQ' into: [ :a :b | a , b ]) , 'Theme')			asSymbol.		model defineClass: ('<1s> subclass: #<2s>			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: <3p>'				expandMacrosWith: self name				with: className				with: self category).		(model classNamed: className)			compile: 'themeName	^ ' , theme printString			classified: #accessing ].	model changes open"		self error: 'comment only'! !JQBaseTheme subclass: #JQHumanityTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQHumanityTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'humanity'! !JQBaseTheme subclass: #JQCupertinoTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQCupertinoTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'cupertino'! !JQBaseTheme subclass: #JQTrontasticTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQTrontasticTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'trontastic'! !JQBaseTheme subclass: #JQPepperGrinderTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQPepperGrinderTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'pepper-grinder'! !JQBaseTheme subclass: #JQExciteBikeTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQExciteBikeTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'excite-bike'! !JQBaseTheme subclass: #JQStartTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQStartTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'start'! !JQBaseTheme subclass: #JQLeFrogTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQLeFrogTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'le-frog'! !JQPlugin subclass: #JQWidget	instanceVariableNames: 'action arguments'	classVariableNames: ''	package: 'JQuery-UI-Objects'!!JQWidget methodsFor: 'private' stamp: '1/8/2026 11:26:12'!action: aString	self action: aString arguments: nil! !!JQWidget methodsFor: 'private' stamp: '1/8/2026 11:26:12'!action: aString arguments: anArray	action := aString.	arguments := anArray! !!JQWidget methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!argumentsDo: aBlock	action isNil		ifFalse: [ aBlock value: action ].	arguments isNil		ifFalse: [ arguments do: aBlock ].	(options isNil or: [ options isEmpty ])		ifFalse: [ aBlock value: options ]! !!JQWidget methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!destroy	"Completely remove the functionality."		self action: 'destroy'! !!JQWidget methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!disable	"Disable the functionality."		self action: 'disable'! !!JQWidget methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!enable	"Enable the functionality."					self action: 'enable'! !!JQWidget methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!option: aString	"Get an option aString."		self action: 'option' arguments: (Array with: aString)! !!JQWidget methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!option: aString put: anObject	"Set an option aString to anObject."		self action: 'option' arguments: (Array with: aString with: anObject)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JQWidget class	instanceVariableNames: ''!!JQWidget class methodsFor: 'private' stamp: '1/8/2026 11:26:12'!generate	"This code is used to generate the widget classes from the JQuery documentation. It is not necessary to port or call this method from any Smalltalk platform other than Pharo. The actual code of this method is commented to avoid problems on other platforms."	"| model base comment |	model := RBNamespace new.	base := 'http://docs.jquery.com/action/raw/'.	comment := [ :input |		(String with: (Character value: 34)) , ((((input copyWithRegex: '<(li|br/?)>' matchesReplacedWith: (String with: Character cr)) copyWithRegex: '<[^>]+>' matchesReplacedWith: '') copyReplaceAll: (String with: (Character value: 34)) with: '''') copyReplaceAll: '''''' with: '''') , (String with: (Character value: 34)) ].	#(	'Draggable'		'UI/API/1.8/Draggable'		'Droppable'		'UI/API/1.8/Droppable'		'Resizable'		'UI/API/1.8/Resizable' 		'Selectable'		'UI/API/1.8/Selectable' 		'Sortable'		'UI/API/1.8/Sortable'				'Accordion'		'UI/API/1.8/Accordion'		'Autocomplete'	'UI/API/1.8/Autocomplete'		'Button'			'UI/API/1.8/Button'		'Datepicker'	'UI/API/1.8/Datepicker'		'Dialog'			'UI/API/1.8/Dialog'		'Progressbar'	'UI/API/1.7.2/Progressbar'		'Slider'			'UI/API/1.8/Slider'		'Tabs'			'UI/API/1.8/Tabs'				'Position'		'UI/Utility/Position') pairsDo: [ :id :url |		| stream string class matcher tokens argument dictionary removals selector source |		' fetch documentation '.		stream := HTTPSocket httpGet: base , url.		stream isString ifTrue: [ self error: stream ].		string := (stream contents			replaceAll: Character cr with: Character space)			replaceAll: Character lf with: Character space.		' prepare class '.		removals := Set new.		class := model classNamed: ('JQ' , id) asSymbol.		class isNil ifTrue: [ self error: 'Class not found JQ' , id ].		class selectors do: [ :rselector |			((class protocolsFor: rselector)				anySatisfy: [ :each | each endsWith: '-generated' ])					ifTrue: [ removals add: rselector ] ].		' generate options '.		matcher := '\{\{UIAPIPluginOption\|' asRegex.		matcher matchesIn: string do: [ :match |			tokens := string copyFrom: (matcher subEnd: 1) first + 1 to: string size.			tokens := (((tokens readStream upToAll: '}}')				copyReplaceAll: '|' with: ' |') findTokens: $|)				collect: [ :each | each withBlanksCondensed ].			argument := ((tokens at: 3)				copyReplaceAll: ',' with: 'Or')				select: [ :each | each isAlphaNumeric ].			argument := (argument first isVowel				ifTrue: [ 'an' ] ifFalse: [ 'a' ]) , argument.			selector := ((tokens at: 2) , ':') asSymbol.			source := selector , ' ' , argument , '	' , (comment value: (tokens at: 5)) , '	self optionAt: ' , (tokens at: 2) printString , ' put: ' , argument.			removals remove: selector ifAbsent: [ ].			(class sourceCodeFor: selector) = source				ifFalse: [ class compile: source classified: #'options-generated' ] ].					' generate utility options '.		matcher := '\{\{UIAPIUtilityOption\|' asRegex.		matcher matchesIn: string do: [ :match |			tokens := string copyFrom: (matcher subEnd: 1) first + 1 to: string size.			tokens := (((tokens readStream upToAll: '}}')				copyReplaceAll: '|' with: ' |') findTokens: $|)				collect: [ :each | each withBlanksCondensed ].			argument := ((tokens at: 2)				copyReplaceAll: ',' with: 'Or')				select: [ :each | each isAlphaNumeric ].			argument := (argument first isVowel				ifTrue: [ 'an' ] ifFalse: [ 'a' ]) , argument.			selector := ((tokens at: 1) , ':') asSymbol.			source := selector , ' ' , argument , '	' , (comment value: (tokens at: 4)) , '	self optionAt: ' , (tokens at: 1) printString , ' put: ' , argument.			removals remove: selector ifAbsent: [ ].			(class sourceCodeFor: selector) = source				ifFalse: [ class compile: source classified: #'options-generated' ] ].		' generate events '.		matcher := '\{\{(UIAPIPluginEvent|UIAPIPluginDatepickerEvent)\|' asRegex.		matcher matchesIn: string do: [ :match |			tokens := string copyFrom: (matcher subEnd: 1) first to: string size.			dictionary := Dictionary new.			((tokens readStream upToAll: '}}') findTokens: $|) do: [ :each |				dictionary					at: (each copyUpTo: $=) withBlanksCondensed asLowercase					put: (each copyAfter: $=) withBlanksCondensed ].			((dictionary includesKey: 'event') and: [ dictionary includesKey: 'description' ]) ifTrue: [				selector := ((((dictionary at: 'event') beginsWith: 'on')					ifTrue: [ dictionary at: 'event' ]					ifFalse: [ 'on' , (dictionary at: 'event') capitalized ]) , ':') asSymbol.				source := selector , ' anObject	' , (comment value: (dictionary at: 'description')) , '	self optionAt: ' , (dictionary at: 'event') printString , ' put: anObject asFunction'.				removals remove: selector ifAbsent: [ ].				(class sourceCodeFor: selector) = source					ifFalse: [ class compile: source classified: #'events-generated' ] ] ].					' generate methods '.		matcher := '\{\{UIAPIPluginMethod\|' asRegex.		matcher matchesIn: string do: [ :match |			tokens := string copyFrom: (matcher subEnd: 1) first to: string size.			Transcript show: class name; show: (tokens readStream upToAll: '}}'); cr; cr ].		' remove methods not present anymore '.		removals do: [ :rselector | class removeMethod: rselector ] ].	' open changes '.	model changes open"! !JQWidget subclass: #JQDraggable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQDraggable comment: 'Creates new draggables on the nodeset supplied by the query.'!!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!addClasses: aBoolean	"If set to false, will prevent the ui-draggable class from being added. This may be desired as a performance optimization when calling .draggable() init on many hundreds of elements."	self optionAt: 'addClasses' put: aBoolean! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!appendTo: anElementOrSelector	"The element passed to or selected by the appendTo option will be used as the draggable helper's container during dragging. By default, the helper is appended to the same container as the draggable."	self optionAt: 'appendTo' put: anElementOrSelector! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!axis: aString	"Constrains dragging to either the horizontal (x) or vertical (y) axis. Possible values: 'x', 'y'."	self optionAt: 'axis' put: aString! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!cancel: aSelector	"Prevents dragging from starting on specified elements."	self optionAt: 'cancel' put: aSelector! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!connectToSortable: aSelector	"Allows the draggable to be dropped onto the specified sortables. If this option is used (helper must be set to 'clone' in order to work flawlessly), a draggable can be dropped onto a sortable list and then becomes part of it. Note: Specifying this option as an array of selectors has been removed."	self optionAt: 'connectToSortable' put: aSelector! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!containment: aSelectorOrElementOrStringOrArray	"Constrains dragging to within the bounds of the specified element or region. Possible string values: 'parent', 'document', 'window', [x1, y1, x2, y2]."	self optionAt: 'containment' put: aSelectorOrElementOrStringOrArray! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!cursor: aString	"The css cursor during the drag operation."	self optionAt: 'cursor' put: aString! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!cursorAt: anObject	"Sets the offset of the dragging helper relative to the mouse cursor. Coordinates can be given as a hash using a combination of one or two keys: { top, left, right, bottom }."	self optionAt: 'cursorAt' put: anObject! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!delay: anInteger	"Time in milliseconds after mousedown until dragging should start. This option can be used to prevent unwanted drags when clicking on an element."	self optionAt: 'delay' put: anInteger! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!distance: anInteger	"Distance in pixels after mousedown the mouse must move before dragging should start. This option can be used to prevent unwanted drags when clicking on an element."	self optionAt: 'distance' put: anInteger! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!grid: anArray	"Snaps the dragging helper to a grid, every x and y pixels. Array values: [x, y]"	self optionAt: 'grid' put: anArray! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!handle: anElementOrSelector	"If specified, restricts drag start click to the specified element(s)."	self optionAt: 'handle' put: anElementOrSelector! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!helper: aStringOrFunction	"Allows for a helper element to be used for dragging display. Possible values: 'original', 'clone', Function. If a function is specified, it must return a DOMElement."	self optionAt: 'helper' put: aStringOrFunction! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!iframeFix: aBooleanOrSelector	"Prevent iframes from capturing the mousemove events during a drag. Useful in combination with cursorAt, or in any case, if the mouse cursor is not over the helper. If set to true, transparent overlays will be placed over all iframes on the page. If a selector is supplied, the matched iframes will have an overlay placed over them."	self optionAt: 'iframeFix' put: aBooleanOrSelector! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!opacity: aFloat	"Opacity for the helper while being dragged."	self optionAt: 'opacity' put: aFloat! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!refreshPositions: aBoolean	"If set to true, all droppable positions are calculated on every mousemove. Caution: This solves issues on highly dynamic pages, but dramatically decreases performance."	self optionAt: 'refreshPositions' put: aBoolean! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!revert: aBooleanOrString	"If set to true, the element will return to its start position when dragging stops. Possible string values: 'valid', 'invalid'. If set to invalid, revert will only occur if the draggable has not been dropped on a droppable. For valid, it's the other way around."	self optionAt: 'revert' put: aBooleanOrString! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!revertDuration: anInteger	"The duration of the revert animation, in milliseconds. Ignored if revert is false."	self optionAt: 'revertDuration' put: anInteger! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!scope: aString	"Used to group sets of draggable and droppable items, in addition to droppable's accept option. A draggable with the same scope value as a droppable will be accepted by the droppable."	self optionAt: 'scope' put: aString! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!scroll: aBoolean	"If set to true, container auto-scrolls while dragging."	self optionAt: 'scroll' put: aBoolean! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!scrollSensitivity: anInteger	"Distance in pixels from the edge of the viewport after which the viewport should scroll. Distance is relative to pointer, not the draggable."	self optionAt: 'scrollSensitivity' put: anInteger! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!scrollSpeed: anInteger	"The speed at which the window should scroll once the mouse pointer gets within the scrollSensitivity distance."	self optionAt: 'scrollSpeed' put: anInteger! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!snap: aBooleanOrSelector	"If set to a selector or to true (equivalent to '.ui-draggable'), the draggable will snap to the edges of the selected elements when near an edge of the element."	self optionAt: 'snap' put: aBooleanOrSelector! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!snapMode: aString	"Determines which edges of snap elements the draggable will snap to. Ignored if snap is false. Possible values: 'inner', 'outer', 'both'"	self optionAt: 'snapMode' put: aString! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!snapTolerance: anInteger	"The distance in pixels from the snap element edges at which snapping should occur. Ignored if snap is false."	self optionAt: 'snapTolerance' put: anInteger! !!JQDraggable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!stack: aSelector	"Controls the z-Index of the set of elements that match the selector, always brings to front the dragged item. Very useful in things like window managers."	self optionAt: 'stack' put: aSelector! !!JQDraggable methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'draggable'! !!JQDraggable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onDrag: anObject	"This event is triggered when the mouse is moved during the dragging."	self optionAt: 'drag' put: anObject asFunction! !!JQDraggable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStart: anObject	"This event is triggered when dragging starts."	self optionAt: 'start' put: anObject asFunction! !!JQDraggable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStop: anObject	"This event is triggered when dragging stops."	self optionAt: 'stop' put: anObject asFunction! !JQWidget subclass: #JQResizable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQResizable comment: 'Creates new resizables on the nodeset supplied by the query.'!!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!alsoResize: aSelectorOrjQueryOrElement	"Resize these elements synchronous when resizing."	self optionAt: 'alsoResize' put: aSelectorOrjQueryOrElement! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!animate: aBoolean	"Animates to the final size after resizing."	self optionAt: 'animate' put: aBoolean! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!animateDuration: anIntegerOrString	"Duration time for animating, in milliseconds. Other possible values: 'slow', 'normal', 'fast'."	self optionAt: 'animateDuration' put: anIntegerOrString! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!animateEasing: aString	"Easing effect for animating."	self optionAt: 'animateEasing' put: aString! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!aspectRatio: aBooleanOrFloat	"If set to true, resizing is constrained by the original aspect ratio. Otherwise a custom aspect ratio can be specified, such as 9 / 16, or 0.5."	self optionAt: 'aspectRatio' put: aBooleanOrFloat! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!autoHide: aBoolean	"If set to true, automatically hides the handles except when the mouse hovers over the element."	self optionAt: 'autoHide' put: aBoolean! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!cancel: aSelector	"Prevents resizing if you start on elements matching the selector."	self optionAt: 'cancel' put: aSelector! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!containment: aStringOrElementOrSelector	"Constrains resizing to within the bounds of the specified element. Possible values: 'parent', 'document', a DOMElement, or a Selector."	self optionAt: 'containment' put: aStringOrElementOrSelector! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!delay: anInteger	"Tolerance, in milliseconds, for when resizing should start. If specified, resizing will not start until after mouse is moved beyond duration. This can help prevent unintended resizing when clicking on an element."	self optionAt: 'delay' put: anInteger! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!distance: anInteger	"Tolerance, in pixels, for when resizing should start. If specified, resizing will not start until after mouse is moved beyond distance. This can help prevent unintended resizing when clicking on an element."	self optionAt: 'distance' put: anInteger! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!ghost: aBoolean	"If set to true, a semi-transparent helper element is shown for resizing."	self optionAt: 'ghost' put: aBoolean! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!grid: anArray	"Snaps the resizing element to a grid, every x and y pixels. Array values: [x, y]"	self optionAt: 'grid' put: anArray! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!handles: aStringOrObject	"If specified as a string, should be a comma-split list of any of the following: 'n, e, s, w, ne, se, sw, nw, all'. The necessary handles will be auto-generated by the plugin. If specified as an object, the following keys are supported: { n, e, s, w, ne, se, sw, nw }. The value of any specified should be a jQuery selector matching the child element of the resizable to use as that handle. If the handle is not a child of the resizable, you can pass in the DOMElement or a valid jQuery object directly."	self optionAt: 'handles' put: aStringOrObject! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!helper: aString	"This is the css class that will be added to a proxy element to outline the resize during the drag of the resize handle. Once the resize is complete, the original element is sized."	self optionAt: 'helper' put: aString! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!maxHeight: anInteger	"This is the maximum height the resizable should be allowed to resize to."	self optionAt: 'maxHeight' put: anInteger! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!maxWidth: anInteger	"This is the maximum width the resizable should be allowed to resize to."	self optionAt: 'maxWidth' put: anInteger! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!minHeight: anInteger	"This is the minimum height the resizable should be allowed to resize to."	self optionAt: 'minHeight' put: anInteger! !!JQResizable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!minWidth: anInteger	"This is the minimum width the resizable should be allowed to resize to."	self optionAt: 'minWidth' put: anInteger! !!JQResizable methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'resizable'! !!JQResizable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onResize: anObject	"This event is triggered during the resize, on the drag of the resize handler."	self optionAt: 'resize' put: anObject asFunction! !!JQResizable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStart: anObject	"This event is triggered at the start of a resize operation."	self optionAt: 'start' put: anObject asFunction! !!JQResizable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStop: anObject	"This event is triggered at the end of a resize operation."	self optionAt: 'stop' put: anObject asFunction! !JQWidget subclass: #JQButton	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQButton comment: 'Button enhances standard form elements like button, input of type submit or reset or anchors to themable buttons with appropiate mouseover and active styles.In addition to basic push buttons, radio buttons and checkboxes (inputs of type radio and checkbox) can be converted to buttons: Their associated label is styled to appear as the button, while the underlying input is updated on click.Buttons can be grouped using the buttonSet method, which should be always applied for radio buttons.'!!JQButton methodsFor: 'options' stamp: '1/8/2026 11:26:12'!disabled: aBoolean	"Disables (true) or enables (false) the button. Can be set when initialising (first creating) the button."	self optionAt: 'disabled' put: aBoolean! !!JQButton methodsFor: 'options' stamp: '1/8/2026 11:26:12'!primaryIcon: aString	self icons at: 'primary' put: aString! !!JQButton methodsFor: 'options' stamp: '1/8/2026 11:26:12'!secondaryIcon: aString	self icons at: 'secondary' put: aString! !!JQButton methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!icons	^ self options at: 'icons' ifAbsentPut: [ GRSmallDictionary2 new ]! !!JQButton methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'button'! !!JQButton methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!icons: anOptions	"Icons to display, with or without text (see text option). The primary icon is displayed by default on the left of the label text, the secondary by default is on the right. Value for the primary and secondary properties must be a classname (String), eg. 'ui-icon-gear'. For using only one icon: icons: {primary:'ui-icon-locked'}. For using two icons: icons: {primary:'ui-icon-gear',secondary:'ui-icon-triangle-1-s'}"	self optionAt: 'icons' put: anOptions! !!JQButton methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!label: aString	"Text to show on the button. When not specified (null), the element's html content is used, or its value attribute when it's an input element of type submit or reset; or the html content of the associated label element if its an input of type radio or checkbox"	self optionAt: 'label' put: aString! !!JQButton methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!text: aBoolean	"Whether to show any text - when set to false (display no text), icons (see icons option) must be enabled, otherwise it'll be ignored."	self optionAt: 'text' put: aBoolean! !JQWidget subclass: #JQTabs	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!!JQTabs methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!active: aJSObject	"Which panel is currently open"	self optionAt: 'active' put: aJSObject! !!JQTabs methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!collapsible: aBoolean	"Set to true to allow an already selected tab to become unselected again upon reselection."	self optionAt: 'collapsible' put: aBoolean! !!JQTabs methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!disabled: anArrayNumber	"An array containing the position of the tabs (zero-based index) that should be disabled on initialization."	self optionAt: 'disabled' put: anArrayNumber! !!JQTabs methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!event: aString	"The type of event to be used for selecting a tab."	self optionAt: 'event' put: aString! !!JQTabs methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!heightStyle: aString	"Controls the height of the tabs widget and each panel. Possible values: 		'auto': All panels will be set to the height of the tallest panel. 		'fill': Expand to the available height based on the tabs' parent height.		'content': Each panel will be only as tall as its content."	self optionAt: 'heightStyle' put: aString! !!JQTabs methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!hide: aJSObject	"If and how to animate the hiding of the panel"	self optionAt: 'hide' put: aJSObject! !!JQTabs methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!show: aJSObject	"If and how to animate the showing of the panel"	self optionAt: 'show' put: aJSObject! !!JQTabs methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!destroy	"Removes the tabs functionality completely. This will return the element back to its pre-init state."		self action: 'destroy'! !!JQTabs methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!disable: anInteger	"=Disable a tab. The selected tab cannot be disabled. To disable more than one tab at once use: <code>$('#example').data('disabled.tabs', [1, 2, 3]);</code>  The second argument is the zero-based index of the tab to be disabled. "		self action: 'disable' arguments: (Array with: anInteger)! !!JQTabs methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!enable: anInteger	"Enable a disabled tab.  To enable more than one tab at once reset the disabled property like: <code>$('#example').data('disabled.tabs', []);</code>. The second argument is the zero-based index of the tab to be enabled."		self action: 'enable' arguments: (Array with: anInteger)! !!JQTabs methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!load: anInteger	"Reload the content of an Ajax tab programmatically. This method always loads the tab content from the remote location, even if cache is set to true. The second argument is the zero-based index of the tab to be reloaded."		self action: 'load' arguments: (Array with: anInteger)! !!JQTabs methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!refresh	"Process any tabs that were added or removed directly in the DOM and recompute the height of the tab panels. "		self action: 'refresh'! !!JQTabs methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'tabs'! !!JQTabs methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onActivate: anObject	"Triggered after a tab has been activated (after animation completes). If the tabs were previously collapsed, ui.oldTab and ui.oldPanel will be empty jQuery objects. If the tabs are collapsing, ui.newTab and ui.newPanel will be empty jQuery objects."	self optionAt: 'activate' put: anObject asFunction! !!JQTabs methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onBeforeActivate: anObject	"Triggered immediately before a tab is activated. Can be canceled to prevent the tab from activating. If the tabs are currently collapsed, ui.oldTab and ui.oldPanel will be empty jQuery objects. If the tabs are collapsing, ui.newTab and ui.newPanel will be empty jQuery objects."	self optionAt: 'beforeActivate' put: anObject asFunction! !!JQTabs methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onBeforeLoad: anObject	"Triggered when a remote tab is about to be loaded, after the beforeActivate event. Can be canceled to prevent the tab panel from loading content; though the panel will still be activated. This event is triggered just before the Ajax request is made, so modifications can be made to ui.jqXHR and ui.ajaxSettings."	self optionAt: 'beforeload' put: anObject asFunction! !!JQTabs methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onCreate: anObject	"Triggered when the tabs are created. If the tabs are collapsed, ui.tab and ui.panel will be empty jQuery objects."	self optionAt: 'create' put: anObject asFunction! !!JQTabs methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onLoad: anObject	"This event is triggered after the content of a remote tab has been loaded."	self optionAt: 'load' put: anObject asFunction! !JQWidget subclass: #JQDroppable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQDroppable comment: 'Creates new droppables on the nodeset supplied by the query.'!!JQDroppable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!accept: aSelectorOrFunction	"All draggables that match the selector will be accepted. If a function is specified, the function will be called for each draggable on the page (passed as the first argument to the function), to provide a custom filter. The function should return true if the draggable should be accepted."	self optionAt: 'accept' put: aSelectorOrFunction! !!JQDroppable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!activeClass: aString	"If specified, the class will be added to the droppable while an acceptable draggable is being dragged."	self optionAt: 'activeClass' put: aString! !!JQDroppable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!addClasses: aBoolean	"If set to false, will prevent the ui-droppable class from being added. This may be desired as a performance optimization when calling .droppable() init on many hundreds of elements."	self optionAt: 'addClasses' put: aBoolean! !!JQDroppable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!greedy: aBoolean	"If true, will prevent event propagation on nested droppables."	self optionAt: 'greedy' put: aBoolean! !!JQDroppable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!hoverClass: aString	"If specified, the class will be added to the droppable while an acceptable draggable is being hovered."	self optionAt: 'hoverClass' put: aString! !!JQDroppable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!scope: aString	"Used to group sets of draggable and droppable items, in addition to droppable's accept option. A draggable with the same scope value as a droppable will be accepted."	self optionAt: 'scope' put: aString! !!JQDroppable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!tolerance: aString	"Specifies which mode to use for testing whether a draggable is 'over' a droppable. Possible values: 'fit', 'intersect', 'pointer', 'touch'.  ''fit'': draggable overlaps the droppable entirely ''intersect'': draggable overlaps the droppable at least 50% ''pointer'': mouse pointer overlaps the droppable ''touch'': draggable overlaps the droppable any amount "	self optionAt: 'tolerance' put: aString! !!JQDroppable methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'droppable'! !!JQDroppable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onActivate: anObject	"This event is triggered any time an accepted draggable starts dragging. This can be useful if you want to make the droppable 'light up' when it can be dropped on."	self optionAt: 'activate' put: anObject asFunction! !!JQDroppable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onDeactivate: anObject	"This event is triggered any time an accepted draggable stops dragging."	self optionAt: 'deactivate' put: anObject asFunction! !!JQDroppable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onDrop: anObject	"This event is triggered when an accepted draggable is dropped 'over' (within the tolerance of) this droppable. In the callback, $(this) represents the droppable the draggable is dropped on. ui.draggable represents the draggable."	self optionAt: 'drop' put: anObject asFunction! !!JQDroppable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onOut: anObject	"This event is triggered when an accepted draggable is dragged out (within the tolerance of) this droppable."	self optionAt: 'out' put: anObject asFunction! !!JQDroppable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onOver: anObject	"This event is triggered as an accepted draggable is dragged 'over' (within the tolerance of) this droppable."	self optionAt: 'over' put: anObject asFunction! !JQBaseTheme subclass: #JQDarkHiveTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQDarkHiveTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'dark-hive'! !JQBaseTheme subclass: #JQUiDarknessTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQUiDarknessTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'ui-darkness'! !JQWidget subclass: #JQSelectable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQSelectable comment: 'Creates new selectable on the nodeset supplied by the query.'!!JQSelectable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!autoRefresh: aBoolean	"This determines whether to refresh (recalculate) the position and size of each selectee at the beginning of each select operation. If you have many many items, you may want to set this to false and call the refresh method manually."	self optionAt: 'autoRefresh' put: aBoolean! !!JQSelectable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!cancel: aSelector	"Prevents selecting if you start on elements matching the selector."	self optionAt: 'cancel' put: aSelector! !!JQSelectable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!delay: anInteger	"Time in milliseconds to define when the selecting should start. It helps preventing unwanted selections when clicking on an element."	self optionAt: 'delay' put: anInteger! !!JQSelectable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!distance: anInteger	"Tolerance, in pixels, for when selecting should start. If specified, selecting will not start until after mouse is dragged beyond distance."	self optionAt: 'distance' put: anInteger! !!JQSelectable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!filter: aSelector	"The matching child elements will be made selectees (able to be selected)."	self optionAt: 'filter' put: aSelector! !!JQSelectable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!tolerance: aString	"Possible values: 'touch', 'fit'.  ''fit'': draggable overlaps the droppable entirely ''touch'': draggable overlaps the droppable any amount "	self optionAt: 'tolerance' put: aString! !!JQSelectable methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'selectable'! !!JQSelectable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onSelected: anObject	"This event is triggered at the end of the select operation, on each element added to the selection."	self optionAt: 'selected' put: anObject asFunction! !!JQSelectable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onSelecting: anObject	"This event is triggered during the select operation, on each element added to the selection."	self optionAt: 'selecting' put: anObject asFunction! !!JQSelectable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStart: anObject	"This event is triggered at the beginning of the select operation."	self optionAt: 'start' put: anObject asFunction! !!JQSelectable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStop: anObject	"This event is triggered at the end of the select operation."	self optionAt: 'stop' put: anObject asFunction! !!JQSelectable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onUnselected: anObject	"This event is triggered at the end of the select operation, on each element removed from the selection."	self optionAt: 'unselected' put: anObject asFunction! !!JQSelectable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onUnselecting: anObject	"This event is triggered during the select operation, on each element removed from the selection."	self optionAt: 'unselecting' put: anObject asFunction! !!JQSelectable methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!refresh	"Refresh the position and size of each selectee element."		self action: 'refresh'! !JQBaseTheme subclass: #JQRedmondTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQRedmondTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'redmond'! !JQWidget subclass: #JQDatepicker	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQDatepicker comment: 'A highly configurable plugin that adds datepicker functionality to your pages. You can restrict the functionality in various ways, you can select date ranges, and you can provide the date in picker in a number of languages.'!!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!altField: aString	"The jQuery selector for another field that is to be updated with the selected date from the datepicker. Use the altFormat setting below to change the format of the date within this field. Leave as blank for no alternate field."	self optionAt: 'altField' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!altFormat: aString	"The dateFormat to be used for the altField option. This allows one date format to be shown to the user for selection purposes, while a different format is actually sent behind the scenes. For a full list of the possible formats see the [[UI/Datepicker/formatDate"	self optionAt: 'altFormat' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!appendText: aString	"The text to display after each date field, e.g. to show the required format."	self optionAt: 'appendText' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!autoSize: aBoolean	"Set to true to automatically resize the input field to accomodate dates in the current [[UI/Datepicker#option-dateFormat"	self optionAt: 'autoSize' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!buttonImage: aString	"The URL for the popup button image. If set, button text becomes the 'alt' value and is not directly displayed."	self optionAt: 'buttonImage' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!buttonImageOnly: aBoolean	"Set to true to place an image after the field to use as the trigger without it appearing on a button."	self optionAt: 'buttonImageOnly' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!buttonText: aString	"The text to display on the trigger button. Use in conjunction with 'showOn' equal to 'button' or 'both'."	self optionAt: 'buttonText' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!calculateWeek: aFunction	"A function to calculate the week of the year for a given date. The default implementation uses the ISO 8601 definition: weeks start on a Monday; the first week of the year contains the first Thursday of the year."	self optionAt: 'calculateWeek' put: aFunction! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!changeMonth: aBoolean	"Allows you to change the month by selecting from a drop-down list. You can enable this feature by setting the attribute to true."	self optionAt: 'changeMonth' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!changeYear: aBoolean	"Allows you to change the year by selecting from a drop-down list. You can enable this feature by setting the attribute to true."	self optionAt: 'changeYear' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!closeText: aString	"The text to display for the close link. This attribute is one of the regionalisation attributes. Use the showButtonPanel to display this button."	self optionAt: 'closeText' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!constrainInput: aBoolean	"True if the input field is constrained to the current date format."	self optionAt: 'constrainInput' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!currentText: aString	"The text to display for the current day link. This attribute is one of the regionalisation attributes. Use the showButtonPanel to display this button."	self optionAt: 'currentText' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!dateFormat: aString	"The format for parsed and displayed dates. This attribute is one of the regionalisation attributes. For a full list of the possible formats see the [[UI/Datepicker/formatDate"	self optionAt: 'dateFormat' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!dayNames: anArray	"The list of long day names, starting from Sunday, for use as requested via the dateFormat setting. They also appear as popup hints when hovering over the corresponding column headings. This attribute is one of the regionalisation attributes."	self optionAt: 'dayNames' put: anArray! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!dayNamesMin: anArray	"The list of minimised day names, starting from Sunday, for use as column headers within the datepicker. This attribute is one of the regionalisation attributes."	self optionAt: 'dayNamesMin' put: anArray! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!dayNamesShort: anArray	"The list of abbreviated day names, starting from Sunday, for use as requested via the dateFormat setting. This attribute is one of the regionalisation attributes."	self optionAt: 'dayNamesShort' put: anArray! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!defaultDate: aDateOrNumberOrString	"Set the date to highlight on first opening if the field is blank. Specify either an actual date via a Date object, or a number of days from today (e.g. +7) or a string of values and periods ('y' for years, 'm' for months, 'w' for weeks, 'd' for days, e.g. '+1m +7d'), or null for today."	self optionAt: 'defaultDate' put: aDateOrNumberOrString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!duration: aStringOrNumber	"Control the speed at which the datepicker appears, it may be a time in milliseconds, a string representing one of the three predefined speeds ('slow', 'normal', 'fast'), or ' for immediately."	self optionAt: 'duration' put: aStringOrNumber! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!firstDay: aNumber	"Set the first day of the week: Sunday is 0, Monday is 1, ... This attribute is one of the regionalisation attributes."	self optionAt: 'firstDay' put: aNumber! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!gotoCurrent: aBoolean	"If true, the current day link moves to the currently selected date instead of today."	self optionAt: 'gotoCurrent' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!hideIfNoPrevNext: aBoolean	"Normally the previous and next links are disabled when not applicable (see minDate/maxDate). You can hide them altogether by setting this attribute to true."	self optionAt: 'hideIfNoPrevNext' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!isRTL: aBoolean	"True if the current language is drawn from right to left. This attribute is one of the regionalisation attributes."	self optionAt: 'isRTL' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!maxDate: aDateOrNumberOrString	"Set a maximum selectable date via a Date object, or a number of days from today (e.g. +7) or a string of values and periods ('y' for years, 'm' for months, 'w' for weeks, 'd' for days, e.g. '+1m +1w'), or null for no limit."	self optionAt: 'maxDate' put: aDateOrNumberOrString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!minDate: aDateOrNumberOrString	"Set a minimum selectable date via a Date object, or a number of days from today (e.g. +7) or a string of values and periods ('y' for years, 'm' for months, 'w' for weeks, 'd' for days, e.g. '-1y -1m'), or null for no limit."	self optionAt: 'minDate' put: aDateOrNumberOrString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!monthNames: anArray	"The list of full month names, as used in the month header on each datepicker and as requested via the dateFormat setting. This attribute is one of the regionalisation attributes."	self optionAt: 'monthNames' put: anArray! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!monthNamesShort: anArray	"The list of abbreviated month names, for use as requested via the dateFormat setting. This attribute is one of the regionalisation attributes."	self optionAt: 'monthNamesShort' put: anArray! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!navigationAsDateFormat: aBoolean	"When true the formatDate function is applied to the prevText, nextText, and currentText values before display, allowing them to display the target month names for example."	self optionAt: 'navigationAsDateFormat' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!nextText: aString	"The text to display for the next month link. This attribute is one of the regionalisation attributes. With the standard ThemeRoller styling, this value is replaced by an icon."	self optionAt: 'nextText' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!numberOfMonths: aNumberOrArray	"Set how many months to show at once. The value can be a straight integer, or can be a two-element array to define the number of rows and columns to display."	self optionAt: 'numberOfMonths' put: aNumberOrArray! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!prevText: aString	"The text to display for the previous month link. This attribute is one of the regionalisation attributes. With the standard ThemeRoller styling, this value is replaced by an icon."	self optionAt: 'prevText' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!selectOtherMonths: aBoolean	"When true days in other months shown before or after the current month are selectable. This only applies if [[UI/Datepicker#option-showOtherMonths"	self optionAt: 'selectOtherMonths' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!shortYearCutoff: aStringOrNumber	"Set the cutoff year for determining the century for a date (used in conjunction with dateFormat 'y'). If a numeric value (0-99) is provided then this value is used directly. If a string value is provided then it is converted to a number and added to the current year. Once the cutoff year is calculated, any dates entered with a year value less than or equal to it are considered to be in the current century, while those greater than it are deemed to be in the previous century."	self optionAt: 'shortYearCutoff' put: aStringOrNumber! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!showAnim: aString	"Set the name of the animation used to show/hide the datepicker. Use 'show' (the default), 'slideDown', 'fadeIn', or any of the show/hide [http://docs.jquery.com/UI/Effects jQuery UI effects]."	self optionAt: 'showAnim' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!showButtonPanel: aBoolean	"Whether to show the button panel."	self optionAt: 'showButtonPanel' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!showCurrentAtPos: aNumber	"Specify where in a multi-month display the current month shows, starting from 0 at the top/left."	self optionAt: 'showCurrentAtPos' put: aNumber! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!showMonthAfterYear: aBoolean	"Whether to show the month after the year in the header."	self optionAt: 'showMonthAfterYear' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!showOn: aString	"Have the datepicker appear automatically when the field receives focus ('focus'), appear only when a button is clicked ('button'), or appear when either event takes place ('both')."	self optionAt: 'showOn' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!showOptions: anOptions	"If using one of the jQuery UI effects for showAnim, you can provide additional settings for that animation via this option."	self optionAt: 'showOptions' put: anOptions! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!showOtherMonths: aBoolean	"Display dates in other months (non-selectable) at the start or end of the current month."	self optionAt: 'showOtherMonths' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!showWeek: aBoolean	"When true a column is added to show the week of the year."	self optionAt: 'showWeek' put: aBoolean! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!stepMonths: aNumber	"Set how many months to move when clicking the Previous/Next links."	self optionAt: 'stepMonths' put: aNumber! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!weekHeader: aString	"The text to display for the week of the year column heading. This attribute is one of the regionalisation attributes."	self optionAt: 'weekHeader' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!yearRange: aString	"Control the range of years displayed in the year drop-down: either relative to current year (-nn:+nn) or absolute (nnnn:nnnn)."	self optionAt: 'yearRange' put: aString! !!JQDatepicker methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!yearSuffix: aString	"Additional text to display after the year in the month headers. This attribute is one of the regionalisation attributes."	self optionAt: 'yearSuffix' put: aString! !!JQDatepicker methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!getDate	"Get the current date for a date picker."		self action: 'getDate'! !!JQDatepicker methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!hide	"Close a previously opened date picker."		self action: 'hide'! !!JQDatepicker methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!isDisabled	"Determine whether a date picker has been disabled."		self action: 'isDisabled'! !!JQDatepicker methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!setDate: aDate	"Set the current date for a date picker."		self action: 'setDate' arguments: (Array with: aDate)! !!JQDatepicker methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!show	"Call up a previously attached date picker."		self action: 'show'! !!JQDatepicker methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'datepicker'! !!JQDatepicker methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onBeforeShow: anObject	"Can be a function that takes an input field and current datepicker instance and returns an options object to update the datepicker with. It is called just before the datepicker is displayed."	self optionAt: 'beforeShow' put: anObject asFunction! !!JQDatepicker methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onBeforeShowDay: anObject	"The function takes a date as a parameter and must return an array with [0] equal to true/false indicating whether or not this date is selectable, [1] equal to a CSS class name(s) or ' for the default presentation, and [2] an optional popup tooltip for this date. It is called for each day in the datepicker before it is displayed."	self optionAt: 'beforeShowDay' put: anObject asFunction! !!JQDatepicker methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onChangeMonthYear: anObject	"Allows you to define your own event when the datepicker moves to a new month and/or year. The function receives the selected year, month (1-12), and the datepicker instance as parameters. this refers to the associated input field."	self optionAt: 'onChangeMonthYear' put: anObject asFunction! !!JQDatepicker methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onClose: anObject	"Allows you to define your own event when the datepicker is closed, whether or not a date is selected. The function receives the selected date as text (' if none) and the datepicker instance as parameters. this refers to the associated input field."	self optionAt: 'onClose' put: anObject asFunction! !!JQDatepicker methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onSelect: anObject	"Allows you to define your own event when the datepicker is selected. The function receives the selected date as text and the datepicker instance as parameters. this refers to the associated input field."	self optionAt: 'onSelect' put: anObject asFunction! !!JQDatepicker methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onUpdateDatePicker: anObject	"Called when the datepicker widget's DOM is updated. The function receives the datepicker instance as the only parameter. this refers to the associated input field."	self optionAt: 'onUpdateDatepicker' put: anObject asFunction! !JQBaseTheme subclass: #JQFlickTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQFlickTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'flick'! !WAFileLibrary subclass: #JQUiDevelopmentLibrary	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQUiDevelopmentLibrary methodsFor: 'uploaded' stamp: '1/8/2026 11:26:12'!jQueryUiJs	<ignoreForCoverage>	^ '/*!! jQuery UI - v1.13.2 - 2022-07-14* http://jqueryui.com* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-patch.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js* Copyright jQuery Foundation and other contributors; Licensed MIT */( function( factory ) {	"use strict";		if ( typeof define === "function" && define.amd ) {		// AMD. Register as an anonymous module.		define( [ "jquery" ], factory );	} else {		// Browser globals		factory( jQuery );	}} )( function( $ ) {"use strict";$.ui = $.ui || {};var version = $.ui.version = "1.13.2";/*!! * jQuery UI Widget 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Widget//>>group: Core//>>description: Provides a factory for creating stateful widgets with a common API.//>>docs: http://api.jqueryui.com/jQuery.widget///>>demos: http://jqueryui.com/widget/var widgetUuid = 0;var widgetHasOwnProperty = Array.prototype.hasOwnProperty;var widgetSlice = Array.prototype.slice;$.cleanData = ( function( orig ) {	return function( elems ) {		var events, elem, i;		for ( i = 0; ( elem = elems[ i ] ) !!= null; i++ ) {			// Only trigger remove when necessary to save time			events = $._data( elem, "events" );			if ( events && events.remove ) {				$( elem ).triggerHandler( "remove" );			}		}		orig( elems );	};} )( $.cleanData );$.widget = function( name, base, prototype ) {	var existingConstructor, constructor, basePrototype;	// ProxiedPrototype allows the provided prototype to remain unmodified	// so that it can be used as a mixin for multiple widgets (#8876)	var proxiedPrototype = {};	var namespace = name.split( "." )[ 0 ];	name = name.split( "." )[ 1 ];	var fullName = namespace + "-" + name;	if ( !!prototype ) {		prototype = base;		base = $.Widget;	}	if ( Array.isArray( prototype ) ) {		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );	}	// Create selector for plugin	$.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {		return !!!!$.data( elem, fullName );	};	$[ namespace ] = $[ namespace ] || {};	existingConstructor = $[ namespace ][ name ];	constructor = $[ namespace ][ name ] = function( options, element ) {		// Allow instantiation without "new" keyword		if ( !!this || !!this._createWidget ) {			return new constructor( options, element );		}		// Allow instantiation without initializing for simple inheritance		// must use "new" keyword (the code above always passes args)		if ( arguments.length ) {			this._createWidget( options, element );		}	};	// Extend with the existing constructor to carry over any static properties	$.extend( constructor, existingConstructor, {		version: prototype.version,		// Copy the object used to create the prototype in case we need to		// redefine the widget later		_proto: $.extend( {}, prototype ),		// Track widgets that inherit from this widget in case this widget is		// redefined after a widget inherits from it		_childConstructors: []	} );	basePrototype = new base();	// We need to make the options hash a property directly on the new instance	// otherwise we''ll modify the options hash on the prototype that we''re	// inheriting from	basePrototype.options = $.widget.extend( {}, basePrototype.options );	$.each( prototype, function( prop, value ) {		if ( typeof value !!== "function" ) {			proxiedPrototype[ prop ] = value;			return;		}		proxiedPrototype[ prop ] = ( function() {			function _super() {				return base.prototype[ prop ].apply( this, arguments );			}			function _superApply( args ) {				return base.prototype[ prop ].apply( this, args );			}			return function() {				var __super = this._super;				var __superApply = this._superApply;				var returnValue;				this._super = _super;				this._superApply = _superApply;				returnValue = value.apply( this, arguments );				this._super = __super;				this._superApply = __superApply;				return returnValue;			};		} )();	} );	constructor.prototype = $.widget.extend( basePrototype, {		// TODO: remove support for widgetEventPrefix		// always use the name + a colon as the prefix, e.g., draggable:start		// don''t prefix for widgets that aren''t DOM-based		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name	}, proxiedPrototype, {		constructor: constructor,		namespace: namespace,		widgetName: name,		widgetFullName: fullName	} );	// If this widget is being redefined then we need to find all widgets that	// are inheriting from it and redefine all of them so that they inherit from	// the new version of this widget. We''re essentially trying to replace one	// level in the prototype chain.	if ( existingConstructor ) {		$.each( existingConstructor._childConstructors, function( i, child ) {			var childPrototype = child.prototype;			// Redefine the child widget using the same prototype that was			// originally used, but inherit from the new version of the base			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,				child._proto );		} );		// Remove the list of existing child constructors from the old constructor		// so the old child constructors can be garbage collected		delete existingConstructor._childConstructors;	} else {		base._childConstructors.push( constructor );	}	$.widget.bridge( name, constructor );	return constructor;};$.widget.extend = function( target ) {	var input = widgetSlice.call( arguments, 1 );	var inputIndex = 0;	var inputLength = input.length;	var key;	var value;	for ( ; inputIndex < inputLength; inputIndex++ ) {		for ( key in input[ inputIndex ] ) {			value = input[ inputIndex ][ key ];			if ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !!== undefined ) {				// Clone objects				if ( $.isPlainObject( value ) ) {					target[ key ] = $.isPlainObject( target[ key ] ) ?						$.widget.extend( {}, target[ key ], value ) :						// Don''t extend strings, arrays, etc. with objects						$.widget.extend( {}, value );				// Copy everything else by reference				} else {					target[ key ] = value;				}			}		}	}	return target;};$.widget.bridge = function( name, object ) {	var fullName = object.prototype.widgetFullName || name;	$.fn[ name ] = function( options ) {		var isMethodCall = typeof options === "string";		var args = widgetSlice.call( arguments, 1 );		var returnValue = this;		if ( isMethodCall ) {			// If this is an empty collection, we need to have the instance method			// return undefined instead of the jQuery instance			if ( !!this.length && options === "instance" ) {				returnValue = undefined;			} else {				this.each( function() {					var methodValue;					var instance = $.data( this, fullName );					if ( options === "instance" ) {						returnValue = instance;						return false;					}					if ( !!instance ) {						return $.error( "cannot call methods on " + name +							" prior to initialization; " +							"attempted to call method ''" + options + "''" );					}					if ( typeof instance[ options ] !!== "function" ||						options.charAt( 0 ) === "_" ) {						return $.error( "no such method ''" + options + "'' for " + name +							" widget instance" );					}					methodValue = instance[ options ].apply( instance, args );					if ( methodValue !!== instance && methodValue !!== undefined ) {						returnValue = methodValue && methodValue.jquery ?							returnValue.pushStack( methodValue.get() ) :							methodValue;						return false;					}				} );			}		} else {			// Allow multiple hashes to be passed on init			if ( args.length ) {				options = $.widget.extend.apply( null, [ options ].concat( args ) );			}			this.each( function() {				var instance = $.data( this, fullName );				if ( instance ) {					instance.option( options || {} );					if ( instance._init ) {						instance._init();					}				} else {					$.data( this, fullName, new object( options, this ) );				}			} );		}		return returnValue;	};};$.Widget = function( /* options, element */ ) {};$.Widget._childConstructors = [];$.Widget.prototype = {	widgetName: "widget",	widgetEventPrefix: "",	defaultElement: "<div>",	options: {		classes: {},		disabled: false,		// Callbacks		create: null	},	_createWidget: function( options, element ) {		element = $( element || this.defaultElement || this )[ 0 ];		this.element = $( element );		this.uuid = widgetUuid++;		this.eventNamespace = "." + this.widgetName + this.uuid;		this.bindings = $();		this.hoverable = $();		this.focusable = $();		this.classesElementLookup = {};		if ( element !!== this ) {			$.data( element, this.widgetFullName, this );			this._on( true, this.element, {				remove: function( event ) {					if ( event.target === element ) {						this.destroy();					}				}			} );			this.document = $( element.style ?				// Element within the document				element.ownerDocument :				// Element is window or document				element.document || element );			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );		}		this.options = $.widget.extend( {},			this.options,			this._getCreateOptions(),			options );		this._create();		if ( this.options.disabled ) {			this._setOptionDisabled( this.options.disabled );		}		this._trigger( "create", null, this._getCreateEventData() );		this._init();	},	_getCreateOptions: function() {		return {};	},	_getCreateEventData: $.noop,	_create: $.noop,	_init: $.noop,	destroy: function() {		var that = this;		this._destroy();		$.each( this.classesElementLookup, function( key, value ) {			that._removeClass( value, key );		} );		// We can probably remove the unbind calls in 2.0		// all event bindings should go through this._on()		this.element			.off( this.eventNamespace )			.removeData( this.widgetFullName );		this.widget()			.off( this.eventNamespace )			.removeAttr( "aria-disabled" );		// Clean up events and states		this.bindings.off( this.eventNamespace );	},	_destroy: $.noop,	widget: function() {		return this.element;	},	option: function( key, value ) {		var options = key;		var parts;		var curOption;		var i;		if ( arguments.length === 0 ) {			// Don''t return a reference to the internal hash			return $.widget.extend( {}, this.options );		}		if ( typeof key === "string" ) {			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }			options = {};			parts = key.split( "." );			key = parts.shift();			if ( parts.length ) {				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );				for ( i = 0; i < parts.length - 1; i++ ) {					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};					curOption = curOption[ parts[ i ] ];				}				key = parts.pop();				if ( arguments.length === 1 ) {					return curOption[ key ] === undefined ? null : curOption[ key ];				}				curOption[ key ] = value;			} else {				if ( arguments.length === 1 ) {					return this.options[ key ] === undefined ? null : this.options[ key ];				}				options[ key ] = value;			}		}		this._setOptions( options );		return this;	},	_setOptions: function( options ) {		var key;		for ( key in options ) {			this._setOption( key, options[ key ] );		}		return this;	},	_setOption: function( key, value ) {		if ( key === "classes" ) {			this._setOptionClasses( value );		}		this.options[ key ] = value;		if ( key === "disabled" ) {			this._setOptionDisabled( value );		}		return this;	},	_setOptionClasses: function( value ) {		var classKey, elements, currentElements;		for ( classKey in value ) {			currentElements = this.classesElementLookup[ classKey ];			if ( value[ classKey ] === this.options.classes[ classKey ] ||					!!currentElements ||					!!currentElements.length ) {				continue;			}			// We are doing this to create a new jQuery object because the _removeClass() call			// on the next line is going to destroy the reference to the current elements being			// tracked. We need to save a copy of this collection so that we can add the new classes			// below.			elements = $( currentElements.get() );			this._removeClass( currentElements, classKey );			// We don''t use _addClass() here, because that uses this.options.classes			// for generating the string of classes. We want to use the value passed in from			// _setOption(), this is the new value of the classes option which was passed to			// _setOption(). We pass this value directly to _classes().			elements.addClass( this._classes( {				element: elements,				keys: classKey,				classes: value,				add: true			} ) );		}	},	_setOptionDisabled: function( value ) {		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!!!value );		// If the widget is becoming disabled, then nothing is interactive		if ( value ) {			this._removeClass( this.hoverable, null, "ui-state-hover" );			this._removeClass( this.focusable, null, "ui-state-focus" );		}	},	enable: function() {		return this._setOptions( { disabled: false } );	},	disable: function() {		return this._setOptions( { disabled: true } );	},	_classes: function( options ) {		var full = [];		var that = this;		options = $.extend( {			element: this.element,			classes: this.options.classes || {}		}, options );		function bindRemoveEvent() {			var nodesToBind = [];			options.element.each( function( _, element ) {				var isTracked = $.map( that.classesElementLookup, function( elements ) {					return elements;				} )					.some( function( elements ) {						return elements.is( element );					} );				if ( !!isTracked ) {					nodesToBind.push( element );				}			} );			that._on( $( nodesToBind ), {				remove: "_untrackClassesElement"			} );		}		function processClassString( classes, checkOption ) {			var current, i;			for ( i = 0; i < classes.length; i++ ) {				current = that.classesElementLookup[ classes[ i ] ] || $();				if ( options.add ) {					bindRemoveEvent();					current = $( $.uniqueSort( current.get().concat( options.element.get() ) ) );				} else {					current = $( current.not( options.element ).get() );				}				that.classesElementLookup[ classes[ i ] ] = current;				full.push( classes[ i ] );				if ( checkOption && options.classes[ classes[ i ] ] ) {					full.push( options.classes[ classes[ i ] ] );				}			}		}		if ( options.keys ) {			processClassString( options.keys.match( /\S+/g ) || [], true );		}		if ( options.extra ) {			processClassString( options.extra.match( /\S+/g ) || [] );		}		return full.join( " " );	},	_untrackClassesElement: function( event ) {		var that = this;		$.each( that.classesElementLookup, function( key, value ) {			if ( $.inArray( event.target, value ) !!== -1 ) {				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );			}		} );		this._off( $( event.target ) );	},	_removeClass: function( element, keys, extra ) {		return this._toggleClass( element, keys, extra, false );	},	_addClass: function( element, keys, extra ) {		return this._toggleClass( element, keys, extra, true );	},	_toggleClass: function( element, keys, extra, add ) {		add = ( typeof add === "boolean" ) ? add : extra;		var shift = ( typeof element === "string" || element === null ),			options = {				extra: shift ? keys : extra,				keys: shift ? element : keys,				element: shift ? this.element : element,				add: add			};		options.element.toggleClass( this._classes( options ), add );		return this;	},	_on: function( suppressDisabledCheck, element, handlers ) {		var delegateElement;		var instance = this;		// No suppressDisabledCheck flag, shuffle arguments		if ( typeof suppressDisabledCheck !!== "boolean" ) {			handlers = element;			element = suppressDisabledCheck;			suppressDisabledCheck = false;		}		// No element argument, shuffle and use this.element		if ( !!handlers ) {			handlers = element;			element = this.element;			delegateElement = this.widget();		} else {			element = delegateElement = $( element );			this.bindings = this.bindings.add( element );		}		$.each( handlers, function( event, handler ) {			function handlerProxy() {				// Allow widgets to customize the disabled handling				// - disabled as an array instead of boolean				// - disabled class as method for disabling individual parts				if ( !!suppressDisabledCheck &&						( instance.options.disabled === true ||						$( this ).hasClass( "ui-state-disabled" ) ) ) {					return;				}				return ( typeof handler === "string" ? instance[ handler ] : handler )					.apply( instance, arguments );			}			// Copy the guid so direct unbinding works			if ( typeof handler !!== "string" ) {				handlerProxy.guid = handler.guid =					handler.guid || handlerProxy.guid || $.guid++;			}			var match = event.match( /^([\w:-]*)\s*(.*)$/ );			var eventName = match[ 1 ] + instance.eventNamespace;			var selector = match[ 2 ];			if ( selector ) {				delegateElement.on( eventName, selector, handlerProxy );			} else {				element.on( eventName, handlerProxy );			}		} );	},	_off: function( element, eventName ) {		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +			this.eventNamespace;		element.off( eventName );		// Clear the stack to avoid memory leaks (#10056)		this.bindings = $( this.bindings.not( element ).get() );		this.focusable = $( this.focusable.not( element ).get() );		this.hoverable = $( this.hoverable.not( element ).get() );	},	_delay: function( handler, delay ) {		function handlerProxy() {			return ( typeof handler === "string" ? instance[ handler ] : handler )				.apply( instance, arguments );		}		var instance = this;		return setTimeout( handlerProxy, delay || 0 );	},	_hoverable: function( element ) {		this.hoverable = this.hoverable.add( element );		this._on( element, {			mouseenter: function( event ) {				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );			},			mouseleave: function( event ) {				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );			}		} );	},	_focusable: function( element ) {		this.focusable = this.focusable.add( element );		this._on( element, {			focusin: function( event ) {				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );			},			focusout: function( event ) {				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );			}		} );	},	_trigger: function( type, event, data ) {		var prop, orig;		var callback = this.options[ type ];		data = data || {};		event = $.Event( event );		event.type = ( type === this.widgetEventPrefix ?			type :			this.widgetEventPrefix + type ).toLowerCase();		// The original event may come from any element		// so we need to reset the target on the new event		event.target = this.element[ 0 ];		// Copy original event properties over to the new event		orig = event.originalEvent;		if ( orig ) {			for ( prop in orig ) {				if ( !!( prop in event ) ) {					event[ prop ] = orig[ prop ];				}			}		}		this.element.trigger( event, data );		return !!( typeof callback === "function" &&			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||			event.isDefaultPrevented() );	}};$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {		if ( typeof options === "string" ) {			options = { effect: options };		}		var hasOptions;		var effectName = !!options ?			method :			options === true || typeof options === "number" ?				defaultEffect :				options.effect || defaultEffect;		options = options || {};		if ( typeof options === "number" ) {			options = { duration: options };		} else if ( options === true ) {			options = {};		}		hasOptions = !!$.isEmptyObject( options );		options.complete = callback;		if ( options.delay ) {			element.delay( options.delay );		}		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {			element[ method ]( options );		} else if ( effectName !!== method && element[ effectName ] ) {			element[ effectName ]( options.duration, options.easing, callback );		} else {			element.queue( function( next ) {				$( this )[ method ]();				if ( callback ) {					callback.call( element[ 0 ] );				}				next();			} );		}	};} );var widget = $.widget;/*!! * jQuery UI Position 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license * * http://api.jqueryui.com/position/ *///>>label: Position//>>group: Core//>>description: Positions elements relative to other elements.//>>docs: http://api.jqueryui.com/position///>>demos: http://jqueryui.com/position/( function() {var cachedScrollbarWidth,	max = Math.max,	abs = Math.abs,	rhorizontal = /left|center|right/,	rvertical = /top|center|bottom/,	roffset = /[\+\-]\d+(\.[\d]+)?%?/,	rposition = /^\w+/,	rpercent = /%$/,	_position = $.fn.position;function getOffsets( offsets, width, height ) {	return [		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )	];}function parseCss( element, property ) {	return parseInt( $.css( element, property ), 10 ) || 0;}function isWindow( obj ) {	return obj !!= null && obj === obj.window;}function getDimensions( elem ) {	var raw = elem[ 0 ];	if ( raw.nodeType === 9 ) {		return {			width: elem.width(),			height: elem.height(),			offset: { top: 0, left: 0 }		};	}	if ( isWindow( raw ) ) {		return {			width: elem.width(),			height: elem.height(),			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }		};	}	if ( raw.preventDefault ) {		return {			width: 0,			height: 0,			offset: { top: raw.pageY, left: raw.pageX }		};	}	return {		width: elem.outerWidth(),		height: elem.outerHeight(),		offset: elem.offset()	};}$.position = {	scrollbarWidth: function() {		if ( cachedScrollbarWidth !!== undefined ) {			return cachedScrollbarWidth;		}		var w1, w2,			div = $( "<div style=" +				"''display:block;position:absolute;width:200px;height:200px;overflow:hidden;''>" +				"<div style=''height:300px;width:auto;''></div></div>" ),			innerDiv = div.children()[ 0 ];		$( "body" ).append( div );		w1 = innerDiv.offsetWidth;		div.css( "overflow", "scroll" );		w2 = innerDiv.offsetWidth;		if ( w1 === w2 ) {			w2 = div[ 0 ].clientWidth;		}		div.remove();		return ( cachedScrollbarWidth = w1 - w2 );	},	getScrollInfo: function( within ) {		var overflowX = within.isWindow || within.isDocument ? "" :				within.element.css( "overflow-x" ),			overflowY = within.isWindow || within.isDocument ? "" :				within.element.css( "overflow-y" ),			hasOverflowX = overflowX === "scroll" ||				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),			hasOverflowY = overflowY === "scroll" ||				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );		return {			width: hasOverflowY ? $.position.scrollbarWidth() : 0,			height: hasOverflowX ? $.position.scrollbarWidth() : 0		};	},	getWithinInfo: function( element ) {		var withinElement = $( element || window ),			isElemWindow = isWindow( withinElement[ 0 ] ),			isDocument = !!!!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,			hasOffset = !!isElemWindow && !!isDocument;		return {			element: withinElement,			isWindow: isElemWindow,			isDocument: isDocument,			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },			scrollLeft: withinElement.scrollLeft(),			scrollTop: withinElement.scrollTop(),			width: withinElement.outerWidth(),			height: withinElement.outerHeight()		};	}};$.fn.position = function( options ) {	if ( !!options || !!options.of ) {		return _position.apply( this, arguments );	}	// Make a copy, we don''t want to modify arguments	options = $.extend( {}, options );	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,		// Make sure string options are treated as CSS selectors		target = typeof options.of === "string" ?			$( document ).find( options.of ) :			$( options.of ),		within = $.position.getWithinInfo( options.within ),		scrollInfo = $.position.getScrollInfo( within ),		collision = ( options.collision || "flip" ).split( " " ),		offsets = {};	dimensions = getDimensions( target );	if ( target[ 0 ].preventDefault ) {		// Force left top to allow flipping		options.at = "left top";	}	targetWidth = dimensions.width;	targetHeight = dimensions.height;	targetOffset = dimensions.offset;	// Clone to reuse original targetOffset later	basePosition = $.extend( {}, targetOffset );	// Force my and at to have valid horizontal and vertical positions	// if a value is missing or invalid, it will be converted to center	$.each( [ "my", "at" ], function() {		var pos = ( options[ this ] || "" ).split( " " ),			horizontalOffset,			verticalOffset;		if ( pos.length === 1 ) {			pos = rhorizontal.test( pos[ 0 ] ) ?				pos.concat( [ "center" ] ) :				rvertical.test( pos[ 0 ] ) ?					[ "center" ].concat( pos ) :					[ "center", "center" ];		}		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";		// Calculate offsets		horizontalOffset = roffset.exec( pos[ 0 ] );		verticalOffset = roffset.exec( pos[ 1 ] );		offsets[ this ] = [			horizontalOffset ? horizontalOffset[ 0 ] : 0,			verticalOffset ? verticalOffset[ 0 ] : 0		];		// Reduce to just the positions without the offsets		options[ this ] = [			rposition.exec( pos[ 0 ] )[ 0 ],			rposition.exec( pos[ 1 ] )[ 0 ]		];	} );	// Normalize collision option	if ( collision.length === 1 ) {		collision[ 1 ] = collision[ 0 ];	}	if ( options.at[ 0 ] === "right" ) {		basePosition.left += targetWidth;	} else if ( options.at[ 0 ] === "center" ) {		basePosition.left += targetWidth / 2;	}	if ( options.at[ 1 ] === "bottom" ) {		basePosition.top += targetHeight;	} else if ( options.at[ 1 ] === "center" ) {		basePosition.top += targetHeight / 2;	}	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );	basePosition.left += atOffset[ 0 ];	basePosition.top += atOffset[ 1 ];	return this.each( function() {		var collisionPosition, using,			elem = $( this ),			elemWidth = elem.outerWidth(),			elemHeight = elem.outerHeight(),			marginLeft = parseCss( this, "marginLeft" ),			marginTop = parseCss( this, "marginTop" ),			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +				scrollInfo.width,			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +				scrollInfo.height,			position = $.extend( {}, basePosition ),			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );		if ( options.my[ 0 ] === "right" ) {			position.left -= elemWidth;		} else if ( options.my[ 0 ] === "center" ) {			position.left -= elemWidth / 2;		}		if ( options.my[ 1 ] === "bottom" ) {			position.top -= elemHeight;		} else if ( options.my[ 1 ] === "center" ) {			position.top -= elemHeight / 2;		}		position.left += myOffset[ 0 ];		position.top += myOffset[ 1 ];		collisionPosition = {			marginLeft: marginLeft,			marginTop: marginTop		};		$.each( [ "left", "top" ], function( i, dir ) {			if ( $.ui.position[ collision[ i ] ] ) {				$.ui.position[ collision[ i ] ][ dir ]( position, {					targetWidth: targetWidth,					targetHeight: targetHeight,					elemWidth: elemWidth,					elemHeight: elemHeight,					collisionPosition: collisionPosition,					collisionWidth: collisionWidth,					collisionHeight: collisionHeight,					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],					my: options.my,					at: options.at,					within: within,					elem: elem				} );			}		} );		if ( options.using ) {			// Adds feedback as second argument to using callback, if present			using = function( props ) {				var left = targetOffset.left - position.left,					right = left + targetWidth - elemWidth,					top = targetOffset.top - position.top,					bottom = top + targetHeight - elemHeight,					feedback = {						target: {							element: target,							left: targetOffset.left,							top: targetOffset.top,							width: targetWidth,							height: targetHeight						},						element: {							element: elem,							left: position.left,							top: position.top,							width: elemWidth,							height: elemHeight						},						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"					};				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {					feedback.horizontal = "center";				}				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {					feedback.vertical = "middle";				}				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {					feedback.important = "horizontal";				} else {					feedback.important = "vertical";				}				options.using.call( this, props, feedback );			};		}		elem.offset( $.extend( position, { using: using } ) );	} );};$.ui.position = {	fit: {		left: function( position, data ) {			var within = data.within,				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,				outerWidth = within.width,				collisionPosLeft = position.left - data.collisionPosition.marginLeft,				overLeft = withinOffset - collisionPosLeft,				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,				newOverRight;			// Element is wider than within			if ( data.collisionWidth > outerWidth ) {				// Element is initially over the left side of within				if ( overLeft > 0 && overRight <= 0 ) {					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -						withinOffset;					position.left += overLeft - newOverRight;				// Element is initially over right side of within				} else if ( overRight > 0 && overLeft <= 0 ) {					position.left = withinOffset;				// Element is initially over both left and right sides of within				} else {					if ( overLeft > overRight ) {						position.left = withinOffset + outerWidth - data.collisionWidth;					} else {						position.left = withinOffset;					}				}			// Too far left -> align with left edge			} else if ( overLeft > 0 ) {				position.left += overLeft;			// Too far right -> align with right edge			} else if ( overRight > 0 ) {				position.left -= overRight;			// Adjust based on position and margin			} else {				position.left = max( position.left - collisionPosLeft, position.left );			}		},		top: function( position, data ) {			var within = data.within,				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,				outerHeight = data.within.height,				collisionPosTop = position.top - data.collisionPosition.marginTop,				overTop = withinOffset - collisionPosTop,				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,				newOverBottom;			// Element is taller than within			if ( data.collisionHeight > outerHeight ) {				// Element is initially over the top of within				if ( overTop > 0 && overBottom <= 0 ) {					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -						withinOffset;					position.top += overTop - newOverBottom;				// Element is initially over bottom of within				} else if ( overBottom > 0 && overTop <= 0 ) {					position.top = withinOffset;				// Element is initially over both top and bottom of within				} else {					if ( overTop > overBottom ) {						position.top = withinOffset + outerHeight - data.collisionHeight;					} else {						position.top = withinOffset;					}				}			// Too far up -> align with top			} else if ( overTop > 0 ) {				position.top += overTop;			// Too far down -> align with bottom edge			} else if ( overBottom > 0 ) {				position.top -= overBottom;			// Adjust based on position and margin			} else {				position.top = max( position.top - collisionPosTop, position.top );			}		}	},	flip: {		left: function( position, data ) {			var within = data.within,				withinOffset = within.offset.left + within.scrollLeft,				outerWidth = within.width,				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,				collisionPosLeft = position.left - data.collisionPosition.marginLeft,				overLeft = collisionPosLeft - offsetLeft,				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,				myOffset = data.my[ 0 ] === "left" ?					-data.elemWidth :					data.my[ 0 ] === "right" ?						data.elemWidth :						0,				atOffset = data.at[ 0 ] === "left" ?					data.targetWidth :					data.at[ 0 ] === "right" ?						-data.targetWidth :						0,				offset = -2 * data.offset[ 0 ],				newOverRight,				newOverLeft;			if ( overLeft < 0 ) {				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -					outerWidth - withinOffset;				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {					position.left += myOffset + atOffset + offset;				}			} else if ( overRight > 0 ) {				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +					atOffset + offset - offsetLeft;				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {					position.left += myOffset + atOffset + offset;				}			}		},		top: function( position, data ) {			var within = data.within,				withinOffset = within.offset.top + within.scrollTop,				outerHeight = within.height,				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,				collisionPosTop = position.top - data.collisionPosition.marginTop,				overTop = collisionPosTop - offsetTop,				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,				top = data.my[ 1 ] === "top",				myOffset = top ?					-data.elemHeight :					data.my[ 1 ] === "bottom" ?						data.elemHeight :						0,				atOffset = data.at[ 1 ] === "top" ?					data.targetHeight :					data.at[ 1 ] === "bottom" ?						-data.targetHeight :						0,				offset = -2 * data.offset[ 1 ],				newOverTop,				newOverBottom;			if ( overTop < 0 ) {				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -					outerHeight - withinOffset;				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {					position.top += myOffset + atOffset + offset;				}			} else if ( overBottom > 0 ) {				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +					offset - offsetTop;				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {					position.top += myOffset + atOffset + offset;				}			}		}	},	flipfit: {		left: function() {			$.ui.position.flip.left.apply( this, arguments );			$.ui.position.fit.left.apply( this, arguments );		},		top: function() {			$.ui.position.flip.top.apply( this, arguments );			$.ui.position.fit.top.apply( this, arguments );		}	}};} )();var position = $.ui.position;/*!! * jQuery UI :data 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: :data Selector//>>group: Core//>>description: Selects elements which have data stored under the specified key.//>>docs: http://api.jqueryui.com/data-selector/var data = $.extend( $.expr.pseudos, {	data: $.expr.createPseudo ?		$.expr.createPseudo( function( dataName ) {			return function( elem ) {				return !!!!$.data( elem, dataName );			};		} ) :		// Support: jQuery <1.8		function( elem, i, match ) {			return !!!!$.data( elem, match[ 3 ] );		}} );/*!! * jQuery UI Disable Selection 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: disableSelection//>>group: Core//>>description: Disable selection of text content within the set of matched elements.//>>docs: http://api.jqueryui.com/disableSelection/// This file is deprecatedvar disableSelection = $.fn.extend( {	disableSelection: ( function() {		var eventType = "onselectstart" in document.createElement( "div" ) ?			"selectstart" :			"mousedown";		return function() {			return this.on( eventType + ".ui-disableSelection", function( event ) {				event.preventDefault();			} );		};	} )(),	enableSelection: function() {		return this.off( ".ui-disableSelection" );	}} );// Create a local jQuery because jQuery Color relies on it and the// global may not exist with AMD and a custom build (#10199).// This module is a noop if used as a regular AMD module.// eslint-disable-next-line no-unused-varsvar jQuery = $;/*!! * jQuery Color Animations v2.2.0 * https://github.com/jquery/jquery-color * * Copyright OpenJS Foundation and other contributors * Released under the MIT license. * http://jquery.org/license * * Date: Sun May 10 09:02:36 2020 +0200 */	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +		"borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",	class2type = {},	toString = class2type.toString,	// plusequals test for += 100 -= 100	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,	// a set of RE''s that can match strings and generate color tuples.	stringParsers = [ {			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,			parse: function( execResult ) {				return [					execResult[ 1 ],					execResult[ 2 ],					execResult[ 3 ],					execResult[ 4 ]				];			}		}, {			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,			parse: function( execResult ) {				return [					execResult[ 1 ] * 2.55,					execResult[ 2 ] * 2.55,					execResult[ 3 ] * 2.55,					execResult[ 4 ]				];			}		}, {			// this regex ignores A-F because it''s compared against an already lowercased string			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?/,			parse: function( execResult ) {				return [					parseInt( execResult[ 1 ], 16 ),					parseInt( execResult[ 2 ], 16 ),					parseInt( execResult[ 3 ], 16 ),					execResult[ 4 ] ?						( parseInt( execResult[ 4 ], 16 ) / 255 ).toFixed( 2 ) :						1				];			}		}, {			// this regex ignores A-F because it''s compared against an already lowercased string			re: /#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?/,			parse: function( execResult ) {				return [					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 ),					execResult[ 4 ] ?						( parseInt( execResult[ 4 ] + execResult[ 4 ], 16 ) / 255 )							.toFixed( 2 ) :						1				];			}		}, {			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,			space: "hsla",			parse: function( execResult ) {				return [					execResult[ 1 ],					execResult[ 2 ] / 100,					execResult[ 3 ] / 100,					execResult[ 4 ]				];			}		} ],	// jQuery.Color( )	color = jQuery.Color = function( color, green, blue, alpha ) {		return new jQuery.Color.fn.parse( color, green, blue, alpha );	},	spaces = {		rgba: {			props: {				red: {					idx: 0,					type: "byte"				},				green: {					idx: 1,					type: "byte"				},				blue: {					idx: 2,					type: "byte"				}			}		},		hsla: {			props: {				hue: {					idx: 0,					type: "degrees"				},				saturation: {					idx: 1,					type: "percent"				},				lightness: {					idx: 2,					type: "percent"				}			}		}	},	propTypes = {		"byte": {			floor: true,			max: 255		},		"percent": {			max: 1		},		"degrees": {			mod: 360,			floor: true		}	},	support = color.support = {},	// element for support tests	supportElem = jQuery( "<p>" )[ 0 ],	// colors = jQuery.Color.names	colors,	// local aliases of functions called often	each = jQuery.each;// determine rgba support immediatelysupportElem.style.cssText = "background-color:rgba(1,1,1,.5)";support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;// define cache name and alpha properties// for rgba and hsla spaceseach( spaces, function( spaceName, space ) {	space.cache = "_" + spaceName;	space.props.alpha = {		idx: 3,		type: "percent",		def: 1	};} );// Populate the class2type mapjQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),	function( _i, name ) {		class2type[ "[object " + name + "]" ] = name.toLowerCase();	} );function getType( obj ) {	if ( obj == null ) {		return obj + "";	}	return typeof obj === "object" ?		class2type[ toString.call( obj ) ] || "object" :		typeof obj;}function clamp( value, prop, allowEmpty ) {	var type = propTypes[ prop.type ] || {};	if ( value == null ) {		return ( allowEmpty || !!prop.def ) ? null : prop.def;	}	// ~~ is an short way of doing floor for positive numbers	value = type.floor ? ~~value : parseFloat( value );	// IE will pass in empty strings as value for alpha,	// which will hit this case	if ( isNaN( value ) ) {		return prop.def;	}	if ( type.mod ) {		// we add mod before modding to make sure that negatives values		// get converted properly: -10 -> 350		return ( value + type.mod ) % type.mod;	}	// for now all property types without mod have min and max	return Math.min( type.max, Math.max( 0, value ) );}function stringParse( string ) {	var inst = color(),		rgba = inst._rgba = [];	string = string.toLowerCase();	each( stringParsers, function( _i, parser ) {		var parsed,			match = parser.re.exec( string ),			values = match && parser.parse( match ),			spaceName = parser.space || "rgba";		if ( values ) {			parsed = inst[ spaceName ]( values );			// if this was an rgba parse the assignment might happen twice			// oh well....			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];			rgba = inst._rgba = parsed._rgba;			// exit each( stringParsers ) here because we matched			return false;		}	} );	// Found a stringParser that handled it	if ( rgba.length ) {		// if this came from a parsed string, force "transparent" when alpha is 0		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)		if ( rgba.join() === "0,0,0,0" ) {			jQuery.extend( rgba, colors.transparent );		}		return inst;	}	// named colors	return colors[ string ];}color.fn = jQuery.extend( color.prototype, {	parse: function( red, green, blue, alpha ) {		if ( red === undefined ) {			this._rgba = [ null, null, null, null ];			return this;		}		if ( red.jquery || red.nodeType ) {			red = jQuery( red ).css( green );			green = undefined;		}		var inst = this,			type = getType( red ),			rgba = this._rgba = [];		// more than 1 argument specified - assume ( red, green, blue, alpha )		if ( green !!== undefined ) {			red = [ red, green, blue, alpha ];			type = "array";		}		if ( type === "string" ) {			return this.parse( stringParse( red ) || colors._default );		}		if ( type === "array" ) {			each( spaces.rgba.props, function( _key, prop ) {				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );			} );			return this;		}		if ( type === "object" ) {			if ( red instanceof color ) {				each( spaces, function( _spaceName, space ) {					if ( red[ space.cache ] ) {						inst[ space.cache ] = red[ space.cache ].slice();					}				} );			} else {				each( spaces, function( _spaceName, space ) {					var cache = space.cache;					each( space.props, function( key, prop ) {						// if the cache doesn''t exist, and we know how to convert						if ( !!inst[ cache ] && space.to ) {							// if the value was null, we don''t need to copy it							// if the key was alpha, we don''t need to copy it either							if ( key === "alpha" || red[ key ] == null ) {								return;							}							inst[ cache ] = space.to( inst._rgba );						}						// this is the only case where we allow nulls for ALL properties.						// call clamp with alwaysAllowEmpty						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );					} );					// everything defined but alpha?					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {						// use the default of 1						if ( inst[ cache ][ 3 ] == null ) {							inst[ cache ][ 3 ] = 1;						}						if ( space.from ) {							inst._rgba = space.from( inst[ cache ] );						}					}				} );			}			return this;		}	},	is: function( compare ) {		var is = color( compare ),			same = true,			inst = this;		each( spaces, function( _, space ) {			var localCache,				isCache = is[ space.cache ];			if ( isCache ) {				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];				each( space.props, function( _, prop ) {					if ( isCache[ prop.idx ] !!= null ) {						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );						return same;					}				} );			}			return same;		} );		return same;	},	_space: function() {		var used = [],			inst = this;		each( spaces, function( spaceName, space ) {			if ( inst[ space.cache ] ) {				used.push( spaceName );			}		} );		return used.pop();	},	transition: function( other, distance ) {		var end = color( other ),			spaceName = end._space(),			space = spaces[ spaceName ],			startColor = this.alpha() === 0 ? color( "transparent" ) : this,			start = startColor[ space.cache ] || space.to( startColor._rgba ),			result = start.slice();		end = end[ space.cache ];		each( space.props, function( _key, prop ) {			var index = prop.idx,				startValue = start[ index ],				endValue = end[ index ],				type = propTypes[ prop.type ] || {};			// if null, don''t override start value			if ( endValue === null ) {				return;			}			// if null - use end			if ( startValue === null ) {				result[ index ] = endValue;			} else {				if ( type.mod ) {					if ( endValue - startValue > type.mod / 2 ) {						startValue += type.mod;					} else if ( startValue - endValue > type.mod / 2 ) {						startValue -= type.mod;					}				}				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );			}		} );		return this[ spaceName ]( result );	},	blend: function( opaque ) {		// if we are already opaque - return ourself		if ( this._rgba[ 3 ] === 1 ) {			return this;		}		var rgb = this._rgba.slice(),			a = rgb.pop(),			blend = color( opaque )._rgba;		return color( jQuery.map( rgb, function( v, i ) {			return ( 1 - a ) * blend[ i ] + a * v;		} ) );	},	toRgbaString: function() {		var prefix = "rgba(",			rgba = jQuery.map( this._rgba, function( v, i ) {				if ( v !!= null ) {					return v;				}				return i > 2 ? 1 : 0;			} );		if ( rgba[ 3 ] === 1 ) {			rgba.pop();			prefix = "rgb(";		}		return prefix + rgba.join() + ")";	},	toHslaString: function() {		var prefix = "hsla(",			hsla = jQuery.map( this.hsla(), function( v, i ) {				if ( v == null ) {					v = i > 2 ? 1 : 0;				}				// catch 1 and 2				if ( i && i < 3 ) {					v = Math.round( v * 100 ) + "%";				}				return v;			} );		if ( hsla[ 3 ] === 1 ) {			hsla.pop();			prefix = "hsl(";		}		return prefix + hsla.join() + ")";	},	toHexString: function( includeAlpha ) {		var rgba = this._rgba.slice(),			alpha = rgba.pop();		if ( includeAlpha ) {			rgba.push( ~~( alpha * 255 ) );		}		return "#" + jQuery.map( rgba, function( v ) {			// default to 0 when nulls exist			v = ( v || 0 ).toString( 16 );			return v.length === 1 ? "0" + v : v;		} ).join( "" );	},	toString: function() {		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();	}} );color.fn.parse.prototype = color.fn;// hsla conversions adapted from:// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021function hue2rgb( p, q, h ) {	h = ( h + 1 ) % 1;	if ( h * 6 < 1 ) {		return p + ( q - p ) * h * 6;	}	if ( h * 2 < 1 ) {		return q;	}	if ( h * 3 < 2 ) {		return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;	}	return p;}spaces.hsla.to = function( rgba ) {	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {		return [ null, null, null, rgba[ 3 ] ];	}	var r = rgba[ 0 ] / 255,		g = rgba[ 1 ] / 255,		b = rgba[ 2 ] / 255,		a = rgba[ 3 ],		max = Math.max( r, g, b ),		min = Math.min( r, g, b ),		diff = max - min,		add = max + min,		l = add * 0.5,		h, s;	if ( min === max ) {		h = 0;	} else if ( r === max ) {		h = ( 60 * ( g - b ) / diff ) + 360;	} else if ( g === max ) {		h = ( 60 * ( b - r ) / diff ) + 120;	} else {		h = ( 60 * ( r - g ) / diff ) + 240;	}	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)	if ( diff === 0 ) {		s = 0;	} else if ( l <= 0.5 ) {		s = diff / add;	} else {		s = diff / ( 2 - add );	}	return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];};spaces.hsla.from = function( hsla ) {	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {		return [ null, null, null, hsla[ 3 ] ];	}	var h = hsla[ 0 ] / 360,		s = hsla[ 1 ],		l = hsla[ 2 ],		a = hsla[ 3 ],		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,		p = 2 * l - q;	return [		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),		Math.round( hue2rgb( p, q, h ) * 255 ),		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),		a	];};each( spaces, function( spaceName, space ) {	var props = space.props,		cache = space.cache,		to = space.to,		from = space.from;	// makes rgba() and hsla()	color.fn[ spaceName ] = function( value ) {		// generate a cache for this space if it doesn''t exist		if ( to && !!this[ cache ] ) {			this[ cache ] = to( this._rgba );		}		if ( value === undefined ) {			return this[ cache ].slice();		}		var ret,			type = getType( value ),			arr = ( type === "array" || type === "object" ) ? value : arguments,			local = this[ cache ].slice();		each( props, function( key, prop ) {			var val = arr[ type === "object" ? key : prop.idx ];			if ( val == null ) {				val = local[ prop.idx ];			}			local[ prop.idx ] = clamp( val, prop );		} );		if ( from ) {			ret = color( from( local ) );			ret[ cache ] = local;			return ret;		} else {			return color( local );		}	};	// makes red() green() blue() alpha() hue() saturation() lightness()	each( props, function( key, prop ) {		// alpha is included in more than one space		if ( color.fn[ key ] ) {			return;		}		color.fn[ key ] = function( value ) {			var local, cur, match, fn,				vtype = getType( value );			if ( key === "alpha" ) {				fn = this._hsla ? "hsla" : "rgba";			} else {				fn = spaceName;			}			local = this[ fn ]();			cur = local[ prop.idx ];			if ( vtype === "undefined" ) {				return cur;			}			if ( vtype === "function" ) {				value = value.call( this, cur );				vtype = getType( value );			}			if ( value == null && prop.empty ) {				return this;			}			if ( vtype === "string" ) {				match = rplusequals.exec( value );				if ( match ) {					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );				}			}			local[ prop.idx ] = value;			return this[ fn ]( local );		};	} );} );// add cssHook and .fx.step function for each named hook.// accept a space separated string of propertiescolor.hook = function( hook ) {	var hooks = hook.split( " " );	each( hooks, function( _i, hook ) {		jQuery.cssHooks[ hook ] = {			set: function( elem, value ) {				var parsed, curElem,					backgroundColor = "";				if ( value !!== "transparent" && ( getType( value ) !!== "string" || ( parsed = stringParse( value ) ) ) ) {					value = color( parsed || value );					if ( !!support.rgba && value._rgba[ 3 ] !!== 1 ) {						curElem = hook === "backgroundColor" ? elem.parentNode : elem;						while (							( backgroundColor === "" || backgroundColor === "transparent" ) &&							curElem && curElem.style						) {							try {								backgroundColor = jQuery.css( curElem, "backgroundColor" );								curElem = curElem.parentNode;							} catch ( e ) {							}						}						value = value.blend( backgroundColor && backgroundColor !!== "transparent" ?							backgroundColor :							"_default" );					}					value = value.toRgbaString();				}				try {					elem.style[ hook ] = value;				} catch ( e ) {					// wrapped to prevent IE from throwing errors on "invalid" values like ''auto'' or ''inherit''				}			}		};		jQuery.fx.step[ hook ] = function( fx ) {			if ( !!fx.colorInit ) {				fx.start = color( fx.elem, hook );				fx.end = color( fx.end );				fx.colorInit = true;			}			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );		};	} );};color.hook( stepHooks );jQuery.cssHooks.borderColor = {	expand: function( value ) {		var expanded = {};		each( [ "Top", "Right", "Bottom", "Left" ], function( _i, part ) {			expanded[ "border" + part + "Color" ] = value;		} );		return expanded;	}};// Basic color names only.// Usage of any of the other color names requires adding yourself or including// jquery.color.svg-names.js.colors = jQuery.Color.names = {	// 4.1. Basic color keywords	aqua: "#00ffff",	black: "#000000",	blue: "#0000ff",	fuchsia: "#ff00ff",	gray: "#808080",	green: "#008000",	lime: "#00ff00",	maroon: "#800000",	navy: "#000080",	olive: "#808000",	purple: "#800080",	red: "#ff0000",	silver: "#c0c0c0",	teal: "#008080",	white: "#ffffff",	yellow: "#ffff00",	// 4.2.3. "transparent" color keyword	transparent: [ null, null, null, 0 ],	_default: "#ffffff"};/*!! * jQuery UI Effects 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Effects Core//>>group: Effects/* eslint-disable max-len *///>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects./* eslint-enable max-len *///>>docs: http://api.jqueryui.com/category/effects-core///>>demos: http://jqueryui.com/effect/var dataSpace = "ui-effects-",	dataSpaceStyle = "ui-effects-style",	dataSpaceAnimated = "ui-effects-animated";$.effects = {	effect: {}};/******************************************************************************//****************************** CLASS ANIMATIONS ******************************//******************************************************************************/( function() {var classAnimationActions = [ "add", "remove", "toggle" ],	shorthandStyles = {		border: 1,		borderBottom: 1,		borderColor: 1,		borderLeft: 1,		borderRight: 1,		borderTop: 1,		borderWidth: 1,		margin: 1,		padding: 1	};$.each(	[ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ],	function( _, prop ) {		$.fx.step[ prop ] = function( fx ) {			if ( fx.end !!== "none" && !!fx.setAttr || fx.pos === 1 && !!fx.setAttr ) {				jQuery.style( fx.elem, prop, fx.end );				fx.setAttr = true;			}		};	});function camelCase( string ) {	return string.replace( /-([\da-z])/gi, function( all, letter ) {		return letter.toUpperCase();	} );}function getElementStyles( elem ) {	var key, len,		style = elem.ownerDocument.defaultView ?			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :			elem.currentStyle,		styles = {};	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {		len = style.length;		while ( len-- ) {			key = style[ len ];			if ( typeof style[ key ] === "string" ) {				styles[ camelCase( key ) ] = style[ key ];			}		}	// Support: Opera, IE <9	} else {		for ( key in style ) {			if ( typeof style[ key ] === "string" ) {				styles[ key ] = style[ key ];			}		}	}	return styles;}function styleDifference( oldStyle, newStyle ) {	var diff = {},		name, value;	for ( name in newStyle ) {		value = newStyle[ name ];		if ( oldStyle[ name ] !!== value ) {			if ( !!shorthandStyles[ name ] ) {				if ( $.fx.step[ name ] || !!isNaN( parseFloat( value ) ) ) {					diff[ name ] = value;				}			}		}	}	return diff;}// Support: jQuery <1.8if ( !!$.fn.addBack ) {	$.fn.addBack = function( selector ) {		return this.add( selector == null ?			this.prevObject : this.prevObject.filter( selector )		);	};}$.effects.animateClass = function( value, duration, easing, callback ) {	var o = $.speed( duration, easing, callback );	return this.queue( function() {		var animated = $( this ),			baseClass = animated.attr( "class" ) || "",			applyClassChange,			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;		// Map the animated objects to store the original styles.		allAnimations = allAnimations.map( function() {			var el = $( this );			return {				el: el,				start: getElementStyles( this )			};		} );		// Apply class change		applyClassChange = function() {			$.each( classAnimationActions, function( i, action ) {				if ( value[ action ] ) {					animated[ action + "Class" ]( value[ action ] );				}			} );		};		applyClassChange();		// Map all animated objects again - calculate new styles and diff		allAnimations = allAnimations.map( function() {			this.end = getElementStyles( this.el[ 0 ] );			this.diff = styleDifference( this.start, this.end );			return this;		} );		// Apply original class		animated.attr( "class", baseClass );		// Map all animated objects again - this time collecting a promise		allAnimations = allAnimations.map( function() {			var styleInfo = this,				dfd = $.Deferred(),				opts = $.extend( {}, o, {					queue: false,					complete: function() {						dfd.resolve( styleInfo );					}				} );			this.el.animate( this.diff, opts );			return dfd.promise();		} );		// Once all animations have completed:		$.when.apply( $, allAnimations.get() ).done( function() {			// Set the final class			applyClassChange();			// For each animated element,			// clear all css properties that were animated			$.each( arguments, function() {				var el = this.el;				$.each( this.diff, function( key ) {					el.css( key, "" );				} );			} );			// This is guarnteed to be there if you use jQuery.speed()			// it also handles dequeuing the next anim...			o.complete.call( animated[ 0 ] );		} );	} );};$.fn.extend( {	addClass: ( function( orig ) {		return function( classNames, speed, easing, callback ) {			return speed ?				$.effects.animateClass.call( this,					{ add: classNames }, speed, easing, callback ) :				orig.apply( this, arguments );		};	} )( $.fn.addClass ),	removeClass: ( function( orig ) {		return function( classNames, speed, easing, callback ) {			return arguments.length > 1 ?				$.effects.animateClass.call( this,					{ remove: classNames }, speed, easing, callback ) :				orig.apply( this, arguments );		};	} )( $.fn.removeClass ),	toggleClass: ( function( orig ) {		return function( classNames, force, speed, easing, callback ) {			if ( typeof force === "boolean" || force === undefined ) {				if ( !!speed ) {					// Without speed parameter					return orig.apply( this, arguments );				} else {					return $.effects.animateClass.call( this,						( force ? { add: classNames } : { remove: classNames } ),						speed, easing, callback );				}			} else {				// Without force parameter				return $.effects.animateClass.call( this,					{ toggle: classNames }, force, speed, easing );			}		};	} )( $.fn.toggleClass ),	switchClass: function( remove, add, speed, easing, callback ) {		return $.effects.animateClass.call( this, {			add: add,			remove: remove		}, speed, easing, callback );	}} );} )();/******************************************************************************//*********************************** EFFECTS **********************************//******************************************************************************/( function() {if ( $.expr && $.expr.pseudos && $.expr.pseudos.animated ) {	$.expr.pseudos.animated = ( function( orig ) {		return function( elem ) {			return !!!!$( elem ).data( dataSpaceAnimated ) || orig( elem );		};	} )( $.expr.pseudos.animated );}if ( $.uiBackCompat !!== false ) {	$.extend( $.effects, {		// Saves a set of properties in a data storage		save: function( element, set ) {			var i = 0, length = set.length;			for ( ; i < length; i++ ) {				if ( set[ i ] !!== null ) {					element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );				}			}		},		// Restores a set of previously saved properties from a data storage		restore: function( element, set ) {			var val, i = 0, length = set.length;			for ( ; i < length; i++ ) {				if ( set[ i ] !!== null ) {					val = element.data( dataSpace + set[ i ] );					element.css( set[ i ], val );				}			}		},		setMode: function( el, mode ) {			if ( mode === "toggle" ) {				mode = el.is( ":hidden" ) ? "show" : "hide";			}			return mode;		},		// Wraps the element around a wrapper that copies position properties		createWrapper: function( element ) {			// If the element is already wrapped, return it			if ( element.parent().is( ".ui-effects-wrapper" ) ) {				return element.parent();			}			// Wrap the element			var props = {					width: element.outerWidth( true ),					height: element.outerHeight( true ),					"float": element.css( "float" )				},				wrapper = $( "<div></div>" )					.addClass( "ui-effects-wrapper" )					.css( {						fontSize: "100%",						background: "transparent",						border: "none",						margin: 0,						padding: 0					} ),				// Store the size in case width/height are defined in % - Fixes #5245				size = {					width: element.width(),					height: element.height()				},				active = document.activeElement;			// Support: Firefox			// Firefox incorrectly exposes anonymous content			// https://bugzilla.mozilla.org/show_bug.cgi?id=561664			try {				// eslint-disable-next-line no-unused-expressions				active.id;			} catch ( e ) {				active = document.body;			}			element.wrap( wrapper );			// Fixes #7595 - Elements lose focus when wrapped.			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {				$( active ).trigger( "focus" );			}			// Hotfix for jQuery 1.4 since some change in wrap() seems to actually			// lose the reference to the wrapped element			wrapper = element.parent();			// Transfer positioning properties to the wrapper			if ( element.css( "position" ) === "static" ) {				wrapper.css( { position: "relative" } );				element.css( { position: "relative" } );			} else {				$.extend( props, {					position: element.css( "position" ),					zIndex: element.css( "z-index" )				} );				$.each( [ "top", "left", "bottom", "right" ], function( i, pos ) {					props[ pos ] = element.css( pos );					if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {						props[ pos ] = "auto";					}				} );				element.css( {					position: "relative",					top: 0,					left: 0,					right: "auto",					bottom: "auto"				} );			}			element.css( size );			return wrapper.css( props ).show();		},		removeWrapper: function( element ) {			var active = document.activeElement;			if ( element.parent().is( ".ui-effects-wrapper" ) ) {				element.parent().replaceWith( element );				// Fixes #7595 - Elements lose focus when wrapped.				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {					$( active ).trigger( "focus" );				}			}			return element;		}	} );}$.extend( $.effects, {	version: "1.13.2",	define: function( name, mode, effect ) {		if ( !!effect ) {			effect = mode;			mode = "effect";		}		$.effects.effect[ name ] = effect;		$.effects.effect[ name ].mode = mode;		return effect;	},	scaledDimensions: function( element, percent, direction ) {		if ( percent === 0 ) {			return {				height: 0,				width: 0,				outerHeight: 0,				outerWidth: 0			};		}		var x = direction !!== "horizontal" ? ( ( percent || 100 ) / 100 ) : 1,			y = direction !!== "vertical" ? ( ( percent || 100 ) / 100 ) : 1;		return {			height: element.height() * y,			width: element.width() * x,			outerHeight: element.outerHeight() * y,			outerWidth: element.outerWidth() * x		};	},	clipToBox: function( animation ) {		return {			width: animation.clip.right - animation.clip.left,			height: animation.clip.bottom - animation.clip.top,			left: animation.clip.left,			top: animation.clip.top		};	},	// Injects recently queued functions to be first in line (after "inprogress")	unshift: function( element, queueLength, count ) {		var queue = element.queue();		if ( queueLength > 1 ) {			queue.splice.apply( queue,				[ 1, 0 ].concat( queue.splice( queueLength, count ) ) );		}		element.dequeue();	},	saveStyle: function( element ) {		element.data( dataSpaceStyle, element[ 0 ].style.cssText );	},	restoreStyle: function( element ) {		element[ 0 ].style.cssText = element.data( dataSpaceStyle ) || "";		element.removeData( dataSpaceStyle );	},	mode: function( element, mode ) {		var hidden = element.is( ":hidden" );		if ( mode === "toggle" ) {			mode = hidden ? "show" : "hide";		}		if ( hidden ? mode === "hide" : mode === "show" ) {			mode = "none";		}		return mode;	},	// Translates a [top,left] array into a baseline value	getBaseline: function( origin, original ) {		var y, x;		switch ( origin[ 0 ] ) {		case "top":			y = 0;			break;		case "middle":			y = 0.5;			break;		case "bottom":			y = 1;			break;		default:			y = origin[ 0 ] / original.height;		}		switch ( origin[ 1 ] ) {		case "left":			x = 0;			break;		case "center":			x = 0.5;			break;		case "right":			x = 1;			break;		default:			x = origin[ 1 ] / original.width;		}		return {			x: x,			y: y		};	},	// Creates a placeholder element so that the original element can be made absolute	createPlaceholder: function( element ) {		var placeholder,			cssPosition = element.css( "position" ),			position = element.position();		// Lock in margins first to account for form elements, which		// will change margin if you explicitly set height		// see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380		// Support: Safari		element.css( {			marginTop: element.css( "marginTop" ),			marginBottom: element.css( "marginBottom" ),			marginLeft: element.css( "marginLeft" ),			marginRight: element.css( "marginRight" )		} )		.outerWidth( element.outerWidth() )		.outerHeight( element.outerHeight() );		if ( /^(static|relative)/.test( cssPosition ) ) {			cssPosition = "absolute";			placeholder = $( "<" + element[ 0 ].nodeName + ">" ).insertAfter( element ).css( {				// Convert inline to inline block to account for inline elements				// that turn to inline block based on content (like img)				display: /^(inline|ruby)/.test( element.css( "display" ) ) ?					"inline-block" :					"block",				visibility: "hidden",				// Margins need to be set to account for margin collapse				marginTop: element.css( "marginTop" ),				marginBottom: element.css( "marginBottom" ),				marginLeft: element.css( "marginLeft" ),				marginRight: element.css( "marginRight" ),				"float": element.css( "float" )			} )			.outerWidth( element.outerWidth() )			.outerHeight( element.outerHeight() )			.addClass( "ui-effects-placeholder" );			element.data( dataSpace + "placeholder", placeholder );		}		element.css( {			position: cssPosition,			left: position.left,			top: position.top		} );		return placeholder;	},	removePlaceholder: function( element ) {		var dataKey = dataSpace + "placeholder",				placeholder = element.data( dataKey );		if ( placeholder ) {			placeholder.remove();			element.removeData( dataKey );		}	},	// Removes a placeholder if it exists and restores	// properties that were modified during placeholder creation	cleanUp: function( element ) {		$.effects.restoreStyle( element );		$.effects.removePlaceholder( element );	},	setTransition: function( element, list, factor, value ) {		value = value || {};		$.each( list, function( i, x ) {			var unit = element.cssUnit( x );			if ( unit[ 0 ] > 0 ) {				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];			}		} );		return value;	}} );// Return an effect options object for the given parameters:function _normalizeArguments( effect, options, speed, callback ) {	// Allow passing all options as the first parameter	if ( $.isPlainObject( effect ) ) {		options = effect;		effect = effect.effect;	}	// Convert to an object	effect = { effect: effect };	// Catch (effect, null, ...)	if ( options == null ) {		options = {};	}	// Catch (effect, callback)	if ( typeof options === "function" ) {		callback = options;		speed = null;		options = {};	}	// Catch (effect, speed, ?)	if ( typeof options === "number" || $.fx.speeds[ options ] ) {		callback = speed;		speed = options;		options = {};	}	// Catch (effect, options, callback)	if ( typeof speed === "function" ) {		callback = speed;		speed = null;	}	// Add options to effect	if ( options ) {		$.extend( effect, options );	}	speed = speed || options.duration;	effect.duration = $.fx.off ? 0 :		typeof speed === "number" ? speed :		speed in $.fx.speeds ? $.fx.speeds[ speed ] :		$.fx.speeds._default;	effect.complete = callback || options.complete;	return effect;}function standardAnimationOption( option ) {	// Valid standard speeds (nothing, number, named speed)	if ( !!option || typeof option === "number" || $.fx.speeds[ option ] ) {		return true;	}	// Invalid strings - treat as "normal" speed	if ( typeof option === "string" && !!$.effects.effect[ option ] ) {		return true;	}	// Complete callback	if ( typeof option === "function" ) {		return true;	}	// Options hash (but not naming an effect)	if ( typeof option === "object" && !!option.effect ) {		return true;	}	// Didn''t match any standard API	return false;}$.fn.extend( {	effect: function( /* effect, options, speed, callback */ ) {		var args = _normalizeArguments.apply( this, arguments ),			effectMethod = $.effects.effect[ args.effect ],			defaultMode = effectMethod.mode,			queue = args.queue,			queueName = queue || "fx",			complete = args.complete,			mode = args.mode,			modes = [],			prefilter = function( next ) {				var el = $( this ),					normalizedMode = $.effects.mode( el, mode ) || defaultMode;				// Sentinel for duck-punching the :animated pseudo-selector				el.data( dataSpaceAnimated, true );				// Save effect mode for later use,				// we can''t just call $.effects.mode again later,				// as the .show() below destroys the initial state				modes.push( normalizedMode );				// See $.uiBackCompat inside of run() for removal of defaultMode in 1.14				if ( defaultMode && ( normalizedMode === "show" ||						( normalizedMode === defaultMode && normalizedMode === "hide" ) ) ) {					el.show();				}				if ( !!defaultMode || normalizedMode !!== "none" ) {					$.effects.saveStyle( el );				}				if ( typeof next === "function" ) {					next();				}			};		if ( $.fx.off || !!effectMethod ) {			// Delegate to the original method (e.g., .show()) if possible			if ( mode ) {				return this[ mode ]( args.duration, complete );			} else {				return this.each( function() {					if ( complete ) {						complete.call( this );					}				} );			}		}		function run( next ) {			var elem = $( this );			function cleanup() {				elem.removeData( dataSpaceAnimated );				$.effects.cleanUp( elem );				if ( args.mode === "hide" ) {					elem.hide();				}				done();			}			function done() {				if ( typeof complete === "function" ) {					complete.call( elem[ 0 ] );				}				if ( typeof next === "function" ) {					next();				}			}			// Override mode option on a per element basis,			// as toggle can be either show or hide depending on element state			args.mode = modes.shift();			if ( $.uiBackCompat !!== false && !!defaultMode ) {				if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {					// Call the core method to track "olddisplay" properly					elem[ mode ]();					done();				} else {					effectMethod.call( elem[ 0 ], args, done );				}			} else {				if ( args.mode === "none" ) {					// Call the core method to track "olddisplay" properly					elem[ mode ]();					done();				} else {					effectMethod.call( elem[ 0 ], args, cleanup );				}			}		}		// Run prefilter on all elements first to ensure that		// any showing or hiding happens before placeholder creation,		// which ensures that any layout changes are correctly captured.		return queue === false ?			this.each( prefilter ).each( run ) :			this.queue( queueName, prefilter ).queue( queueName, run );	},	show: ( function( orig ) {		return function( option ) {			if ( standardAnimationOption( option ) ) {				return orig.apply( this, arguments );			} else {				var args = _normalizeArguments.apply( this, arguments );				args.mode = "show";				return this.effect.call( this, args );			}		};	} )( $.fn.show ),	hide: ( function( orig ) {		return function( option ) {			if ( standardAnimationOption( option ) ) {				return orig.apply( this, arguments );			} else {				var args = _normalizeArguments.apply( this, arguments );				args.mode = "hide";				return this.effect.call( this, args );			}		};	} )( $.fn.hide ),	toggle: ( function( orig ) {		return function( option ) {			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {				return orig.apply( this, arguments );			} else {				var args = _normalizeArguments.apply( this, arguments );				args.mode = "toggle";				return this.effect.call( this, args );			}		};	} )( $.fn.toggle ),	cssUnit: function( key ) {		var style = this.css( key ),			val = [];		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {			if ( style.indexOf( unit ) > 0 ) {				val = [ parseFloat( style ), unit ];			}		} );		return val;	},	cssClip: function( clipObj ) {		if ( clipObj ) {			return this.css( "clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " +				clipObj.bottom + "px " + clipObj.left + "px)" );		}		return parseClip( this.css( "clip" ), this );	},	transfer: function( options, done ) {		var element = $( this ),			target = $( options.to ),			targetFixed = target.css( "position" ) === "fixed",			body = $( "body" ),			fixTop = targetFixed ? body.scrollTop() : 0,			fixLeft = targetFixed ? body.scrollLeft() : 0,			endPosition = target.offset(),			animation = {				top: endPosition.top - fixTop,				left: endPosition.left - fixLeft,				height: target.innerHeight(),				width: target.innerWidth()			},			startPosition = element.offset(),			transfer = $( "<div class=''ui-effects-transfer''></div>" );		transfer			.appendTo( "body" )			.addClass( options.className )			.css( {				top: startPosition.top - fixTop,				left: startPosition.left - fixLeft,				height: element.innerHeight(),				width: element.innerWidth(),				position: targetFixed ? "fixed" : "absolute"			} )			.animate( animation, options.duration, options.easing, function() {				transfer.remove();				if ( typeof done === "function" ) {					done();				}			} );	}} );function parseClip( str, element ) {		var outerWidth = element.outerWidth(),			outerHeight = element.outerHeight(),			clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,			values = clipRegex.exec( str ) || [ "", 0, outerWidth, outerHeight, 0 ];		return {			top: parseFloat( values[ 1 ] ) || 0,			right: values[ 2 ] === "auto" ? outerWidth : parseFloat( values[ 2 ] ),			bottom: values[ 3 ] === "auto" ? outerHeight : parseFloat( values[ 3 ] ),			left: parseFloat( values[ 4 ] ) || 0		};}$.fx.step.clip = function( fx ) {	if ( !!fx.clipInit ) {		fx.start = $( fx.elem ).cssClip();		if ( typeof fx.end === "string" ) {			fx.end = parseClip( fx.end, fx.elem );		}		fx.clipInit = true;	}	$( fx.elem ).cssClip( {		top: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top,		right: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right,		bottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom,		left: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left	} );};} )();/******************************************************************************//*********************************** EASING ***********************************//******************************************************************************/( function() {// Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)var baseEasings = {};$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {	baseEasings[ name ] = function( p ) {		return Math.pow( p, i + 2 );	};} );$.extend( baseEasings, {	Sine: function( p ) {		return 1 - Math.cos( p * Math.PI / 2 );	},	Circ: function( p ) {		return 1 - Math.sqrt( 1 - p * p );	},	Elastic: function( p ) {		return p === 0 || p === 1 ? p :			-Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 );	},	Back: function( p ) {		return p * p * ( 3 * p - 2 );	},	Bounce: function( p ) {		var pow2,			bounce = 4;		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );	}} );$.each( baseEasings, function( name, easeIn ) {	$.easing[ "easeIn" + name ] = easeIn;	$.easing[ "easeOut" + name ] = function( p ) {		return 1 - easeIn( 1 - p );	};	$.easing[ "easeInOut" + name ] = function( p ) {		return p < 0.5 ?			easeIn( p * 2 ) / 2 :			1 - easeIn( p * -2 + 2 ) / 2;	};} );} )();var effect = $.effects;/*!! * jQuery UI Effects Blind 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Blind Effect//>>group: Effects//>>description: Blinds the element.//>>docs: http://api.jqueryui.com/blind-effect///>>demos: http://jqueryui.com/effect/var effectsEffectBlind = $.effects.define( "blind", "hide", function( options, done ) {	var map = {			up: [ "bottom", "top" ],			vertical: [ "bottom", "top" ],			down: [ "top", "bottom" ],			left: [ "right", "left" ],			horizontal: [ "right", "left" ],			right: [ "left", "right" ]		},		element = $( this ),		direction = options.direction || "up",		start = element.cssClip(),		animate = { clip: $.extend( {}, start ) },		placeholder = $.effects.createPlaceholder( element );	animate.clip[ map[ direction ][ 0 ] ] = animate.clip[ map[ direction ][ 1 ] ];	if ( options.mode === "show" ) {		element.cssClip( animate.clip );		if ( placeholder ) {			placeholder.css( $.effects.clipToBox( animate ) );		}		animate.clip = start;	}	if ( placeholder ) {		placeholder.animate( $.effects.clipToBox( animate ), options.duration, options.easing );	}	element.animate( animate, {		queue: false,		duration: options.duration,		easing: options.easing,		complete: done	} );} );/*!! * jQuery UI Effects Bounce 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Bounce Effect//>>group: Effects//>>description: Bounces an element horizontally or vertically n times.//>>docs: http://api.jqueryui.com/bounce-effect///>>demos: http://jqueryui.com/effect/var effectsEffectBounce = $.effects.define( "bounce", function( options, done ) {	var upAnim, downAnim, refValue,		element = $( this ),		// Defaults:		mode = options.mode,		hide = mode === "hide",		show = mode === "show",		direction = options.direction || "up",		distance = options.distance,		times = options.times || 5,		// Number of internal animations		anims = times * 2 + ( show || hide ? 1 : 0 ),		speed = options.duration / anims,		easing = options.easing,		// Utility:		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",		motion = ( direction === "up" || direction === "left" ),		i = 0,		queuelen = element.queue().length;	$.effects.createPlaceholder( element );	refValue = element.css( ref );	// Default distance for the BIGGEST bounce is the outer Distance / 3	if ( !!distance ) {		distance = element[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;	}	if ( show ) {		downAnim = { opacity: 1 };		downAnim[ ref ] = refValue;		// If we are showing, force opacity 0 and set the initial position		// then do the "first" animation		element			.css( "opacity", 0 )			.css( ref, motion ? -distance * 2 : distance * 2 )			.animate( downAnim, speed, easing );	}	// Start at the smallest distance if we are hiding	if ( hide ) {		distance = distance / Math.pow( 2, times - 1 );	}	downAnim = {};	downAnim[ ref ] = refValue;	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here	for ( ; i < times; i++ ) {		upAnim = {};		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;		element			.animate( upAnim, speed, easing )			.animate( downAnim, speed, easing );		distance = hide ? distance * 2 : distance / 2;	}	// Last Bounce when Hiding	if ( hide ) {		upAnim = { opacity: 0 };		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;		element.animate( upAnim, speed, easing );	}	element.queue( done );	$.effects.unshift( element, queuelen, anims + 1 );} );/*!! * jQuery UI Effects Clip 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Clip Effect//>>group: Effects//>>description: Clips the element on and off like an old TV.//>>docs: http://api.jqueryui.com/clip-effect///>>demos: http://jqueryui.com/effect/var effectsEffectClip = $.effects.define( "clip", "hide", function( options, done ) {	var start,		animate = {},		element = $( this ),		direction = options.direction || "vertical",		both = direction === "both",		horizontal = both || direction === "horizontal",		vertical = both || direction === "vertical";	start = element.cssClip();	animate.clip = {		top: vertical ? ( start.bottom - start.top ) / 2 : start.top,		right: horizontal ? ( start.right - start.left ) / 2 : start.right,		bottom: vertical ? ( start.bottom - start.top ) / 2 : start.bottom,		left: horizontal ? ( start.right - start.left ) / 2 : start.left	};	$.effects.createPlaceholder( element );	if ( options.mode === "show" ) {		element.cssClip( animate.clip );		animate.clip = start;	}	element.animate( animate, {		queue: false,		duration: options.duration,		easing: options.easing,		complete: done	} );} );/*!! * jQuery UI Effects Drop 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Drop Effect//>>group: Effects//>>description: Moves an element in one direction and hides it at the same time.//>>docs: http://api.jqueryui.com/drop-effect///>>demos: http://jqueryui.com/effect/var effectsEffectDrop = $.effects.define( "drop", "hide", function( options, done ) {	var distance,		element = $( this ),		mode = options.mode,		show = mode === "show",		direction = options.direction || "left",		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",		motion = ( direction === "up" || direction === "left" ) ? "-=" : "+=",		oppositeMotion = ( motion === "+=" ) ? "-=" : "+=",		animation = {			opacity: 0		};	$.effects.createPlaceholder( element );	distance = options.distance ||		element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;	animation[ ref ] = motion + distance;	if ( show ) {		element.css( animation );		animation[ ref ] = oppositeMotion + distance;		animation.opacity = 1;	}	// Animate	element.animate( animation, {		queue: false,		duration: options.duration,		easing: options.easing,		complete: done	} );} );/*!! * jQuery UI Effects Explode 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Explode Effect//>>group: Effects/* eslint-disable max-len *///>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness./* eslint-enable max-len *///>>docs: http://api.jqueryui.com/explode-effect///>>demos: http://jqueryui.com/effect/var effectsEffectExplode = $.effects.define( "explode", "hide", function( options, done ) {	var i, j, left, top, mx, my,		rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,		cells = rows,		element = $( this ),		mode = options.mode,		show = mode === "show",		// Show and then visibility:hidden the element before calculating offset		offset = element.show().css( "visibility", "hidden" ).offset(),		// Width and height of a piece		width = Math.ceil( element.outerWidth() / cells ),		height = Math.ceil( element.outerHeight() / rows ),		pieces = [];	// Children animate complete:	function childComplete() {		pieces.push( this );		if ( pieces.length === rows * cells ) {			animComplete();		}	}	// Clone the element for each row and cell.	for ( i = 0; i < rows; i++ ) { // ===>		top = offset.top + i * height;		my = i - ( rows - 1 ) / 2;		for ( j = 0; j < cells; j++ ) { // |||			left = offset.left + j * width;			mx = j - ( cells - 1 ) / 2;			// Create a clone of the now hidden main element that will be absolute positioned			// within a wrapper div off the -left and -top equal to size of our pieces			element				.clone()				.appendTo( "body" )				.wrap( "<div></div>" )				.css( {					position: "absolute",					visibility: "visible",					left: -j * width,					top: -i * height				} )				// Select the wrapper - make it overflow: hidden and absolute positioned based on				// where the original was located +left and +top equal to the size of pieces				.parent()					.addClass( "ui-effects-explode" )					.css( {						position: "absolute",						overflow: "hidden",						width: width,						height: height,						left: left + ( show ? mx * width : 0 ),						top: top + ( show ? my * height : 0 ),						opacity: show ? 0 : 1					} )					.animate( {						left: left + ( show ? 0 : mx * width ),						top: top + ( show ? 0 : my * height ),						opacity: show ? 1 : 0					}, options.duration || 500, options.easing, childComplete );		}	}	function animComplete() {		element.css( {			visibility: "visible"		} );		$( pieces ).remove();		done();	}} );/*!! * jQuery UI Effects Fade 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Fade Effect//>>group: Effects//>>description: Fades the element.//>>docs: http://api.jqueryui.com/fade-effect///>>demos: http://jqueryui.com/effect/var effectsEffectFade = $.effects.define( "fade", "toggle", function( options, done ) {	var show = options.mode === "show";	$( this )		.css( "opacity", show ? 0 : 1 )		.animate( {			opacity: show ? 1 : 0		}, {			queue: false,			duration: options.duration,			easing: options.easing,			complete: done		} );} );/*!! * jQuery UI Effects Fold 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Fold Effect//>>group: Effects//>>description: Folds an element first horizontally and then vertically.//>>docs: http://api.jqueryui.com/fold-effect///>>demos: http://jqueryui.com/effect/var effectsEffectFold = $.effects.define( "fold", "hide", function( options, done ) {	// Create element	var element = $( this ),		mode = options.mode,		show = mode === "show",		hide = mode === "hide",		size = options.size || 15,		percent = /([0-9]+)%/.exec( size ),		horizFirst = !!!!options.horizFirst,		ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ],		duration = options.duration / 2,		placeholder = $.effects.createPlaceholder( element ),		start = element.cssClip(),		animation1 = { clip: $.extend( {}, start ) },		animation2 = { clip: $.extend( {}, start ) },		distance = [ start[ ref[ 0 ] ], start[ ref[ 1 ] ] ],		queuelen = element.queue().length;	if ( percent ) {		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];	}	animation1.clip[ ref[ 0 ] ] = size;	animation2.clip[ ref[ 0 ] ] = size;	animation2.clip[ ref[ 1 ] ] = 0;	if ( show ) {		element.cssClip( animation2.clip );		if ( placeholder ) {			placeholder.css( $.effects.clipToBox( animation2 ) );		}		animation2.clip = start;	}	// Animate	element		.queue( function( next ) {			if ( placeholder ) {				placeholder					.animate( $.effects.clipToBox( animation1 ), duration, options.easing )					.animate( $.effects.clipToBox( animation2 ), duration, options.easing );			}			next();		} )		.animate( animation1, duration, options.easing )		.animate( animation2, duration, options.easing )		.queue( done );	$.effects.unshift( element, queuelen, 4 );} );/*!! * jQuery UI Effects Highlight 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Highlight Effect//>>group: Effects//>>description: Highlights the background of an element in a defined color for a custom duration.//>>docs: http://api.jqueryui.com/highlight-effect///>>demos: http://jqueryui.com/effect/var effectsEffectHighlight = $.effects.define( "highlight", "show", function( options, done ) {	var element = $( this ),		animation = {			backgroundColor: element.css( "backgroundColor" )		};	if ( options.mode === "hide" ) {		animation.opacity = 0;	}	$.effects.saveStyle( element );	element		.css( {			backgroundImage: "none",			backgroundColor: options.color || "#ffff99"		} )		.animate( animation, {			queue: false,			duration: options.duration,			easing: options.easing,			complete: done		} );} );/*!! * jQuery UI Effects Size 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Size Effect//>>group: Effects//>>description: Resize an element to a specified width and height.//>>docs: http://api.jqueryui.com/size-effect///>>demos: http://jqueryui.com/effect/var effectsEffectSize = $.effects.define( "size", function( options, done ) {	// Create element	var baseline, factor, temp,		element = $( this ),		// Copy for children		cProps = [ "fontSize" ],		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],		// Set options		mode = options.mode,		restore = mode !!== "effect",		scale = options.scale || "both",		origin = options.origin || [ "middle", "center" ],		position = element.css( "position" ),		pos = element.position(),		original = $.effects.scaledDimensions( element ),		from = options.from || original,		to = options.to || $.effects.scaledDimensions( element, 0 );	$.effects.createPlaceholder( element );	if ( mode === "show" ) {		temp = from;		from = to;		to = temp;	}	// Set scaling factor	factor = {		from: {			y: from.height / original.height,			x: from.width / original.width		},		to: {			y: to.height / original.height,			x: to.width / original.width		}	};	// Scale the css box	if ( scale === "box" || scale === "both" ) {		// Vertical props scaling		if ( factor.from.y !!== factor.to.y ) {			from = $.effects.setTransition( element, vProps, factor.from.y, from );			to = $.effects.setTransition( element, vProps, factor.to.y, to );		}		// Horizontal props scaling		if ( factor.from.x !!== factor.to.x ) {			from = $.effects.setTransition( element, hProps, factor.from.x, from );			to = $.effects.setTransition( element, hProps, factor.to.x, to );		}	}	// Scale the content	if ( scale === "content" || scale === "both" ) {		// Vertical props scaling		if ( factor.from.y !!== factor.to.y ) {			from = $.effects.setTransition( element, cProps, factor.from.y, from );			to = $.effects.setTransition( element, cProps, factor.to.y, to );		}	}	// Adjust the position properties based on the provided origin points	if ( origin ) {		baseline = $.effects.getBaseline( origin, original );		from.top = ( original.outerHeight - from.outerHeight ) * baseline.y + pos.top;		from.left = ( original.outerWidth - from.outerWidth ) * baseline.x + pos.left;		to.top = ( original.outerHeight - to.outerHeight ) * baseline.y + pos.top;		to.left = ( original.outerWidth - to.outerWidth ) * baseline.x + pos.left;	}	delete from.outerHeight;	delete from.outerWidth;	element.css( from );	// Animate the children if desired	if ( scale === "content" || scale === "both" ) {		vProps = vProps.concat( [ "marginTop", "marginBottom" ] ).concat( cProps );		hProps = hProps.concat( [ "marginLeft", "marginRight" ] );		// Only animate children with width attributes specified		// TODO: is this right? should we include anything with css width specified as well		element.find( "*[width]" ).each( function() {			var child = $( this ),				childOriginal = $.effects.scaledDimensions( child ),				childFrom = {					height: childOriginal.height * factor.from.y,					width: childOriginal.width * factor.from.x,					outerHeight: childOriginal.outerHeight * factor.from.y,					outerWidth: childOriginal.outerWidth * factor.from.x				},				childTo = {					height: childOriginal.height * factor.to.y,					width: childOriginal.width * factor.to.x,					outerHeight: childOriginal.height * factor.to.y,					outerWidth: childOriginal.width * factor.to.x				};			// Vertical props scaling			if ( factor.from.y !!== factor.to.y ) {				childFrom = $.effects.setTransition( child, vProps, factor.from.y, childFrom );				childTo = $.effects.setTransition( child, vProps, factor.to.y, childTo );			}			// Horizontal props scaling			if ( factor.from.x !!== factor.to.x ) {				childFrom = $.effects.setTransition( child, hProps, factor.from.x, childFrom );				childTo = $.effects.setTransition( child, hProps, factor.to.x, childTo );			}			if ( restore ) {				$.effects.saveStyle( child );			}			// Animate children			child.css( childFrom );			child.animate( childTo, options.duration, options.easing, function() {				// Restore children				if ( restore ) {					$.effects.restoreStyle( child );				}			} );		} );	}	// Animate	element.animate( to, {		queue: false,		duration: options.duration,		easing: options.easing,		complete: function() {			var offset = element.offset();			if ( to.opacity === 0 ) {				element.css( "opacity", from.opacity );			}			if ( !!restore ) {				element					.css( "position", position === "static" ? "relative" : position )					.offset( offset );				// Need to save style here so that automatic style restoration				// doesn''t restore to the original styles from before the animation.				$.effects.saveStyle( element );			}			done();		}	} );} );/*!! * jQuery UI Effects Scale 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Scale Effect//>>group: Effects//>>description: Grows or shrinks an element and its content.//>>docs: http://api.jqueryui.com/scale-effect///>>demos: http://jqueryui.com/effect/var effectsEffectScale = $.effects.define( "scale", function( options, done ) {	// Create element	var el = $( this ),		mode = options.mode,		percent = parseInt( options.percent, 10 ) ||			( parseInt( options.percent, 10 ) === 0 ? 0 : ( mode !!== "effect" ? 0 : 100 ) ),		newOptions = $.extend( true, {			from: $.effects.scaledDimensions( el ),			to: $.effects.scaledDimensions( el, percent, options.direction || "both" ),			origin: options.origin || [ "middle", "center" ]		}, options );	// Fade option to support puff	if ( options.fade ) {		newOptions.from.opacity = 1;		newOptions.to.opacity = 0;	}	$.effects.effect.size.call( this, newOptions, done );} );/*!! * jQuery UI Effects Puff 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Puff Effect//>>group: Effects//>>description: Creates a puff effect by scaling the element up and hiding it at the same time.//>>docs: http://api.jqueryui.com/puff-effect///>>demos: http://jqueryui.com/effect/var effectsEffectPuff = $.effects.define( "puff", "hide", function( options, done ) {	var newOptions = $.extend( true, {}, options, {		fade: true,		percent: parseInt( options.percent, 10 ) || 150	} );	$.effects.effect.scale.call( this, newOptions, done );} );/*!! * jQuery UI Effects Pulsate 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Pulsate Effect//>>group: Effects//>>description: Pulsates an element n times by changing the opacity to zero and back.//>>docs: http://api.jqueryui.com/pulsate-effect///>>demos: http://jqueryui.com/effect/var effectsEffectPulsate = $.effects.define( "pulsate", "show", function( options, done ) {	var element = $( this ),		mode = options.mode,		show = mode === "show",		hide = mode === "hide",		showhide = show || hide,		// Showing or hiding leaves off the "last" animation		anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),		duration = options.duration / anims,		animateTo = 0,		i = 1,		queuelen = element.queue().length;	if ( show || !!element.is( ":visible" ) ) {		element.css( "opacity", 0 ).show();		animateTo = 1;	}	// Anims - 1 opacity "toggles"	for ( ; i < anims; i++ ) {		element.animate( { opacity: animateTo }, duration, options.easing );		animateTo = 1 - animateTo;	}	element.animate( { opacity: animateTo }, duration, options.easing );	element.queue( done );	$.effects.unshift( element, queuelen, anims + 1 );} );/*!! * jQuery UI Effects Shake 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Shake Effect//>>group: Effects//>>description: Shakes an element horizontally or vertically n times.//>>docs: http://api.jqueryui.com/shake-effect///>>demos: http://jqueryui.com/effect/var effectsEffectShake = $.effects.define( "shake", function( options, done ) {	var i = 1,		element = $( this ),		direction = options.direction || "left",		distance = options.distance || 20,		times = options.times || 3,		anims = times * 2 + 1,		speed = Math.round( options.duration / anims ),		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",		positiveMotion = ( direction === "up" || direction === "left" ),		animation = {},		animation1 = {},		animation2 = {},		queuelen = element.queue().length;	$.effects.createPlaceholder( element );	// Animation	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;	// Animate	element.animate( animation, speed, options.easing );	// Shakes	for ( ; i < times; i++ ) {		element			.animate( animation1, speed, options.easing )			.animate( animation2, speed, options.easing );	}	element		.animate( animation1, speed, options.easing )		.animate( animation, speed / 2, options.easing )		.queue( done );	$.effects.unshift( element, queuelen, anims + 1 );} );/*!! * jQuery UI Effects Slide 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Slide Effect//>>group: Effects//>>description: Slides an element in and out of the viewport.//>>docs: http://api.jqueryui.com/slide-effect///>>demos: http://jqueryui.com/effect/var effectsEffectSlide = $.effects.define( "slide", "show", function( options, done ) {	var startClip, startRef,		element = $( this ),		map = {			up: [ "bottom", "top" ],			down: [ "top", "bottom" ],			left: [ "right", "left" ],			right: [ "left", "right" ]		},		mode = options.mode,		direction = options.direction || "left",		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",		positiveMotion = ( direction === "up" || direction === "left" ),		distance = options.distance ||			element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ),		animation = {};	$.effects.createPlaceholder( element );	startClip = element.cssClip();	startRef = element.position()[ ref ];	// Define hide animation	animation[ ref ] = ( positiveMotion ? -1 : 1 ) * distance + startRef;	animation.clip = element.cssClip();	animation.clip[ map[ direction ][ 1 ] ] = animation.clip[ map[ direction ][ 0 ] ];	// Reverse the animation if we''re showing	if ( mode === "show" ) {		element.cssClip( animation.clip );		element.css( ref, animation[ ref ] );		animation.clip = startClip;		animation[ ref ] = startRef;	}	// Actually animate	element.animate( animation, {		queue: false,		duration: options.duration,		easing: options.easing,		complete: done	} );} );/*!! * jQuery UI Effects Transfer 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Transfer Effect//>>group: Effects//>>description: Displays a transfer effect from one element to another.//>>docs: http://api.jqueryui.com/transfer-effect///>>demos: http://jqueryui.com/effect/var effect;if ( $.uiBackCompat !!== false ) {	effect = $.effects.define( "transfer", function( options, done ) {		$( this ).transfer( options, done );	} );}var effectsEffectTransfer = effect;/*!! * jQuery UI Focusable 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: :focusable Selector//>>group: Core//>>description: Selects elements which can be focused.//>>docs: http://api.jqueryui.com/focusable-selector/// Selectors$.ui.focusable = function( element, hasTabindex ) {	var map, mapName, img, focusableIfVisible, fieldset,		nodeName = element.nodeName.toLowerCase();	if ( "area" === nodeName ) {		map = element.parentNode;		mapName = map.name;		if ( !!element.href || !!mapName || map.nodeName.toLowerCase() !!== "map" ) {			return false;		}		img = $( "img[usemap=''#" + mapName + "'']" );		return img.length > 0 && img.is( ":visible" );	}	if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {		focusableIfVisible = !!element.disabled;		if ( focusableIfVisible ) {			// Form controls within a disabled fieldset are disabled.			// However, controls within the fieldset''s legend do not get disabled.			// Since controls generally aren''t placed inside legends, we skip			// this portion of the check.			fieldset = $( element ).closest( "fieldset" )[ 0 ];			if ( fieldset ) {				focusableIfVisible = !!fieldset.disabled;			}		}	} else if ( "a" === nodeName ) {		focusableIfVisible = element.href || hasTabindex;	} else {		focusableIfVisible = hasTabindex;	}	return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );};// Support: IE 8 only// IE 8 doesn''t resolve inherit to visible/hidden for computed valuesfunction visible( element ) {	var visibility = element.css( "visibility" );	while ( visibility === "inherit" ) {		element = element.parent();		visibility = element.css( "visibility" );	}	return visibility === "visible";}$.extend( $.expr.pseudos, {	focusable: function( element ) {		return $.ui.focusable( element, $.attr( element, "tabindex" ) !!= null );	}} );var focusable = $.ui.focusable;// Support: IE8 Only// IE8 does not support the form attribute and when it is supplied. It overwrites the form prop// with a string, so we need to find the proper form.var form = $.fn._form = function() {	return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );};/*!! * jQuery UI Form Reset Mixin 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Form Reset Mixin//>>group: Core//>>description: Refresh input widgets when their form is reset//>>docs: http://api.jqueryui.com/form-reset-mixin/var formResetMixin = $.ui.formResetMixin = {	_formResetHandler: function() {		var form = $( this );		// Wait for the form reset to actually happen before refreshing		setTimeout( function() {			var instances = form.data( "ui-form-reset-instances" );			$.each( instances, function() {				this.refresh();			} );		} );	},	_bindFormResetHandler: function() {		this.form = this.element._form();		if ( !!this.form.length ) {			return;		}		var instances = this.form.data( "ui-form-reset-instances" ) || [];		if ( !!instances.length ) {			// We don''t use _on() here because we use a single event handler per form			this.form.on( "reset.ui-form-reset", this._formResetHandler );		}		instances.push( this );		this.form.data( "ui-form-reset-instances", instances );	},	_unbindFormResetHandler: function() {		if ( !!this.form.length ) {			return;		}		var instances = this.form.data( "ui-form-reset-instances" );		instances.splice( $.inArray( this, instances ), 1 );		if ( instances.length ) {			this.form.data( "ui-form-reset-instances", instances );		} else {			this.form				.removeData( "ui-form-reset-instances" )				.off( "reset.ui-form-reset" );		}	}};/*!! * jQuery UI Support for jQuery core 1.8.x and newer 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license * *///>>label: jQuery 1.8+ Support//>>group: Core//>>description: Support version 1.8.x and newer of jQuery core// Support: jQuery 1.9.x or older// $.expr[ ":" ] is deprecated.if ( !!$.expr.pseudos ) {	$.expr.pseudos = $.expr[ ":" ];}// Support: jQuery 1.11.x or older// $.unique has been renamed to $.uniqueSortif ( !!$.uniqueSort ) {	$.uniqueSort = $.unique;}// Support: jQuery 2.2.x or older.// This method has been defined in jQuery 3.0.0.// Code from https://github.com/jquery/jquery/blob/e539bac79e666bba95bba86d690b4e609dca2286/src/selector/escapeSelector.jsif ( !!$.escapeSelector ) {	// CSS string/identifier serialization	// https://drafts.csswg.org/cssom/#common-serializing-idioms	var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;	var fcssescape = function( ch, asCodePoint ) {		if ( asCodePoint ) {			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER			if ( ch === "\0" ) {				return "\uFFFD";			}			// Control characters and (dependent upon position) numbers get escaped as code points			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";		}		// Other potentially-special ASCII characters get backslash-escaped		return "\\" + ch;	};	$.escapeSelector = function( sel ) {		return ( sel + "" ).replace( rcssescape, fcssescape );	};}// Support: jQuery 3.4.x or older// These methods have been defined in jQuery 3.5.0.if ( !!$.fn.even || !!$.fn.odd ) {	$.fn.extend( {		even: function() {			return this.filter( function( i ) {				return i % 2 === 0;			} );		},		odd: function() {			return this.filter( function( i ) {				return i % 2 === 1;			} );		}	} );};/*!! * jQuery UI Keycode 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Keycode//>>group: Core//>>description: Provide keycodes as keynames//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/var keycode = $.ui.keyCode = {	BACKSPACE: 8,	COMMA: 188,	DELETE: 46,	DOWN: 40,	END: 35,	ENTER: 13,	ESCAPE: 27,	HOME: 36,	LEFT: 37,	PAGE_DOWN: 34,	PAGE_UP: 33,	PERIOD: 190,	RIGHT: 39,	SPACE: 32,	TAB: 9,	UP: 38};/*!! * jQuery UI Labels 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: labels//>>group: Core//>>description: Find all the labels associated with a given input//>>docs: http://api.jqueryui.com/labels/var labels = $.fn.labels = function() {	var ancestor, selector, id, labels, ancestors;	if ( !!this.length ) {		return this.pushStack( [] );	}	// Check control.labels first	if ( this[ 0 ].labels && this[ 0 ].labels.length ) {		return this.pushStack( this[ 0 ].labels );	}	// Support: IE <= 11, FF <= 37, Android <= 2.3 only	// Above browsers do not support control.labels. Everything below is to support them	// as well as document fragments. control.labels does not work on document fragments	labels = this.eq( 0 ).parents( "label" );	// Look for the label based on the id	id = this.attr( "id" );	if ( id ) {		// We don''t search against the document in case the element		// is disconnected from the DOM		ancestor = this.eq( 0 ).parents().last();		// Get a full set of top level ancestors		ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );		// Create a selector for the label based on the id		selector = "label[for=''" + $.escapeSelector( id ) + "'']";		labels = labels.add( ancestors.find( selector ).addBack( selector ) );	}	// Return whatever we have found for labels	return this.pushStack( labels );};/*!! * jQuery UI Scroll Parent 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: scrollParent//>>group: Core//>>description: Get the closest ancestor element that is scrollable.//>>docs: http://api.jqueryui.com/scrollParent/var scrollParent = $.fn.scrollParent = function( includeHidden ) {	var position = this.css( "position" ),		excludeStaticParent = position === "absolute",		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,		scrollParent = this.parents().filter( function() {			var parent = $( this );			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {				return false;			}			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +				parent.css( "overflow-x" ) );		} ).eq( 0 );	return position === "fixed" || !!scrollParent.length ?		$( this[ 0 ].ownerDocument || document ) :		scrollParent;};/*!! * jQuery UI Tabbable 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: :tabbable Selector//>>group: Core//>>description: Selects elements which can be tabbed to.//>>docs: http://api.jqueryui.com/tabbable-selector/var tabbable = $.extend( $.expr.pseudos, {	tabbable: function( element ) {		var tabIndex = $.attr( element, "tabindex" ),			hasTabindex = tabIndex !!= null;		return ( !!hasTabindex || tabIndex >= 0 ) && $.ui.focusable( element, hasTabindex );	}} );/*!! * jQuery UI Unique ID 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: uniqueId//>>group: Core//>>description: Functions to generate and remove uniqueId''s//>>docs: http://api.jqueryui.com/uniqueId/var uniqueId = $.fn.extend( {	uniqueId: ( function() {		var uuid = 0;		return function() {			return this.each( function() {				if ( !!this.id ) {					this.id = "ui-id-" + ( ++uuid );				}			} );		};	} )(),	removeUniqueId: function() {		return this.each( function() {			if ( /^ui-id-\d+$/.test( this.id ) ) {				$( this ).removeAttr( "id" );			}		} );	}} );/*!! * jQuery UI Accordion 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Accordion//>>group: Widgets/* eslint-disable max-len *///>>description: Displays collapsible content panels for presenting information in a limited amount of space./* eslint-enable max-len *///>>docs: http://api.jqueryui.com/accordion///>>demos: http://jqueryui.com/accordion///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/accordion.css//>>css.theme: ../../themes/base/theme.cssvar widgetsAccordion = $.widget( "ui.accordion", {	version: "1.13.2",	options: {		active: 0,		animate: {},		classes: {			"ui-accordion-header": "ui-corner-top",			"ui-accordion-header-collapsed": "ui-corner-all",			"ui-accordion-content": "ui-corner-bottom"		},		collapsible: false,		event: "click",		header: function( elem ) {			return elem.find( "> li > :first-child" ).add( elem.find( "> :not(li)" ).even() );		},		heightStyle: "auto",		icons: {			activeHeader: "ui-icon-triangle-1-s",			header: "ui-icon-triangle-1-e"		},		// Callbacks		activate: null,		beforeActivate: null	},	hideProps: {		borderTopWidth: "hide",		borderBottomWidth: "hide",		paddingTop: "hide",		paddingBottom: "hide",		height: "hide"	},	showProps: {		borderTopWidth: "show",		borderBottomWidth: "show",		paddingTop: "show",		paddingBottom: "show",		height: "show"	},	_create: function() {		var options = this.options;		this.prevShow = this.prevHide = $();		this._addClass( "ui-accordion", "ui-widget ui-helper-reset" );		this.element.attr( "role", "tablist" );		// Don''t allow collapsible: false and active: false / null		if ( !!options.collapsible && ( options.active === false || options.active == null ) ) {			options.active = 0;		}		this._processPanels();		// handle negative values		if ( options.active < 0 ) {			options.active += this.headers.length;		}		this._refresh();	},	_getCreateEventData: function() {		return {			header: this.active,			panel: !!this.active.length ? $() : this.active.next()		};	},	_createIcons: function() {		var icon, children,			icons = this.options.icons;		if ( icons ) {			icon = $( "<span>" );			this._addClass( icon, "ui-accordion-header-icon", "ui-icon " + icons.header );			icon.prependTo( this.headers );			children = this.active.children( ".ui-accordion-header-icon" );			this._removeClass( children, icons.header )				._addClass( children, null, icons.activeHeader )				._addClass( this.headers, "ui-accordion-icons" );		}	},	_destroyIcons: function() {		this._removeClass( this.headers, "ui-accordion-icons" );		this.headers.children( ".ui-accordion-header-icon" ).remove();	},	_destroy: function() {		var contents;		// Clean up main element		this.element.removeAttr( "role" );		// Clean up headers		this.headers			.removeAttr( "role aria-expanded aria-selected aria-controls tabIndex" )			.removeUniqueId();		this._destroyIcons();		// Clean up content panels		contents = this.headers.next()			.css( "display", "" )			.removeAttr( "role aria-hidden aria-labelledby" )			.removeUniqueId();		if ( this.options.heightStyle !!== "content" ) {			contents.css( "height", "" );		}	},	_setOption: function( key, value ) {		if ( key === "active" ) {			// _activate() will handle invalid values and update this.options			this._activate( value );			return;		}		if ( key === "event" ) {			if ( this.options.event ) {				this._off( this.headers, this.options.event );			}			this._setupEvents( value );		}		this._super( key, value );		// Setting collapsible: false while collapsed; open first panel		if ( key === "collapsible" && !!value && this.options.active === false ) {			this._activate( 0 );		}		if ( key === "icons" ) {			this._destroyIcons();			if ( value ) {				this._createIcons();			}		}	},	_setOptionDisabled: function( value ) {		this._super( value );		this.element.attr( "aria-disabled", value );		// Support: IE8 Only		// #5332 / #6059 - opacity doesn''t cascade to positioned elements in IE		// so we need to add the disabled class to the headers and panels		this._toggleClass( null, "ui-state-disabled", !!!!value );		this._toggleClass( this.headers.add( this.headers.next() ), null, "ui-state-disabled",			!!!!value );	},	_keydown: function( event ) {		if ( event.altKey || event.ctrlKey ) {			return;		}		var keyCode = $.ui.keyCode,			length = this.headers.length,			currentIndex = this.headers.index( event.target ),			toFocus = false;		switch ( event.keyCode ) {		case keyCode.RIGHT:		case keyCode.DOWN:			toFocus = this.headers[ ( currentIndex + 1 ) % length ];			break;		case keyCode.LEFT:		case keyCode.UP:			toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];			break;		case keyCode.SPACE:		case keyCode.ENTER:			this._eventHandler( event );			break;		case keyCode.HOME:			toFocus = this.headers[ 0 ];			break;		case keyCode.END:			toFocus = this.headers[ length - 1 ];			break;		}		if ( toFocus ) {			$( event.target ).attr( "tabIndex", -1 );			$( toFocus ).attr( "tabIndex", 0 );			$( toFocus ).trigger( "focus" );			event.preventDefault();		}	},	_panelKeyDown: function( event ) {		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {			$( event.currentTarget ).prev().trigger( "focus" );		}	},	refresh: function() {		var options = this.options;		this._processPanels();		// Was collapsed or no panel		if ( ( options.active === false && options.collapsible === true ) ||				!!this.headers.length ) {			options.active = false;			this.active = $();		// active false only when collapsible is true		} else if ( options.active === false ) {			this._activate( 0 );		// was active, but active panel is gone		} else if ( this.active.length && !!$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {			// all remaining panel are disabled			if ( this.headers.length === this.headers.find( ".ui-state-disabled" ).length ) {				options.active = false;				this.active = $();			// activate previous panel			} else {				this._activate( Math.max( 0, options.active - 1 ) );			}		// was active, active panel still exists		} else {			// make sure active index is correct			options.active = this.headers.index( this.active );		}		this._destroyIcons();		this._refresh();	},	_processPanels: function() {		var prevHeaders = this.headers,			prevPanels = this.panels;		if ( typeof this.options.header === "function" ) {			this.headers = this.options.header( this.element );		} else {			this.headers = this.element.find( this.options.header );		}		this._addClass( this.headers, "ui-accordion-header ui-accordion-header-collapsed",			"ui-state-default" );		this.panels = this.headers.next().filter( ":not(.ui-accordion-content-active)" ).hide();		this._addClass( this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content" );		// Avoid memory leaks (#10056)		if ( prevPanels ) {			this._off( prevHeaders.not( this.headers ) );			this._off( prevPanels.not( this.panels ) );		}	},	_refresh: function() {		var maxHeight,			options = this.options,			heightStyle = options.heightStyle,			parent = this.element.parent();		this.active = this._findActive( options.active );		this._addClass( this.active, "ui-accordion-header-active", "ui-state-active" )			._removeClass( this.active, "ui-accordion-header-collapsed" );		this._addClass( this.active.next(), "ui-accordion-content-active" );		this.active.next().show();		this.headers			.attr( "role", "tab" )			.each( function() {				var header = $( this ),					headerId = header.uniqueId().attr( "id" ),					panel = header.next(),					panelId = panel.uniqueId().attr( "id" );				header.attr( "aria-controls", panelId );				panel.attr( "aria-labelledby", headerId );			} )			.next()				.attr( "role", "tabpanel" );		this.headers			.not( this.active )				.attr( {					"aria-selected": "false",					"aria-expanded": "false",					tabIndex: -1				} )				.next()					.attr( {						"aria-hidden": "true"					} )					.hide();		// Make sure at least one header is in the tab order		if ( !!this.active.length ) {			this.headers.eq( 0 ).attr( "tabIndex", 0 );		} else {			this.active.attr( {				"aria-selected": "true",				"aria-expanded": "true",				tabIndex: 0			} )				.next()					.attr( {						"aria-hidden": "false"					} );		}		this._createIcons();		this._setupEvents( options.event );		if ( heightStyle === "fill" ) {			maxHeight = parent.height();			this.element.siblings( ":visible" ).each( function() {				var elem = $( this ),					position = elem.css( "position" );				if ( position === "absolute" || position === "fixed" ) {					return;				}				maxHeight -= elem.outerHeight( true );			} );			this.headers.each( function() {				maxHeight -= $( this ).outerHeight( true );			} );			this.headers.next()				.each( function() {					$( this ).height( Math.max( 0, maxHeight -						$( this ).innerHeight() + $( this ).height() ) );				} )				.css( "overflow", "auto" );		} else if ( heightStyle === "auto" ) {			maxHeight = 0;			this.headers.next()				.each( function() {					var isVisible = $( this ).is( ":visible" );					if ( !!isVisible ) {						$( this ).show();					}					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );					if ( !!isVisible ) {						$( this ).hide();					}				} )				.height( maxHeight );		}	},	_activate: function( index ) {		var active = this._findActive( index )[ 0 ];		// Trying to activate the already active panel		if ( active === this.active[ 0 ] ) {			return;		}		// Trying to collapse, simulate a click on the currently active header		active = active || this.active[ 0 ];		this._eventHandler( {			target: active,			currentTarget: active,			preventDefault: $.noop		} );	},	_findActive: function( selector ) {		return typeof selector === "number" ? this.headers.eq( selector ) : $();	},	_setupEvents: function( event ) {		var events = {			keydown: "_keydown"		};		if ( event ) {			$.each( event.split( " " ), function( index, eventName ) {				events[ eventName ] = "_eventHandler";			} );		}		this._off( this.headers.add( this.headers.next() ) );		this._on( this.headers, events );		this._on( this.headers.next(), { keydown: "_panelKeyDown" } );		this._hoverable( this.headers );		this._focusable( this.headers );	},	_eventHandler: function( event ) {		var activeChildren, clickedChildren,			options = this.options,			active = this.active,			clicked = $( event.currentTarget ),			clickedIsActive = clicked[ 0 ] === active[ 0 ],			collapsing = clickedIsActive && options.collapsible,			toShow = collapsing ? $() : clicked.next(),			toHide = active.next(),			eventData = {				oldHeader: active,				oldPanel: toHide,				newHeader: collapsing ? $() : clicked,				newPanel: toShow			};		event.preventDefault();		if (				// click on active header, but not collapsible				( clickedIsActive && !!options.collapsible ) ||				// allow canceling activation				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {			return;		}		options.active = collapsing ? false : this.headers.index( clicked );		// When the call to ._toggle() comes after the class changes		// it causes a very odd bug in IE 8 (see #6720)		this.active = clickedIsActive ? $() : clicked;		this._toggle( eventData );		// Switch classes		// corner classes on the previously active header stay after the animation		this._removeClass( active, "ui-accordion-header-active", "ui-state-active" );		if ( options.icons ) {			activeChildren = active.children( ".ui-accordion-header-icon" );			this._removeClass( activeChildren, null, options.icons.activeHeader )				._addClass( activeChildren, null, options.icons.header );		}		if ( !!clickedIsActive ) {			this._removeClass( clicked, "ui-accordion-header-collapsed" )				._addClass( clicked, "ui-accordion-header-active", "ui-state-active" );			if ( options.icons ) {				clickedChildren = clicked.children( ".ui-accordion-header-icon" );				this._removeClass( clickedChildren, null, options.icons.header )					._addClass( clickedChildren, null, options.icons.activeHeader );			}			this._addClass( clicked.next(), "ui-accordion-content-active" );		}	},	_toggle: function( data ) {		var toShow = data.newPanel,			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;		// Handle activating a panel during the animation for another activation		this.prevShow.add( this.prevHide ).stop( true, true );		this.prevShow = toShow;		this.prevHide = toHide;		if ( this.options.animate ) {			this._animate( toShow, toHide, data );		} else {			toHide.hide();			toShow.show();			this._toggleComplete( data );		}		toHide.attr( {			"aria-hidden": "true"		} );		toHide.prev().attr( {			"aria-selected": "false",			"aria-expanded": "false"		} );		// if we''re switching panels, remove the old header from the tab order		// if we''re opening from collapsed state, remove the previous header from the tab order		// if we''re collapsing, then keep the collapsing header in the tab order		if ( toShow.length && toHide.length ) {			toHide.prev().attr( {				"tabIndex": -1,				"aria-expanded": "false"			} );		} else if ( toShow.length ) {			this.headers.filter( function() {				return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;			} )				.attr( "tabIndex", -1 );		}		toShow			.attr( "aria-hidden", "false" )			.prev()				.attr( {					"aria-selected": "true",					"aria-expanded": "true",					tabIndex: 0				} );	},	_animate: function( toShow, toHide, data ) {		var total, easing, duration,			that = this,			adjust = 0,			boxSizing = toShow.css( "box-sizing" ),			down = toShow.length &&				( !!toHide.length || ( toShow.index() < toHide.index() ) ),			animate = this.options.animate || {},			options = down && animate.down || animate,			complete = function() {				that._toggleComplete( data );			};		if ( typeof options === "number" ) {			duration = options;		}		if ( typeof options === "string" ) {			easing = options;		}		// fall back from options to animation in case of partial down settings		easing = easing || options.easing || animate.easing;		duration = duration || options.duration || animate.duration;		if ( !!toHide.length ) {			return toShow.animate( this.showProps, duration, easing, complete );		}		if ( !!toShow.length ) {			return toHide.animate( this.hideProps, duration, easing, complete );		}		total = toShow.show().outerHeight();		toHide.animate( this.hideProps, {			duration: duration,			easing: easing,			step: function( now, fx ) {				fx.now = Math.round( now );			}		} );		toShow			.hide()			.animate( this.showProps, {				duration: duration,				easing: easing,				complete: complete,				step: function( now, fx ) {					fx.now = Math.round( now );					if ( fx.prop !!== "height" ) {						if ( boxSizing === "content-box" ) {							adjust += fx.now;						}					} else if ( that.options.heightStyle !!== "content" ) {						fx.now = Math.round( total - toHide.outerHeight() - adjust );						adjust = 0;					}				}			} );	},	_toggleComplete: function( data ) {		var toHide = data.oldPanel,			prev = toHide.prev();		this._removeClass( toHide, "ui-accordion-content-active" );		this._removeClass( prev, "ui-accordion-header-active" )			._addClass( prev, "ui-accordion-header-collapsed" );		// Work around for rendering bug in IE (#5421)		if ( toHide.length ) {			toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;		}		this._trigger( "activate", null, data );	}} );var safeActiveElement = $.ui.safeActiveElement = function( document ) {	var activeElement;	// Support: IE 9 only	// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>	try {		activeElement = document.activeElement;	} catch ( error ) {		activeElement = document.body;	}	// Support: IE 9 - 11 only	// IE may return null instead of an element	// Interestingly, this only seems to occur when NOT in an iframe	if ( !!activeElement ) {		activeElement = document.body;	}	// Support: IE 11 only	// IE11 returns a seemingly empty object in some cases when accessing	// document.activeElement from an <iframe>	if ( !!activeElement.nodeName ) {		activeElement = document.body;	}	return activeElement;};/*!! * jQuery UI Menu 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Menu//>>group: Widgets//>>description: Creates nestable menus.//>>docs: http://api.jqueryui.com/menu///>>demos: http://jqueryui.com/menu///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/menu.css//>>css.theme: ../../themes/base/theme.cssvar widgetsMenu = $.widget( "ui.menu", {	version: "1.13.2",	defaultElement: "<ul>",	delay: 300,	options: {		icons: {			submenu: "ui-icon-caret-1-e"		},		items: "> *",		menus: "ul",		position: {			my: "left top",			at: "right top"		},		role: "menu",		// Callbacks		blur: null,		focus: null,		select: null	},	_create: function() {		this.activeMenu = this.element;		// Flag used to prevent firing of the click handler		// as the event bubbles up through nested menus		this.mouseHandled = false;		this.lastMousePosition = { x: null, y: null };		this.element			.uniqueId()			.attr( {				role: this.options.role,				tabIndex: 0			} );		this._addClass( "ui-menu", "ui-widget ui-widget-content" );		this._on( {			// Prevent focus from sticking to links inside menu after clicking			// them (focus should always stay on UL during navigation).			"mousedown .ui-menu-item": function( event ) {				event.preventDefault();				this._activateItem( event );			},			"click .ui-menu-item": function( event ) {				var target = $( event.target );				var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) );				if ( !!this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {					this.select( event );					// Only set the mouseHandled flag if the event will bubble, see #9469.					if ( !!event.isPropagationStopped() ) {						this.mouseHandled = true;					}					// Open submenu on click					if ( target.has( ".ui-menu" ).length ) {						this.expand( event );					} else if ( !!this.element.is( ":focus" ) &&							active.closest( ".ui-menu" ).length ) {						// Redirect focus to the menu						this.element.trigger( "focus", [ true ] );						// If the active item is on the top level, let it stay active.						// Otherwise, blur the active item since it is no longer visible.						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {							clearTimeout( this.timer );						}					}				}			},			"mouseenter .ui-menu-item": "_activateItem",			"mousemove .ui-menu-item": "_activateItem",			mouseleave: "collapseAll",			"mouseleave .ui-menu": "collapseAll",			focus: function( event, keepActiveItem ) {				// If there''s already an active item, keep it active				// If not, activate the first item				var item = this.active || this._menuItems().first();				if ( !!keepActiveItem ) {					this.focus( event, item );				}			},			blur: function( event ) {				this._delay( function() {					var notContained = !!$.contains(						this.element[ 0 ],						$.ui.safeActiveElement( this.document[ 0 ] )					);					if ( notContained ) {						this.collapseAll( event );					}				} );			},			keydown: "_keydown"		} );		this.refresh();		// Clicks outside of a menu collapse any open menus		this._on( this.document, {			click: function( event ) {				if ( this._closeOnDocumentClick( event ) ) {					this.collapseAll( event, true );				}				// Reset the mouseHandled flag				this.mouseHandled = false;			}		} );	},	_activateItem: function( event ) {		// Ignore mouse events while typeahead is active, see #10458.		// Prevents focusing the wrong item when typeahead causes a scroll while the mouse		// is over an item in the menu		if ( this.previousFilter ) {			return;		}		// If the mouse didn''t actually move, but the page was scrolled, ignore the event (#9356)		if ( event.clientX === this.lastMousePosition.x &&				event.clientY === this.lastMousePosition.y ) {			return;		}		this.lastMousePosition = {			x: event.clientX,			y: event.clientY		};		var actualTarget = $( event.target ).closest( ".ui-menu-item" ),			target = $( event.currentTarget );		// Ignore bubbled events on parent items, see #11641		if ( actualTarget[ 0 ] !!== target[ 0 ] ) {			return;		}		// If the item is already active, there''s nothing to do		if ( target.is( ".ui-state-active" ) ) {			return;		}		// Remove ui-state-active class from siblings of the newly focused menu item		// to avoid a jump caused by adjacent elements both having a class with a border		this._removeClass( target.siblings().children( ".ui-state-active" ),			null, "ui-state-active" );		this.focus( event, target );	},	_destroy: function() {		var items = this.element.find( ".ui-menu-item" )				.removeAttr( "role aria-disabled" ),			submenus = items.children( ".ui-menu-item-wrapper" )				.removeUniqueId()				.removeAttr( "tabIndex role aria-haspopup" );		// Destroy (sub)menus		this.element			.removeAttr( "aria-activedescendant" )			.find( ".ui-menu" ).addBack()				.removeAttr( "role aria-labelledby aria-expanded aria-hidden aria-disabled " +					"tabIndex" )				.removeUniqueId()				.show();		submenus.children().each( function() {			var elem = $( this );			if ( elem.data( "ui-menu-submenu-caret" ) ) {				elem.remove();			}		} );	},	_keydown: function( event ) {		var match, prev, character, skip,			preventDefault = true;		switch ( event.keyCode ) {		case $.ui.keyCode.PAGE_UP:			this.previousPage( event );			break;		case $.ui.keyCode.PAGE_DOWN:			this.nextPage( event );			break;		case $.ui.keyCode.HOME:			this._move( "first", "first", event );			break;		case $.ui.keyCode.END:			this._move( "last", "last", event );			break;		case $.ui.keyCode.UP:			this.previous( event );			break;		case $.ui.keyCode.DOWN:			this.next( event );			break;		case $.ui.keyCode.LEFT:			this.collapse( event );			break;		case $.ui.keyCode.RIGHT:			if ( this.active && !!this.active.is( ".ui-state-disabled" ) ) {				this.expand( event );			}			break;		case $.ui.keyCode.ENTER:		case $.ui.keyCode.SPACE:			this._activate( event );			break;		case $.ui.keyCode.ESCAPE:			this.collapse( event );			break;		default:			preventDefault = false;			prev = this.previousFilter || "";			skip = false;			// Support number pad values			character = event.keyCode >= 96 && event.keyCode <= 105 ?				( event.keyCode - 96 ).toString() : String.fromCharCode( event.keyCode );			clearTimeout( this.filterTimer );			if ( character === prev ) {				skip = true;			} else {				character = prev + character;			}			match = this._filterMenuItems( character );			match = skip && match.index( this.active.next() ) !!== -1 ?				this.active.nextAll( ".ui-menu-item" ) :				match;			// If no matches on the current filter, reset to the last character pressed			// to move down the menu to the first item that starts with that character			if ( !!match.length ) {				character = String.fromCharCode( event.keyCode );				match = this._filterMenuItems( character );			}			if ( match.length ) {				this.focus( event, match );				this.previousFilter = character;				this.filterTimer = this._delay( function() {					delete this.previousFilter;				}, 1000 );			} else {				delete this.previousFilter;			}		}		if ( preventDefault ) {			event.preventDefault();		}	},	_activate: function( event ) {		if ( this.active && !!this.active.is( ".ui-state-disabled" ) ) {			if ( this.active.children( "[aria-haspopup=''true'']" ).length ) {				this.expand( event );			} else {				this.select( event );			}		}	},	refresh: function() {		var menus, items, newSubmenus, newItems, newWrappers,			that = this,			icon = this.options.icons.submenu,			submenus = this.element.find( this.options.menus );		this._toggleClass( "ui-menu-icons", null, !!!!this.element.find( ".ui-icon" ).length );		// Initialize nested menus		newSubmenus = submenus.filter( ":not(.ui-menu)" )			.hide()			.attr( {				role: this.options.role,				"aria-hidden": "true",				"aria-expanded": "false"			} )			.each( function() {				var menu = $( this ),					item = menu.prev(),					submenuCaret = $( "<span>" ).data( "ui-menu-submenu-caret", true );				that._addClass( submenuCaret, "ui-menu-icon", "ui-icon " + icon );				item					.attr( "aria-haspopup", "true" )					.prepend( submenuCaret );				menu.attr( "aria-labelledby", item.attr( "id" ) );			} );		this._addClass( newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front" );		menus = submenus.add( this.element );		items = menus.find( this.options.items );		// Initialize menu-items containing spaces and/or dashes only as dividers		items.not( ".ui-menu-item" ).each( function() {			var item = $( this );			if ( that._isDivider( item ) ) {				that._addClass( item, "ui-menu-divider", "ui-widget-content" );			}		} );		// Don''t refresh list items that are already adapted		newItems = items.not( ".ui-menu-item, .ui-menu-divider" );		newWrappers = newItems.children()			.not( ".ui-menu" )				.uniqueId()				.attr( {					tabIndex: -1,					role: this._itemRole()				} );		this._addClass( newItems, "ui-menu-item" )			._addClass( newWrappers, "ui-menu-item-wrapper" );		// Add aria-disabled attribute to any disabled menu item		items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );		// If the active item has been removed, blur the menu		if ( this.active && !!$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {			this.blur();		}	},	_itemRole: function() {		return {			menu: "menuitem",			listbox: "option"		}[ this.options.role ];	},	_setOption: function( key, value ) {		if ( key === "icons" ) {			var icons = this.element.find( ".ui-menu-icon" );			this._removeClass( icons, null, this.options.icons.submenu )				._addClass( icons, null, value.submenu );		}		this._super( key, value );	},	_setOptionDisabled: function( value ) {		this._super( value );		this.element.attr( "aria-disabled", String( value ) );		this._toggleClass( null, "ui-state-disabled", !!!!value );	},	focus: function( event, item ) {		var nested, focused, activeParent;		this.blur( event, event && event.type === "focus" );		this._scrollIntoView( item );		this.active = item.first();		focused = this.active.children( ".ui-menu-item-wrapper" );		this._addClass( focused, null, "ui-state-active" );		// Only update aria-activedescendant if there''s a role		// otherwise we assume focus is managed elsewhere		if ( this.options.role ) {			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );		}		// Highlight active parent menu item, if any		activeParent = this.active			.parent()				.closest( ".ui-menu-item" )					.children( ".ui-menu-item-wrapper" );		this._addClass( activeParent, null, "ui-state-active" );		if ( event && event.type === "keydown" ) {			this._close();		} else {			this.timer = this._delay( function() {				this._close();			}, this.delay );		}		nested = item.children( ".ui-menu" );		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {			this._startOpening( nested );		}		this.activeMenu = item.parent();		this._trigger( "focus", event, { item: item } );	},	_scrollIntoView: function( item ) {		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;		if ( this._hasScroll() ) {			borderTop = parseFloat( $.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0;			paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0;			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;			scroll = this.activeMenu.scrollTop();			elementHeight = this.activeMenu.height();			itemHeight = item.outerHeight();			if ( offset < 0 ) {				this.activeMenu.scrollTop( scroll + offset );			} else if ( offset + itemHeight > elementHeight ) {				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );			}		}	},	blur: function( event, fromFocus ) {		if ( !!fromFocus ) {			clearTimeout( this.timer );		}		if ( !!this.active ) {			return;		}		this._removeClass( this.active.children( ".ui-menu-item-wrapper" ),			null, "ui-state-active" );		this._trigger( "blur", event, { item: this.active } );		this.active = null;	},	_startOpening: function( submenu ) {		clearTimeout( this.timer );		// Don''t open if already open fixes a Firefox bug that caused a .5 pixel		// shift in the submenu position when mousing over the caret icon		if ( submenu.attr( "aria-hidden" ) !!== "true" ) {			return;		}		this.timer = this._delay( function() {			this._close();			this._open( submenu );		}, this.delay );	},	_open: function( submenu ) {		var position = $.extend( {			of: this.active		}, this.options.position );		clearTimeout( this.timer );		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )			.hide()			.attr( "aria-hidden", "true" );		submenu			.show()			.removeAttr( "aria-hidden" )			.attr( "aria-expanded", "true" )			.position( position );	},	collapseAll: function( event, all ) {		clearTimeout( this.timer );		this.timer = this._delay( function() {			// If we were passed an event, look for the submenu that contains the event			var currentMenu = all ? this.element :				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );			// If we found no valid submenu ancestor, use the main menu to close all			// sub menus anyway			if ( !!currentMenu.length ) {				currentMenu = this.element;			}			this._close( currentMenu );			this.blur( event );			// Work around active item staying active after menu is blurred			this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" );			this.activeMenu = currentMenu;		}, all ? 0 : this.delay );	},	// With no arguments, closes the currently active menu - if nothing is active	// it closes all menus.  If passed an argument, it will search for menus BELOW	_close: function( startMenu ) {		if ( !!startMenu ) {			startMenu = this.active ? this.active.parent() : this.element;		}		startMenu.find( ".ui-menu" )			.hide()			.attr( "aria-hidden", "true" )			.attr( "aria-expanded", "false" );	},	_closeOnDocumentClick: function( event ) {		return !!$( event.target ).closest( ".ui-menu" ).length;	},	_isDivider: function( item ) {		// Match hyphen, em dash, en dash		return !!/[^\-\u2014\u2013\s]/.test( item.text() );	},	collapse: function( event ) {		var newItem = this.active &&			this.active.parent().closest( ".ui-menu-item", this.element );		if ( newItem && newItem.length ) {			this._close();			this.focus( event, newItem );		}	},	expand: function( event ) {		var newItem = this.active && this._menuItems( this.active.children( ".ui-menu" ) ).first();		if ( newItem && newItem.length ) {			this._open( newItem.parent() );			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT			this._delay( function() {				this.focus( event, newItem );			} );		}	},	next: function( event ) {		this._move( "next", "first", event );	},	previous: function( event ) {		this._move( "prev", "last", event );	},	isFirstItem: function() {		return this.active && !!this.active.prevAll( ".ui-menu-item" ).length;	},	isLastItem: function() {		return this.active && !!this.active.nextAll( ".ui-menu-item" ).length;	},	_menuItems: function( menu ) {		return ( menu || this.element )			.find( this.options.items )			.filter( ".ui-menu-item" );	},	_move: function( direction, filter, event ) {		var next;		if ( this.active ) {			if ( direction === "first" || direction === "last" ) {				next = this.active					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )					.last();			} else {				next = this.active					[ direction + "All" ]( ".ui-menu-item" )					.first();			}		}		if ( !!next || !!next.length || !!this.active ) {			next = this._menuItems( this.activeMenu )[ filter ]();		}		this.focus( event, next );	},	nextPage: function( event ) {		var item, base, height;		if ( !!this.active ) {			this.next( event );			return;		}		if ( this.isLastItem() ) {			return;		}		if ( this._hasScroll() ) {			base = this.active.offset().top;			height = this.element.innerHeight();			// jQuery 3.2 doesn''t include scrollbars in innerHeight, add it back.			if ( $.fn.jquery.indexOf( "3.2." ) === 0 ) {				height += this.element[ 0 ].offsetHeight - this.element.outerHeight();			}			this.active.nextAll( ".ui-menu-item" ).each( function() {				item = $( this );				return item.offset().top - base - height < 0;			} );			this.focus( event, item );		} else {			this.focus( event, this._menuItems( this.activeMenu )				[ !!this.active ? "first" : "last" ]() );		}	},	previousPage: function( event ) {		var item, base, height;		if ( !!this.active ) {			this.next( event );			return;		}		if ( this.isFirstItem() ) {			return;		}		if ( this._hasScroll() ) {			base = this.active.offset().top;			height = this.element.innerHeight();			// jQuery 3.2 doesn''t include scrollbars in innerHeight, add it back.			if ( $.fn.jquery.indexOf( "3.2." ) === 0 ) {				height += this.element[ 0 ].offsetHeight - this.element.outerHeight();			}			this.active.prevAll( ".ui-menu-item" ).each( function() {				item = $( this );				return item.offset().top - base + height > 0;			} );			this.focus( event, item );		} else {			this.focus( event, this._menuItems( this.activeMenu ).first() );		}	},	_hasScroll: function() {		return this.element.outerHeight() < this.element.prop( "scrollHeight" );	},	select: function( event ) {		// TODO: It should never be possible to not have an active item at this		// point, but the tests don''t trigger mouseenter before click.		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );		var ui = { item: this.active };		if ( !!this.active.has( ".ui-menu" ).length ) {			this.collapseAll( event, true );		}		this._trigger( "select", event, ui );	},	_filterMenuItems: function( character ) {		var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),			regex = new RegExp( "^" + escapedCharacter, "i" );		return this.activeMenu			.find( this.options.items )				// Only match on items, not dividers or other content (#10571)				.filter( ".ui-menu-item" )					.filter( function() {						return regex.test(							String.prototype.trim.call(								$( this ).children( ".ui-menu-item-wrapper" ).text() ) );					} );	}} );/*!! * jQuery UI Autocomplete 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Autocomplete//>>group: Widgets//>>description: Lists suggested words as the user is typing.//>>docs: http://api.jqueryui.com/autocomplete///>>demos: http://jqueryui.com/autocomplete///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/autocomplete.css//>>css.theme: ../../themes/base/theme.css$.widget( "ui.autocomplete", {	version: "1.13.2",	defaultElement: "<input>",	options: {		appendTo: null,		autoFocus: false,		delay: 300,		minLength: 1,		position: {			my: "left top",			at: "left bottom",			collision: "none"		},		source: null,		// Callbacks		change: null,		close: null,		focus: null,		open: null,		response: null,		search: null,		select: null	},	requestIndex: 0,	pending: 0,	liveRegionTimer: null,	_create: function() {		// Some browsers only repeat keydown events, not keypress events,		// so we use the suppressKeyPress flag to determine if we''ve already		// handled the keydown event. #7269		// Unfortunately the code for & in keypress is the same as the up arrow,		// so we use the suppressKeyPressRepeat flag to avoid handling keypress		// events when we know the keydown event was used to modify the		// search term. #7799		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,			nodeName = this.element[ 0 ].nodeName.toLowerCase(),			isTextarea = nodeName === "textarea",			isInput = nodeName === "input";		// Textareas are always multi-line		// Inputs are always single-line, even if inside a contentEditable element		// IE also treats inputs as contentEditable		// All other element types are determined by whether or not they''re contentEditable		this.isMultiLine = isTextarea || !!isInput && this._isContentEditable( this.element );		this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];		this.isNewMenu = true;		this._addClass( "ui-autocomplete-input" );		this.element.attr( "autocomplete", "off" );		this._on( this.element, {			keydown: function( event ) {				if ( this.element.prop( "readOnly" ) ) {					suppressKeyPress = true;					suppressInput = true;					suppressKeyPressRepeat = true;					return;				}				suppressKeyPress = false;				suppressInput = false;				suppressKeyPressRepeat = false;				var keyCode = $.ui.keyCode;				switch ( event.keyCode ) {				case keyCode.PAGE_UP:					suppressKeyPress = true;					this._move( "previousPage", event );					break;				case keyCode.PAGE_DOWN:					suppressKeyPress = true;					this._move( "nextPage", event );					break;				case keyCode.UP:					suppressKeyPress = true;					this._keyEvent( "previous", event );					break;				case keyCode.DOWN:					suppressKeyPress = true;					this._keyEvent( "next", event );					break;				case keyCode.ENTER:					// when menu is open and has focus					if ( this.menu.active ) {						// #6055 - Opera still allows the keypress to occur						// which causes forms to submit						suppressKeyPress = true;						event.preventDefault();						this.menu.select( event );					}					break;				case keyCode.TAB:					if ( this.menu.active ) {						this.menu.select( event );					}					break;				case keyCode.ESCAPE:					if ( this.menu.element.is( ":visible" ) ) {						if ( !!this.isMultiLine ) {							this._value( this.term );						}						this.close( event );						// Different browsers have different default behavior for escape						// Single press can mean undo or clear						// Double press in IE means clear the whole form						event.preventDefault();					}					break;				default:					suppressKeyPressRepeat = true;					// search timeout should be triggered before the input value is changed					this._searchTimeout( event );					break;				}			},			keypress: function( event ) {				if ( suppressKeyPress ) {					suppressKeyPress = false;					if ( !!this.isMultiLine || this.menu.element.is( ":visible" ) ) {						event.preventDefault();					}					return;				}				if ( suppressKeyPressRepeat ) {					return;				}				// Replicate some key handlers to allow them to repeat in Firefox and Opera				var keyCode = $.ui.keyCode;				switch ( event.keyCode ) {				case keyCode.PAGE_UP:					this._move( "previousPage", event );					break;				case keyCode.PAGE_DOWN:					this._move( "nextPage", event );					break;				case keyCode.UP:					this._keyEvent( "previous", event );					break;				case keyCode.DOWN:					this._keyEvent( "next", event );					break;				}			},			input: function( event ) {				if ( suppressInput ) {					suppressInput = false;					event.preventDefault();					return;				}				this._searchTimeout( event );			},			focus: function() {				this.selectedItem = null;				this.previous = this._value();			},			blur: function( event ) {				clearTimeout( this.searching );				this.close( event );				this._change( event );			}		} );		this._initSource();		this.menu = $( "<ul>" )			.appendTo( this._appendTo() )			.menu( {				// disable ARIA support, the live region takes care of that				role: null			} )			.hide()			// Support: IE 11 only, Edge <= 14			// For other browsers, we preventDefault() on the mousedown event			// to keep the dropdown from taking focus from the input. This doesn''t			// work for IE/Edge, causing problems with selection and scrolling (#9638)			// Happily, IE and Edge support an "unselectable" attribute that			// prevents an element from receiving focus, exactly what we want here.			.attr( {				"unselectable": "on"			} )			.menu( "instance" );		this._addClass( this.menu.element, "ui-autocomplete", "ui-front" );		this._on( this.menu.element, {			mousedown: function( event ) {				// Prevent moving focus out of the text field				event.preventDefault();			},			menufocus: function( event, ui ) {				var label, item;				// support: Firefox				// Prevent accidental activation of menu items in Firefox (#7024 #9118)				if ( this.isNewMenu ) {					this.isNewMenu = false;					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {						this.menu.blur();						this.document.one( "mousemove", function() {							$( event.target ).trigger( event.originalEvent );						} );						return;					}				}				item = ui.item.data( "ui-autocomplete-item" );				if ( false !!== this._trigger( "focus", event, { item: item } ) ) {					// use value to match what will end up in the input, if it was a key event					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {						this._value( item.value );					}				}				// Announce the value in the liveRegion				label = ui.item.attr( "aria-label" ) || item.value;				if ( label && String.prototype.trim.call( label ).length ) {					clearTimeout( this.liveRegionTimer );					this.liveRegionTimer = this._delay( function() {						this.liveRegion.html( $( "<div>" ).text( label ) );					}, 100 );				}			},			menuselect: function( event, ui ) {				var item = ui.item.data( "ui-autocomplete-item" ),					previous = this.previous;				// Only trigger when focus was lost (click on menu)				if ( this.element[ 0 ] !!== $.ui.safeActiveElement( this.document[ 0 ] ) ) {					this.element.trigger( "focus" );					this.previous = previous;					// #6109 - IE triggers two focus events and the second					// is asynchronous, so we need to reset the previous					// term synchronously and asynchronously :-(					this._delay( function() {						this.previous = previous;						this.selectedItem = item;					} );				}				if ( false !!== this._trigger( "select", event, { item: item } ) ) {					this._value( item.value );				}				// reset the term after the select event				// this allows custom select handling to work properly				this.term = this._value();				this.close( event );				this.selectedItem = item;			}		} );		this.liveRegion = $( "<div>", {			role: "status",			"aria-live": "assertive",			"aria-relevant": "additions"		} )			.appendTo( this.document[ 0 ].body );		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );		// Turning off autocomplete prevents the browser from remembering the		// value when navigating through history, so we re-enable autocomplete		// if the page is unloaded before the widget is destroyed. #7790		this._on( this.window, {			beforeunload: function() {				this.element.removeAttr( "autocomplete" );			}		} );	},	_destroy: function() {		clearTimeout( this.searching );		this.element.removeAttr( "autocomplete" );		this.menu.element.remove();		this.liveRegion.remove();	},	_setOption: function( key, value ) {		this._super( key, value );		if ( key === "source" ) {			this._initSource();		}		if ( key === "appendTo" ) {			this.menu.element.appendTo( this._appendTo() );		}		if ( key === "disabled" && value && this.xhr ) {			this.xhr.abort();		}	},	_isEventTargetInWidget: function( event ) {		var menuElement = this.menu.element[ 0 ];		return event.target === this.element[ 0 ] ||			event.target === menuElement ||			$.contains( menuElement, event.target );	},	_closeOnClickOutside: function( event ) {		if ( !!this._isEventTargetInWidget( event ) ) {			this.close();		}	},	_appendTo: function() {		var element = this.options.appendTo;		if ( element ) {			element = element.jquery || element.nodeType ?				$( element ) :				this.document.find( element ).eq( 0 );		}		if ( !!element || !!element[ 0 ] ) {			element = this.element.closest( ".ui-front, dialog" );		}		if ( !!element.length ) {			element = this.document[ 0 ].body;		}		return element;	},	_initSource: function() {		var array, url,			that = this;		if ( Array.isArray( this.options.source ) ) {			array = this.options.source;			this.source = function( request, response ) {				response( $.ui.autocomplete.filter( array, request.term ) );			};		} else if ( typeof this.options.source === "string" ) {			url = this.options.source;			this.source = function( request, response ) {				if ( that.xhr ) {					that.xhr.abort();				}				that.xhr = $.ajax( {					url: url,					data: request,					dataType: "json",					success: function( data ) {						response( data );					},					error: function() {						response( [] );					}				} );			};		} else {			this.source = this.options.source;		}	},	_searchTimeout: function( event ) {		clearTimeout( this.searching );		this.searching = this._delay( function() {			// Search if the value has changed, or if the user retypes the same value (see #7434)			var equalValues = this.term === this._value(),				menuVisible = this.menu.element.is( ":visible" ),				modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;			if ( !!equalValues || ( equalValues && !!menuVisible && !!modifierKey ) ) {				this.selectedItem = null;				this.search( null, event );			}		}, this.options.delay );	},	search: function( value, event ) {		value = value !!= null ? value : this._value();		// Always save the actual value, not the one passed as an argument		this.term = this._value();		if ( value.length < this.options.minLength ) {			return this.close( event );		}		if ( this._trigger( "search", event ) === false ) {			return;		}		return this._search( value );	},	_search: function( value ) {		this.pending++;		this._addClass( "ui-autocomplete-loading" );		this.cancelSearch = false;		this.source( { term: value }, this._response() );	},	_response: function() {		var index = ++this.requestIndex;		return function( content ) {			if ( index === this.requestIndex ) {				this.__response( content );			}			this.pending--;			if ( !!this.pending ) {				this._removeClass( "ui-autocomplete-loading" );			}		}.bind( this );	},	__response: function( content ) {		if ( content ) {			content = this._normalize( content );		}		this._trigger( "response", null, { content: content } );		if ( !!this.options.disabled && content && content.length && !!this.cancelSearch ) {			this._suggest( content );			this._trigger( "open" );		} else {			// use ._close() instead of .close() so we don''t cancel future searches			this._close();		}	},	close: function( event ) {		this.cancelSearch = true;		this._close( event );	},	_close: function( event ) {		// Remove the handler that closes the menu on outside clicks		this._off( this.document, "mousedown" );		if ( this.menu.element.is( ":visible" ) ) {			this.menu.element.hide();			this.menu.blur();			this.isNewMenu = true;			this._trigger( "close", event );		}	},	_change: function( event ) {		if ( this.previous !!== this._value() ) {			this._trigger( "change", event, { item: this.selectedItem } );		}	},	_normalize: function( items ) {		// assume all items have the right format when the first item is complete		if ( items.length && items[ 0 ].label && items[ 0 ].value ) {			return items;		}		return $.map( items, function( item ) {			if ( typeof item === "string" ) {				return {					label: item,					value: item				};			}			return $.extend( {}, item, {				label: item.label || item.value,				value: item.value || item.label			} );		} );	},	_suggest: function( items ) {		var ul = this.menu.element.empty();		this._renderMenu( ul, items );		this.isNewMenu = true;		this.menu.refresh();		// Size and position menu		ul.show();		this._resizeMenu();		ul.position( $.extend( {			of: this.element		}, this.options.position ) );		if ( this.options.autoFocus ) {			this.menu.next();		}		// Listen for interactions outside of the widget (#6642)		this._on( this.document, {			mousedown: "_closeOnClickOutside"		} );	},	_resizeMenu: function() {		var ul = this.menu.element;		ul.outerWidth( Math.max(			// Firefox wraps long text (possibly a rounding bug)			// so we add 1px to avoid the wrapping (#7513)			ul.width( "" ).outerWidth() + 1,			this.element.outerWidth()		) );	},	_renderMenu: function( ul, items ) {		var that = this;		$.each( items, function( index, item ) {			that._renderItemData( ul, item );		} );	},	_renderItemData: function( ul, item ) {		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );	},	_renderItem: function( ul, item ) {		return $( "<li>" )			.append( $( "<div>" ).text( item.label ) )			.appendTo( ul );	},	_move: function( direction, event ) {		if ( !!this.menu.element.is( ":visible" ) ) {			this.search( null, event );			return;		}		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||				this.menu.isLastItem() && /^next/.test( direction ) ) {			if ( !!this.isMultiLine ) {				this._value( this.term );			}			this.menu.blur();			return;		}		this.menu[ direction ]( event );	},	widget: function() {		return this.menu.element;	},	_value: function() {		return this.valueMethod.apply( this.element, arguments );	},	_keyEvent: function( keyEvent, event ) {		if ( !!this.isMultiLine || this.menu.element.is( ":visible" ) ) {			this._move( keyEvent, event );			// Prevents moving cursor to beginning/end of the text field in some browsers			event.preventDefault();		}	},	// Support: Chrome <=50	// We should be able to just use this.element.prop( "isContentEditable" )	// but hidden elements always report false in Chrome.	// https://code.google.com/p/chromium/issues/detail?id=313082	_isContentEditable: function( element ) {		if ( !!element.length ) {			return false;		}		var editable = element.prop( "contentEditable" );		if ( editable === "inherit" ) {			return this._isContentEditable( element.parent() );		}		return editable === "true";	}} );$.extend( $.ui.autocomplete, {	escapeRegex: function( value ) {		return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );	},	filter: function( array, term ) {		var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );		return $.grep( array, function( value ) {			return matcher.test( value.label || value.value || value );		} );	}} );// Live region extension, adding a `messages` option// NOTE: This is an experimental API. We are still investigating// a full solution for string manipulation and internationalization.$.widget( "ui.autocomplete", $.ui.autocomplete, {	options: {		messages: {			noResults: "No search results.",			results: function( amount ) {				return amount + ( amount > 1 ? " results are" : " result is" ) +					" available, use up and down arrow keys to navigate.";			}		}	},	__response: function( content ) {		var message;		this._superApply( arguments );		if ( this.options.disabled || this.cancelSearch ) {			return;		}		if ( content && content.length ) {			message = this.options.messages.results( content.length );		} else {			message = this.options.messages.noResults;		}		clearTimeout( this.liveRegionTimer );		this.liveRegionTimer = this._delay( function() {			this.liveRegion.html( $( "<div>" ).text( message ) );		}, 100 );	}} );var widgetsAutocomplete = $.ui.autocomplete;/*!! * jQuery UI Controlgroup 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Controlgroup//>>group: Widgets//>>description: Visually groups form control widgets//>>docs: http://api.jqueryui.com/controlgroup///>>demos: http://jqueryui.com/controlgroup///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/controlgroup.css//>>css.theme: ../../themes/base/theme.cssvar controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;var widgetsControlgroup = $.widget( "ui.controlgroup", {	version: "1.13.2",	defaultElement: "<div>",	options: {		direction: "horizontal",		disabled: null,		onlyVisible: true,		items: {			"button": "input[type=button], input[type=submit], input[type=reset], button, a",			"controlgroupLabel": ".ui-controlgroup-label",			"checkboxradio": "input[type=''checkbox''], input[type=''radio'']",			"selectmenu": "select",			"spinner": ".ui-spinner-input"		}	},	_create: function() {		this._enhance();	},	// To support the enhanced option in jQuery Mobile, we isolate DOM manipulation	_enhance: function() {		this.element.attr( "role", "toolbar" );		this.refresh();	},	_destroy: function() {		this._callChildMethod( "destroy" );		this.childWidgets.removeData( "ui-controlgroup-data" );		this.element.removeAttr( "role" );		if ( this.options.items.controlgroupLabel ) {			this.element				.find( this.options.items.controlgroupLabel )				.find( ".ui-controlgroup-label-contents" )				.contents().unwrap();		}	},	_initWidgets: function() {		var that = this,			childWidgets = [];		// First we iterate over each of the items options		$.each( this.options.items, function( widget, selector ) {			var labels;			var options = {};			// Make sure the widget has a selector set			if ( !!selector ) {				return;			}			if ( widget === "controlgroupLabel" ) {				labels = that.element.find( selector );				labels.each( function() {					var element = $( this );					if ( element.children( ".ui-controlgroup-label-contents" ).length ) {						return;					}					element.contents()						.wrapAll( "<span class=''ui-controlgroup-label-contents''></span>" );				} );				that._addClass( labels, null, "ui-widget ui-widget-content ui-state-default" );				childWidgets = childWidgets.concat( labels.get() );				return;			}			// Make sure the widget actually exists			if ( !!$.fn[ widget ] ) {				return;			}			// We assume everything is in the middle to start because we can''t determine			// first / last elements until all enhancments are done.			if ( that[ "_" + widget + "Options" ] ) {				options = that[ "_" + widget + "Options" ]( "middle" );			} else {				options = { classes: {} };			}			// Find instances of this widget inside controlgroup and init them			that.element				.find( selector )				.each( function() {					var element = $( this );					var instance = element[ widget ]( "instance" );					// We need to clone the default options for this type of widget to avoid					// polluting the variable options which has a wider scope than a single widget.					var instanceOptions = $.widget.extend( {}, options );					// If the button is the child of a spinner ignore it					// TODO: Find a more generic solution					if ( widget === "button" && element.parent( ".ui-spinner" ).length ) {						return;					}					// Create the widget if it doesn''t exist					if ( !!instance ) {						instance = element[ widget ]()[ widget ]( "instance" );					}					if ( instance ) {						instanceOptions.classes =							that._resolveClassesValues( instanceOptions.classes, instance );					}					element[ widget ]( instanceOptions );					// Store an instance of the controlgroup to be able to reference					// from the outermost element for changing options and refresh					var widgetElement = element[ widget ]( "widget" );					$.data( widgetElement[ 0 ], "ui-controlgroup-data",						instance ? instance : element[ widget ]( "instance" ) );					childWidgets.push( widgetElement[ 0 ] );				} );		} );		this.childWidgets = $( $.uniqueSort( childWidgets ) );		this._addClass( this.childWidgets, "ui-controlgroup-item" );	},	_callChildMethod: function( method ) {		this.childWidgets.each( function() {			var element = $( this ),				data = element.data( "ui-controlgroup-data" );			if ( data && data[ method ] ) {				data[ method ]();			}		} );	},	_updateCornerClass: function( element, position ) {		var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";		var add = this._buildSimpleOptions( position, "label" ).classes.label;		this._removeClass( element, null, remove );		this._addClass( element, null, add );	},	_buildSimpleOptions: function( position, key ) {		var direction = this.options.direction === "vertical";		var result = {			classes: {}		};		result.classes[ key ] = {			"middle": "",			"first": "ui-corner-" + ( direction ? "top" : "left" ),			"last": "ui-corner-" + ( direction ? "bottom" : "right" ),			"only": "ui-corner-all"		}[ position ];		return result;	},	_spinnerOptions: function( position ) {		var options = this._buildSimpleOptions( position, "ui-spinner" );		options.classes[ "ui-spinner-up" ] = "";		options.classes[ "ui-spinner-down" ] = "";		return options;	},	_buttonOptions: function( position ) {		return this._buildSimpleOptions( position, "ui-button" );	},	_checkboxradioOptions: function( position ) {		return this._buildSimpleOptions( position, "ui-checkboxradio-label" );	},	_selectmenuOptions: function( position ) {		var direction = this.options.direction === "vertical";		return {			width: direction ? "auto" : false,			classes: {				middle: {					"ui-selectmenu-button-open": "",					"ui-selectmenu-button-closed": ""				},				first: {					"ui-selectmenu-button-open": "ui-corner-" + ( direction ? "top" : "tl" ),					"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "top" : "left" )				},				last: {					"ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",					"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "bottom" : "right" )				},				only: {					"ui-selectmenu-button-open": "ui-corner-top",					"ui-selectmenu-button-closed": "ui-corner-all"				}			}[ position ]		};	},	_resolveClassesValues: function( classes, instance ) {		var result = {};		$.each( classes, function( key ) {			var current = instance.options.classes[ key ] || "";			current = String.prototype.trim.call( current.replace( controlgroupCornerRegex, "" ) );			result[ key ] = ( current + " " + classes[ key ] ).replace( /\s+/g, " " );		} );		return result;	},	_setOption: function( key, value ) {		if ( key === "direction" ) {			this._removeClass( "ui-controlgroup-" + this.options.direction );		}		this._super( key, value );		if ( key === "disabled" ) {			this._callChildMethod( value ? "disable" : "enable" );			return;		}		this.refresh();	},	refresh: function() {		var children,			that = this;		this._addClass( "ui-controlgroup ui-controlgroup-" + this.options.direction );		if ( this.options.direction === "horizontal" ) {			this._addClass( null, "ui-helper-clearfix" );		}		this._initWidgets();		children = this.childWidgets;		// We filter here because we need to track all childWidgets not just the visible ones		if ( this.options.onlyVisible ) {			children = children.filter( ":visible" );		}		if ( children.length ) {			// We do this last because we need to make sure all enhancment is done			// before determining first and last			$.each( [ "first", "last" ], function( index, value ) {				var instance = children[ value ]().data( "ui-controlgroup-data" );				if ( instance && that[ "_" + instance.widgetName + "Options" ] ) {					var options = that[ "_" + instance.widgetName + "Options" ](						children.length === 1 ? "only" : value					);					options.classes = that._resolveClassesValues( options.classes, instance );					instance.element[ instance.widgetName ]( options );				} else {					that._updateCornerClass( children[ value ](), value );				}			} );			// Finally call the refresh method on each of the child widgets.			this._callChildMethod( "refresh" );		}	}} );/*!! * jQuery UI Checkboxradio 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Checkboxradio//>>group: Widgets//>>description: Enhances a form with multiple themeable checkboxes or radio buttons.//>>docs: http://api.jqueryui.com/checkboxradio///>>demos: http://jqueryui.com/checkboxradio///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/button.css//>>css.structure: ../../themes/base/checkboxradio.css//>>css.theme: ../../themes/base/theme.css$.widget( "ui.checkboxradio", [ $.ui.formResetMixin, {	version: "1.13.2",	options: {		disabled: null,		label: null,		icon: true,		classes: {			"ui-checkboxradio-label": "ui-corner-all",			"ui-checkboxradio-icon": "ui-corner-all"		}	},	_getCreateOptions: function() {		var disabled, labels, labelContents;		var options = this._super() || {};		// We read the type here, because it makes more sense to throw a element type error first,		// rather then the error for lack of a label. Often if its the wrong type, it		// won''t have a label (e.g. calling on a div, btn, etc)		this._readType();		labels = this.element.labels();		// If there are multiple labels, use the last one		this.label = $( labels[ labels.length - 1 ] );		if ( !!this.label.length ) {			$.error( "No label found for checkboxradio widget" );		}		this.originalLabel = "";		// We need to get the label text but this may also need to make sure it does not contain the		// input itself.		// The label contents could be text, html, or a mix. We wrap all elements		// and read the wrapper''s `innerHTML` to get a string representation of		// the label, without the input as part of it.		labelContents = this.label.contents().not( this.element[ 0 ] );		if ( labelContents.length ) {			this.originalLabel += labelContents				.clone()				.wrapAll( "<div></div>" )				.parent()				.html();		}		// Set the label option if we found label text		if ( this.originalLabel ) {			options.label = this.originalLabel;		}		disabled = this.element[ 0 ].disabled;		if ( disabled !!= null ) {			options.disabled = disabled;		}		return options;	},	_create: function() {		var checked = this.element[ 0 ].checked;		this._bindFormResetHandler();		if ( this.options.disabled == null ) {			this.options.disabled = this.element[ 0 ].disabled;		}		this._setOption( "disabled", this.options.disabled );		this._addClass( "ui-checkboxradio", "ui-helper-hidden-accessible" );		this._addClass( this.label, "ui-checkboxradio-label", "ui-button ui-widget" );		if ( this.type === "radio" ) {			this._addClass( this.label, "ui-checkboxradio-radio-label" );		}		if ( this.options.label && this.options.label !!== this.originalLabel ) {			this._updateLabel();		} else if ( this.originalLabel ) {			this.options.label = this.originalLabel;		}		this._enhance();		if ( checked ) {			this._addClass( this.label, "ui-checkboxradio-checked", "ui-state-active" );		}		this._on( {			change: "_toggleClasses",			focus: function() {				this._addClass( this.label, null, "ui-state-focus ui-visual-focus" );			},			blur: function() {				this._removeClass( this.label, null, "ui-state-focus ui-visual-focus" );			}		} );	},	_readType: function() {		var nodeName = this.element[ 0 ].nodeName.toLowerCase();		this.type = this.element[ 0 ].type;		if ( nodeName !!== "input" || !!/radio|checkbox/.test( this.type ) ) {			$.error( "Can''t create checkboxradio on element.nodeName=" + nodeName +				" and element.type=" + this.type );		}	},	// Support jQuery Mobile enhanced option	_enhance: function() {		this._updateIcon( this.element[ 0 ].checked );	},	widget: function() {		return this.label;	},	_getRadioGroup: function() {		var group;		var name = this.element[ 0 ].name;		var nameSelector = "input[name=''" + $.escapeSelector( name ) + "'']";		if ( !!name ) {			return $( [] );		}		if ( this.form.length ) {			group = $( this.form[ 0 ].elements ).filter( nameSelector );		} else {			// Not inside a form, check all inputs that also are not inside a form			group = $( nameSelector ).filter( function() {				return $( this )._form().length === 0;			} );		}		return group.not( this.element );	},	_toggleClasses: function() {		var checked = this.element[ 0 ].checked;		this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );		if ( this.options.icon && this.type === "checkbox" ) {			this._toggleClass( this.icon, null, "ui-icon-check ui-state-checked", checked )				._toggleClass( this.icon, null, "ui-icon-blank", !!checked );		}		if ( this.type === "radio" ) {			this._getRadioGroup()				.each( function() {					var instance = $( this ).checkboxradio( "instance" );					if ( instance ) {						instance._removeClass( instance.label,							"ui-checkboxradio-checked", "ui-state-active" );					}				} );		}	},	_destroy: function() {		this._unbindFormResetHandler();		if ( this.icon ) {			this.icon.remove();			this.iconSpace.remove();		}	},	_setOption: function( key, value ) {		// We don''t allow the value to be set to nothing		if ( key === "label" && !!value ) {			return;		}		this._super( key, value );		if ( key === "disabled" ) {			this._toggleClass( this.label, null, "ui-state-disabled", value );			this.element[ 0 ].disabled = value;			// Don''t refresh when setting disabled			return;		}		this.refresh();	},	_updateIcon: function( checked ) {		var toAdd = "ui-icon ui-icon-background ";		if ( this.options.icon ) {			if ( !!this.icon ) {				this.icon = $( "<span>" );				this.iconSpace = $( "<span> </span>" );				this._addClass( this.iconSpace, "ui-checkboxradio-icon-space" );			}			if ( this.type === "checkbox" ) {				toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";				this._removeClass( this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check" );			} else {				toAdd += "ui-icon-blank";			}			this._addClass( this.icon, "ui-checkboxradio-icon", toAdd );			if ( !!checked ) {				this._removeClass( this.icon, null, "ui-icon-check ui-state-checked" );			}			this.icon.prependTo( this.label ).after( this.iconSpace );		} else if ( this.icon !!== undefined ) {			this.icon.remove();			this.iconSpace.remove();			delete this.icon;		}	},	_updateLabel: function() {		// Remove the contents of the label ( minus the icon, icon space, and input )		var contents = this.label.contents().not( this.element[ 0 ] );		if ( this.icon ) {			contents = contents.not( this.icon[ 0 ] );		}		if ( this.iconSpace ) {			contents = contents.not( this.iconSpace[ 0 ] );		}		contents.remove();		this.label.append( this.options.label );	},	refresh: function() {		var checked = this.element[ 0 ].checked,			isDisabled = this.element[ 0 ].disabled;		this._updateIcon( checked );		this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );		if ( this.options.label !!== null ) {			this._updateLabel();		}		if ( isDisabled !!== this.options.disabled ) {			this._setOptions( { "disabled": isDisabled } );		}	}} ] );var widgetsCheckboxradio = $.ui.checkboxradio;/*!! * jQuery UI Button 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Button//>>group: Widgets//>>description: Enhances a form with themeable buttons.//>>docs: http://api.jqueryui.com/button///>>demos: http://jqueryui.com/button///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/button.css//>>css.theme: ../../themes/base/theme.css$.widget( "ui.button", {	version: "1.13.2",	defaultElement: "<button>",	options: {		classes: {			"ui-button": "ui-corner-all"		},		disabled: null,		icon: null,		iconPosition: "beginning",		label: null,		showLabel: true	},	_getCreateOptions: function() {		var disabled,			// This is to support cases like in jQuery Mobile where the base widget does have			// an implementation of _getCreateOptions			options = this._super() || {};		this.isInput = this.element.is( "input" );		disabled = this.element[ 0 ].disabled;		if ( disabled !!= null ) {			options.disabled = disabled;		}		this.originalLabel = this.isInput ? this.element.val() : this.element.html();		if ( this.originalLabel ) {			options.label = this.originalLabel;		}		return options;	},	_create: function() {		if ( !!this.option.showLabel & !!this.options.icon ) {			this.options.showLabel = true;		}		// We have to check the option again here even though we did in _getCreateOptions,		// because null may have been passed on init which would override what was set in		// _getCreateOptions		if ( this.options.disabled == null ) {			this.options.disabled = this.element[ 0 ].disabled || false;		}		this.hasTitle = !!!!this.element.attr( "title" );		// Check to see if the label needs to be set or if its already correct		if ( this.options.label && this.options.label !!== this.originalLabel ) {			if ( this.isInput ) {				this.element.val( this.options.label );			} else {				this.element.html( this.options.label );			}		}		this._addClass( "ui-button", "ui-widget" );		this._setOption( "disabled", this.options.disabled );		this._enhance();		if ( this.element.is( "a" ) ) {			this._on( {				"keyup": function( event ) {					if ( event.keyCode === $.ui.keyCode.SPACE ) {						event.preventDefault();						// Support: PhantomJS <= 1.9, IE 8 Only						// If a native click is available use it so we actually cause navigation						// otherwise just trigger a click event						if ( this.element[ 0 ].click ) {							this.element[ 0 ].click();						} else {							this.element.trigger( "click" );						}					}				}			} );		}	},	_enhance: function() {		if ( !!this.element.is( "button" ) ) {			this.element.attr( "role", "button" );		}		if ( this.options.icon ) {			this._updateIcon( "icon", this.options.icon );			this._updateTooltip();		}	},	_updateTooltip: function() {		this.title = this.element.attr( "title" );		if ( !!this.options.showLabel && !!this.title ) {			this.element.attr( "title", this.options.label );		}	},	_updateIcon: function( option, value ) {		var icon = option !!== "iconPosition",			position = icon ? this.options.iconPosition : value,			displayBlock = position === "top" || position === "bottom";		// Create icon		if ( !!this.icon ) {			this.icon = $( "<span>" );			this._addClass( this.icon, "ui-button-icon", "ui-icon" );			if ( !!this.options.showLabel ) {				this._addClass( "ui-button-icon-only" );			}		} else if ( icon ) {			// If we are updating the icon remove the old icon class			this._removeClass( this.icon, null, this.options.icon );		}		// If we are updating the icon add the new icon class		if ( icon ) {			this._addClass( this.icon, null, value );		}		this._attachIcon( position );		// If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove		// the iconSpace if there is one.		if ( displayBlock ) {			this._addClass( this.icon, null, "ui-widget-icon-block" );			if ( this.iconSpace ) {				this.iconSpace.remove();			}		} else {			// Position is beginning or end so remove the ui-widget-icon-block class and add the			// space if it does not exist			if ( !!this.iconSpace ) {				this.iconSpace = $( "<span> </span>" );				this._addClass( this.iconSpace, "ui-button-icon-space" );			}			this._removeClass( this.icon, null, "ui-wiget-icon-block" );			this._attachIconSpace( position );		}	},	_destroy: function() {		this.element.removeAttr( "role" );		if ( this.icon ) {			this.icon.remove();		}		if ( this.iconSpace ) {			this.iconSpace.remove();		}		if ( !!this.hasTitle ) {			this.element.removeAttr( "title" );		}	},	_attachIconSpace: function( iconPosition ) {		this.icon[ /^(?:end|bottom)/.test( iconPosition ) ? "before" : "after" ]( this.iconSpace );	},	_attachIcon: function( iconPosition ) {		this.element[ /^(?:end|bottom)/.test( iconPosition ) ? "append" : "prepend" ]( this.icon );	},	_setOptions: function( options ) {		var newShowLabel = options.showLabel === undefined ?				this.options.showLabel :				options.showLabel,			newIcon = options.icon === undefined ? this.options.icon : options.icon;		if ( !!newShowLabel && !!newIcon ) {			options.showLabel = true;		}		this._super( options );	},	_setOption: function( key, value ) {		if ( key === "icon" ) {			if ( value ) {				this._updateIcon( key, value );			} else if ( this.icon ) {				this.icon.remove();				if ( this.iconSpace ) {					this.iconSpace.remove();				}			}		}		if ( key === "iconPosition" ) {			this._updateIcon( key, value );		}		// Make sure we can''t end up with a button that has neither text nor icon		if ( key === "showLabel" ) {				this._toggleClass( "ui-button-icon-only", null, !!value );				this._updateTooltip();		}		if ( key === "label" ) {			if ( this.isInput ) {				this.element.val( value );			} else {				// If there is an icon, append it, else nothing then append the value				// this avoids removal of the icon when setting label text				this.element.html( value );				if ( this.icon ) {					this._attachIcon( this.options.iconPosition );					this._attachIconSpace( this.options.iconPosition );				}			}		}		this._super( key, value );		if ( key === "disabled" ) {			this._toggleClass( null, "ui-state-disabled", value );			this.element[ 0 ].disabled = value;			if ( value ) {				this.element.trigger( "blur" );			}		}	},	refresh: function() {		// Make sure to only check disabled if its an element that supports this otherwise		// check for the disabled class to determine state		var isDisabled = this.element.is( "input, button" ) ?			this.element[ 0 ].disabled : this.element.hasClass( "ui-button-disabled" );		if ( isDisabled !!== this.options.disabled ) {			this._setOptions( { disabled: isDisabled } );		}		this._updateTooltip();	}} );// DEPRECATEDif ( $.uiBackCompat !!== false ) {	// Text and Icons options	$.widget( "ui.button", $.ui.button, {		options: {			text: true,			icons: {				primary: null,				secondary: null			}		},		_create: function() {			if ( this.options.showLabel && !!this.options.text ) {				this.options.showLabel = this.options.text;			}			if ( !!this.options.showLabel && this.options.text ) {				this.options.text = this.options.showLabel;			}			if ( !!this.options.icon && ( this.options.icons.primary ||					this.options.icons.secondary ) ) {				if ( this.options.icons.primary ) {					this.options.icon = this.options.icons.primary;				} else {					this.options.icon = this.options.icons.secondary;					this.options.iconPosition = "end";				}			} else if ( this.options.icon ) {				this.options.icons.primary = this.options.icon;			}			this._super();		},		_setOption: function( key, value ) {			if ( key === "text" ) {				this._super( "showLabel", value );				return;			}			if ( key === "showLabel" ) {				this.options.text = value;			}			if ( key === "icon" ) {				this.options.icons.primary = value;			}			if ( key === "icons" ) {				if ( value.primary ) {					this._super( "icon", value.primary );					this._super( "iconPosition", "beginning" );				} else if ( value.secondary ) {					this._super( "icon", value.secondary );					this._super( "iconPosition", "end" );				}			}			this._superApply( arguments );		}	} );	$.fn.button = ( function( orig ) {		return function( options ) {			var isMethodCall = typeof options === "string";			var args = Array.prototype.slice.call( arguments, 1 );			var returnValue = this;			if ( isMethodCall ) {				// If this is an empty collection, we need to have the instance method				// return undefined instead of the jQuery instance				if ( !!this.length && options === "instance" ) {					returnValue = undefined;				} else {					this.each( function() {						var methodValue;						var type = $( this ).attr( "type" );						var name = type !!== "checkbox" && type !!== "radio" ?							"button" :							"checkboxradio";						var instance = $.data( this, "ui-" + name );						if ( options === "instance" ) {							returnValue = instance;							return false;						}						if ( !!instance ) {							return $.error( "cannot call methods on button" +								" prior to initialization; " +								"attempted to call method ''" + options + "''" );						}						if ( typeof instance[ options ] !!== "function" ||							options.charAt( 0 ) === "_" ) {							return $.error( "no such method ''" + options + "'' for button" +								" widget instance" );						}						methodValue = instance[ options ].apply( instance, args );						if ( methodValue !!== instance && methodValue !!== undefined ) {							returnValue = methodValue && methodValue.jquery ?								returnValue.pushStack( methodValue.get() ) :								methodValue;							return false;						}					} );				}			} else {				// Allow multiple hashes to be passed on init				if ( args.length ) {					options = $.widget.extend.apply( null, [ options ].concat( args ) );				}				this.each( function() {					var type = $( this ).attr( "type" );					var name = type !!== "checkbox" && type !!== "radio" ? "button" : "checkboxradio";					var instance = $.data( this, "ui-" + name );					if ( instance ) {						instance.option( options || {} );						if ( instance._init ) {							instance._init();						}					} else {						if ( name === "button" ) {							orig.call( $( this ), options );							return;						}						$( this ).checkboxradio( $.extend( { icon: false }, options ) );					}				} );			}			return returnValue;		};	} )( $.fn.button );	$.fn.buttonset = function() {		if ( !!$.ui.controlgroup ) {			$.error( "Controlgroup widget missing" );		}		if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" && arguments[ 2 ] ) {			return this.controlgroup.apply( this,				[ arguments[ 0 ], "items.button", arguments[ 2 ] ] );		}		if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" ) {			return this.controlgroup.apply( this, [ arguments[ 0 ], "items.button" ] );		}		if ( typeof arguments[ 0 ] === "object" && arguments[ 0 ].items ) {			arguments[ 0 ].items = {				button: arguments[ 0 ].items			};		}		return this.controlgroup.apply( this, arguments );	};}var widgetsButton = $.ui.button;/* eslint-disable max-len, camelcase *//*!! * jQuery UI Datepicker 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Datepicker//>>group: Widgets//>>description: Displays a calendar from an input or inline for selecting dates.//>>docs: http://api.jqueryui.com/datepicker///>>demos: http://jqueryui.com/datepicker///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/datepicker.css//>>css.theme: ../../themes/base/theme.css$.extend( $.ui, { datepicker: { version: "1.13.2" } } );var datepicker_instActive;function datepicker_getZindex( elem ) {	var position, value;	while ( elem.length && elem[ 0 ] !!== document ) {		// Ignore z-index if position is set to a value where z-index is ignored by the browser		// This makes behavior of this function consistent across browsers		// WebKit always returns auto if the element is positioned		position = elem.css( "position" );		if ( position === "absolute" || position === "relative" || position === "fixed" ) {			// IE returns 0 when zIndex is not specified			// other browsers return a string			// we ignore the case of nested elements with an explicit value of 0			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>			value = parseInt( elem.css( "zIndex" ), 10 );			if ( !!isNaN( value ) && value !!== 0 ) {				return value;			}		}		elem = elem.parent();	}	return 0;}/* Date picker manager.   Use the singleton instance of this class, $.datepicker, to interact with the date picker.   Settings for (groups of) date pickers are maintained in an instance object,   allowing multiple different settings on the same page. */function Datepicker() {	this._curInst = null; // The current instance in use	this._keyEvent = false; // If the last event was a key event	this._disabledInputs = []; // List of date picker inputs that have been disabled	this._datepickerShowing = false; // True if the popup picker is showing , false if not	this._inDialog = false; // True if showing within a "dialog", false if not	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class	this._appendClass = "ui-datepicker-append"; // The name of the append marker class	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class	this.regional = []; // Available regional settings, indexed by language code	this.regional[ "" ] = { // Default regional settings		closeText: "Done", // Display text for close link		prevText: "Prev", // Display text for previous month link		nextText: "Next", // Display text for next month link		currentText: "Today", // Display text for current month link		monthNames: [ "January", "February", "March", "April", "May", "June",			"July", "August", "September", "October", "November", "December" ], // Names of months for drop-down and formatting		monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting		dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting		dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting		dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ], // Column headings for days starting at Sunday		weekHeader: "Wk", // Column header for week of the year		dateFormat: "mm/dd/yy", // See format options on parseDate		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...		isRTL: false, // True if right-to-left language, false if left-to-right		showMonthAfterYear: false, // True if the year select precedes month, false for month then year		yearSuffix: "", // Additional text to append to the year in the month headers,		selectMonthLabel: "Select month", // Invisible label for month selector		selectYearLabel: "Select year" // Invisible label for year selector	};	this._defaults = { // Global defaults for all the date picker instances		showOn: "focus", // "focus" for popup on focus,			// "button" for trigger button, or "both" for either		showAnim: "fadeIn", // Name of jQuery animation for popup		showOptions: {}, // Options for enhanced animations		defaultDate: null, // Used when field is blank: actual date,			// +/-number for offset from today, null for today		appendText: "", // Display text following the input box, e.g. showing the format		buttonText: "...", // Text for trigger button		buttonImage: "", // URL for trigger button image		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button		hideIfNoPrevNext: false, // True to hide next/previous month links			// if not applicable, false to just disable them		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links		gotoCurrent: false, // True if today link goes back to current selection instead		changeMonth: false, // True if month can be selected directly, false if only prev/next		changeYear: false, // True if year can be selected directly, false if only prev/next		yearRange: "c-10:c+10", // Range of years to display in drop-down,			// either relative to today''s year (-nn:+nn), relative to currently displayed year			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)		showOtherMonths: false, // True to show dates in other months, false to leave blank		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable		showWeek: false, // True to show week of the year, false to not show it		calculateWeek: this.iso8601Week, // How to calculate the week of the year,			// takes a Date and returns the number of the week for it		shortYearCutoff: "+10", // Short year values < this are in the current century,			// > this are in the previous century,			// string value starting with "+" for current year + value		minDate: null, // The earliest selectable date, or null for no limit		maxDate: null, // The latest selectable date, or null for no limit		duration: "fast", // Duration of display/closure		beforeShowDay: null, // Function that takes a date and returns an array with			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",			// [2] = cell title (optional), e.g. $.datepicker.noWeekends		beforeShow: null, // Function that takes an input field and			// returns a set of custom settings for the date picker		onSelect: null, // Define a callback function when a date is selected		onChangeMonthYear: null, // Define a callback function when the month or year is changed		onClose: null, // Define a callback function when the datepicker is closed		onUpdateDatepicker: null, // Define a callback function when the datepicker is updated		numberOfMonths: 1, // Number of months to show at a time		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)		stepMonths: 1, // Number of months to step back/forward		stepBigMonths: 12, // Number of months to step back/forward for the big links		altField: "", // Selector for an alternate field to store selected dates into		altFormat: "", // The date format to use for the alternate field		constrainInput: true, // The input is constrained by the current date format		showButtonPanel: false, // True to show button panel, false to not show it		autoSize: false, // True to size the input for the date format, false to leave as is		disabled: false // The initial disabled state	};	$.extend( this._defaults, this.regional[ "" ] );	this.regional.en = $.extend( true, {}, this.regional[ "" ] );	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );	this.dpDiv = datepicker_bindHover( $( "<div id=''" + this._mainDivId + "'' class=''ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all''></div>" ) );}$.extend( Datepicker.prototype, {	/* Class name added to elements to indicate already configured with a date picker. */	markerClassName: "hasDatepicker",	//Keep track of the maximum number of rows displayed (see #7043)	maxRows: 4,	// TODO rename to "widget" when switching to widget factory	_widgetDatepicker: function() {		return this.dpDiv;	},	/* Override the default settings for all instances of the date picker.	 * @param  settings  object - the new settings to use as defaults (anonymous object)	 * @return the manager object	 */	setDefaults: function( settings ) {		datepicker_extendRemove( this._defaults, settings || {} );		return this;	},	/* Attach the date picker to a jQuery selection.	 * @param  target	element - the target input field or division or span	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)	 */	_attachDatepicker: function( target, settings ) {		var nodeName, inline, inst;		nodeName = target.nodeName.toLowerCase();		inline = ( nodeName === "div" || nodeName === "span" );		if ( !!target.id ) {			this.uuid += 1;			target.id = "dp" + this.uuid;		}		inst = this._newInst( $( target ), inline );		inst.settings = $.extend( {}, settings || {} );		if ( nodeName === "input" ) {			this._connectDatepicker( target, inst );		} else if ( inline ) {			this._inlineDatepicker( target, inst );		}	},	/* Create a new instance object. */	_newInst: function( target, inline ) {		var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars		return { id: id, input: target, // associated target			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection			drawMonth: 0, drawYear: 0, // month being drawn			inline: inline, // is datepicker inline or not			dpDiv: ( !!inline ? this.dpDiv : // presentation div			datepicker_bindHover( $( "<div class=''" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all''></div>" ) ) ) };	},	/* Attach the date picker to an input field. */	_connectDatepicker: function( target, inst ) {		var input = $( target );		inst.append = $( [] );		inst.trigger = $( [] );		if ( input.hasClass( this.markerClassName ) ) {			return;		}		this._attachments( input, inst );		input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).			on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );		this._autoSize( inst );		$.data( target, "datepicker", inst );		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)		if ( inst.settings.disabled ) {			this._disableDatepicker( target );		}	},	/* Make attachments based on settings. */	_attachments: function( input, inst ) {		var showOn, buttonText, buttonImage,			appendText = this._get( inst, "appendText" ),			isRTL = this._get( inst, "isRTL" );		if ( inst.append ) {			inst.append.remove();		}		if ( appendText ) {			inst.append = $( "<span>" )				.addClass( this._appendClass )				.text( appendText );			input[ isRTL ? "before" : "after" ]( inst.append );		}		input.off( "focus", this._showDatepicker );		if ( inst.trigger ) {			inst.trigger.remove();		}		showOn = this._get( inst, "showOn" );		if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field			input.on( "focus", this._showDatepicker );		}		if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked			buttonText = this._get( inst, "buttonText" );			buttonImage = this._get( inst, "buttonImage" );			if ( this._get( inst, "buttonImageOnly" ) ) {				inst.trigger = $( "<img>" )					.addClass( this._triggerClass )					.attr( {						src: buttonImage,						alt: buttonText,						title: buttonText					} );			} else {				inst.trigger = $( "<button type=''button''>" )					.addClass( this._triggerClass );				if ( buttonImage ) {					inst.trigger.html(						$( "<img>" )							.attr( {								src: buttonImage,								alt: buttonText,								title: buttonText							} )					);				} else {					inst.trigger.text( buttonText );				}			}			input[ isRTL ? "before" : "after" ]( inst.trigger );			inst.trigger.on( "click", function() {				if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {					$.datepicker._hideDatepicker();				} else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !!== input[ 0 ] ) {					$.datepicker._hideDatepicker();					$.datepicker._showDatepicker( input[ 0 ] );				} else {					$.datepicker._showDatepicker( input[ 0 ] );				}				return false;			} );		}	},	/* Apply the maximum length for the date format. */	_autoSize: function( inst ) {		if ( this._get( inst, "autoSize" ) && !!inst.inline ) {			var findMax, max, maxI, i,				date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits				dateFormat = this._get( inst, "dateFormat" );			if ( dateFormat.match( /[DM]/ ) ) {				findMax = function( names ) {					max = 0;					maxI = 0;					for ( i = 0; i < names.length; i++ ) {						if ( names[ i ].length > max ) {							max = names[ i ].length;							maxI = i;						}					}					return maxI;				};				date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?					"monthNames" : "monthNamesShort" ) ) ) );				date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?					"dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );			}			inst.input.attr( "size", this._formatDate( inst, date ).length );		}	},	/* Attach an inline date picker to a div. */	_inlineDatepicker: function( target, inst ) {		var divSpan = $( target );		if ( divSpan.hasClass( this.markerClassName ) ) {			return;		}		divSpan.addClass( this.markerClassName ).append( inst.dpDiv );		$.data( target, "datepicker", inst );		this._setDate( inst, this._getDefaultDate( inst ), true );		this._updateDatepicker( inst );		this._updateAlternate( inst );		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)		if ( inst.settings.disabled ) {			this._disableDatepicker( target );		}		// Set display:block in place of inst.dpDiv.show() which won''t work on disconnected elements		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height		inst.dpDiv.css( "display", "block" );	},	/* Pop-up the date picker in a "dialog" box.	 * @param  input element - ignored	 * @param  date	string or Date - the initial date to display	 * @param  onSelect  function - the function to call when a date is selected	 * @param  settings  object - update the dialog date picker instance''s settings (anonymous object)	 * @param  pos int[2] - coordinates for the dialog''s position within the screen or	 *					event - with x/y coordinates or	 *					leave empty for default (screen centre)	 * @return the manager object	 */	_dialogDatepicker: function( input, date, onSelect, settings, pos ) {		var id, browserWidth, browserHeight, scrollX, scrollY,			inst = this._dialogInst; // internal instance		if ( !!inst ) {			this.uuid += 1;			id = "dp" + this.uuid;			this._dialogInput = $( "<input type=''text'' id=''" + id +				"'' style=''position: absolute; top: -100px; width: 0px;''/>" );			this._dialogInput.on( "keydown", this._doKeyDown );			$( "body" ).append( this._dialogInput );			inst = this._dialogInst = this._newInst( this._dialogInput, false );			inst.settings = {};			$.data( this._dialogInput[ 0 ], "datepicker", inst );		}		datepicker_extendRemove( inst.settings, settings || {} );		date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );		this._dialogInput.val( date );		this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );		if ( !!this._pos ) {			browserWidth = document.documentElement.clientWidth;			browserHeight = document.documentElement.clientHeight;			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;			scrollY = document.documentElement.scrollTop || document.body.scrollTop;			this._pos = // should use actual width/height below				[ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];		}		// Move input on screen for focus, but hidden behind dialog		this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );		inst.settings.onSelect = onSelect;		this._inDialog = true;		this.dpDiv.addClass( this._dialogClass );		this._showDatepicker( this._dialogInput[ 0 ] );		if ( $.blockUI ) {			$.blockUI( this.dpDiv );		}		$.data( this._dialogInput[ 0 ], "datepicker", inst );		return this;	},	/* Detach a datepicker from its control.	 * @param  target	element - the target input field or division or span	 */	_destroyDatepicker: function( target ) {		var nodeName,			$target = $( target ),			inst = $.data( target, "datepicker" );		if ( !!$target.hasClass( this.markerClassName ) ) {			return;		}		nodeName = target.nodeName.toLowerCase();		$.removeData( target, "datepicker" );		if ( nodeName === "input" ) {			inst.append.remove();			inst.trigger.remove();			$target.removeClass( this.markerClassName ).				off( "focus", this._showDatepicker ).				off( "keydown", this._doKeyDown ).				off( "keypress", this._doKeyPress ).				off( "keyup", this._doKeyUp );		} else if ( nodeName === "div" || nodeName === "span" ) {			$target.removeClass( this.markerClassName ).empty();		}		if ( datepicker_instActive === inst ) {			datepicker_instActive = null;			this._curInst = null;		}	},	/* Enable the date picker to a jQuery selection.	 * @param  target	element - the target input field or division or span	 */	_enableDatepicker: function( target ) {		var nodeName, inline,			$target = $( target ),			inst = $.data( target, "datepicker" );		if ( !!$target.hasClass( this.markerClassName ) ) {			return;		}		nodeName = target.nodeName.toLowerCase();		if ( nodeName === "input" ) {			target.disabled = false;			inst.trigger.filter( "button" ).				each( function() {					this.disabled = false;				} ).end().				filter( "img" ).css( { opacity: "1.0", cursor: "" } );		} else if ( nodeName === "div" || nodeName === "span" ) {			inline = $target.children( "." + this._inlineClass );			inline.children().removeClass( "ui-state-disabled" );			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).				prop( "disabled", false );		}		this._disabledInputs = $.map( this._disabledInputs,			// Delete entry			function( value ) {				return ( value === target ? null : value );			} );	},	/* Disable the date picker to a jQuery selection.	 * @param  target	element - the target input field or division or span	 */	_disableDatepicker: function( target ) {		var nodeName, inline,			$target = $( target ),			inst = $.data( target, "datepicker" );		if ( !!$target.hasClass( this.markerClassName ) ) {			return;		}		nodeName = target.nodeName.toLowerCase();		if ( nodeName === "input" ) {			target.disabled = true;			inst.trigger.filter( "button" ).				each( function() {					this.disabled = true;				} ).end().				filter( "img" ).css( { opacity: "0.5", cursor: "default" } );		} else if ( nodeName === "div" || nodeName === "span" ) {			inline = $target.children( "." + this._inlineClass );			inline.children().addClass( "ui-state-disabled" );			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).				prop( "disabled", true );		}		this._disabledInputs = $.map( this._disabledInputs,			// Delete entry			function( value ) {				return ( value === target ? null : value );			} );		this._disabledInputs[ this._disabledInputs.length ] = target;	},	/* Is the first field in a jQuery collection disabled as a datepicker?	 * @param  target	element - the target input field or division or span	 * @return boolean - true if disabled, false if enabled	 */	_isDisabledDatepicker: function( target ) {		if ( !!target ) {			return false;		}		for ( var i = 0; i < this._disabledInputs.length; i++ ) {			if ( this._disabledInputs[ i ] === target ) {				return true;			}		}		return false;	},	/* Retrieve the instance data for the target control.	 * @param  target  element - the target input field or division or span	 * @return  object - the associated instance data	 * @throws  error if a jQuery problem getting data	 */	_getInst: function( target ) {		try {			return $.data( target, "datepicker" );		} catch ( err ) {			throw "Missing instance data for this datepicker";		}	},	/* Update or retrieve the settings for a date picker attached to an input field or division.	 * @param  target  element - the target input field or division or span	 * @param  name	object - the new settings to update or	 *				string - the name of the setting to change or retrieve,	 *				when retrieving also "all" for all instance settings or	 *				"defaults" for all global defaults	 * @param  value   any - the new value for the setting	 *				(omit if above is an object or to retrieve a value)	 */	_optionDatepicker: function( target, name, value ) {		var settings, date, minDate, maxDate,			inst = this._getInst( target );		if ( arguments.length === 2 && typeof name === "string" ) {			return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :				( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :				this._get( inst, name ) ) : null ) );		}		settings = name || {};		if ( typeof name === "string" ) {			settings = {};			settings[ name ] = value;		}		if ( inst ) {			if ( this._curInst === inst ) {				this._hideDatepicker();			}			date = this._getDateDatepicker( target, true );			minDate = this._getMinMaxDate( inst, "min" );			maxDate = this._getMinMaxDate( inst, "max" );			datepicker_extendRemove( inst.settings, settings );			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn''t provided			if ( minDate !!== null && settings.dateFormat !!== undefined && settings.minDate === undefined ) {				inst.settings.minDate = this._formatDate( inst, minDate );			}			if ( maxDate !!== null && settings.dateFormat !!== undefined && settings.maxDate === undefined ) {				inst.settings.maxDate = this._formatDate( inst, maxDate );			}			if ( "disabled" in settings ) {				if ( settings.disabled ) {					this._disableDatepicker( target );				} else {					this._enableDatepicker( target );				}			}			this._attachments( $( target ), inst );			this._autoSize( inst );			this._setDate( inst, date );			this._updateAlternate( inst );			this._updateDatepicker( inst );		}	},	// Change method deprecated	_changeDatepicker: function( target, name, value ) {		this._optionDatepicker( target, name, value );	},	/* Redraw the date picker attached to an input field or division.	 * @param  target  element - the target input field or division or span	 */	_refreshDatepicker: function( target ) {		var inst = this._getInst( target );		if ( inst ) {			this._updateDatepicker( inst );		}	},	/* Set the dates for a jQuery selection.	 * @param  target element - the target input field or division or span	 * @param  date	Date - the new date	 */	_setDateDatepicker: function( target, date ) {		var inst = this._getInst( target );		if ( inst ) {			this._setDate( inst, date );			this._updateDatepicker( inst );			this._updateAlternate( inst );		}	},	/* Get the date(s) for the first entry in a jQuery selection.	 * @param  target element - the target input field or division or span	 * @param  noDefault boolean - true if no default date is to be used	 * @return Date - the current date	 */	_getDateDatepicker: function( target, noDefault ) {		var inst = this._getInst( target );		if ( inst && !!inst.inline ) {			this._setDateFromField( inst, noDefault );		}		return ( inst ? this._getDate( inst ) : null );	},	/* Handle keystrokes. */	_doKeyDown: function( event ) {		var onSelect, dateStr, sel,			inst = $.datepicker._getInst( event.target ),			handled = true,			isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );		inst._keyEvent = true;		if ( $.datepicker._datepickerShowing ) {			switch ( event.keyCode ) {				case 9: $.datepicker._hideDatepicker();						handled = false;						break; // hide on tab out				case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +									$.datepicker._currentClass + ")", inst.dpDiv );						if ( sel[ 0 ] ) {							$.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );						}						onSelect = $.datepicker._get( inst, "onSelect" );						if ( onSelect ) {							dateStr = $.datepicker._formatDate( inst );							// Trigger custom callback							onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );						} else {							$.datepicker._hideDatepicker();						}						return false; // don''t submit the form				case 27: $.datepicker._hideDatepicker();						break; // hide on escape				case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?							-$.datepicker._get( inst, "stepBigMonths" ) :							-$.datepicker._get( inst, "stepMonths" ) ), "M" );						break; // previous month/year on page up/+ ctrl				case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?							+$.datepicker._get( inst, "stepBigMonths" ) :							+$.datepicker._get( inst, "stepMonths" ) ), "M" );						break; // next month/year on page down/+ ctrl				case 35: if ( event.ctrlKey || event.metaKey ) {							$.datepicker._clearDate( event.target );						}						handled = event.ctrlKey || event.metaKey;						break; // clear on ctrl or command +end				case 36: if ( event.ctrlKey || event.metaKey ) {							$.datepicker._gotoToday( event.target );						}						handled = event.ctrlKey || event.metaKey;						break; // current on ctrl or command +home				case 37: if ( event.ctrlKey || event.metaKey ) {							$.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );						}						handled = event.ctrlKey || event.metaKey;						// -1 day on ctrl or command +left						if ( event.originalEvent.altKey ) {							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?								-$.datepicker._get( inst, "stepBigMonths" ) :								-$.datepicker._get( inst, "stepMonths" ) ), "M" );						}						// next month/year on alt +left on Mac						break;				case 38: if ( event.ctrlKey || event.metaKey ) {							$.datepicker._adjustDate( event.target, -7, "D" );						}						handled = event.ctrlKey || event.metaKey;						break; // -1 week on ctrl or command +up				case 39: if ( event.ctrlKey || event.metaKey ) {							$.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );						}						handled = event.ctrlKey || event.metaKey;						// +1 day on ctrl or command +right						if ( event.originalEvent.altKey ) {							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?								+$.datepicker._get( inst, "stepBigMonths" ) :								+$.datepicker._get( inst, "stepMonths" ) ), "M" );						}						// next month/year on alt +right						break;				case 40: if ( event.ctrlKey || event.metaKey ) {							$.datepicker._adjustDate( event.target, +7, "D" );						}						handled = event.ctrlKey || event.metaKey;						break; // +1 week on ctrl or command +down				default: handled = false;			}		} else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home			$.datepicker._showDatepicker( this );		} else {			handled = false;		}		if ( handled ) {			event.preventDefault();			event.stopPropagation();		}	},	/* Filter entered characters - based on date format. */	_doKeyPress: function( event ) {		var chars, chr,			inst = $.datepicker._getInst( event.target );		if ( $.datepicker._get( inst, "constrainInput" ) ) {			chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );			chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );			return event.ctrlKey || event.metaKey || ( chr < " " || !!chars || chars.indexOf( chr ) > -1 );		}	},	/* Synchronise manual entry and field/alternate field. */	_doKeyUp: function( event ) {		var date,			inst = $.datepicker._getInst( event.target );		if ( inst.input.val() !!== inst.lastVal ) {			try {				date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),					( inst.input ? inst.input.val() : null ),					$.datepicker._getFormatConfig( inst ) );				if ( date ) { // only if valid					$.datepicker._setDateFromField( inst );					$.datepicker._updateAlternate( inst );					$.datepicker._updateDatepicker( inst );				}			} catch ( err ) {			}		}		return true;	},	/* Pop-up the date picker for a given input field.	 * If false returned from beforeShow event handler do not show.	 * @param  input  element - the input field attached to the date picker or	 *					event - if triggered by focus	 */	_showDatepicker: function( input ) {		input = input.target || input;		if ( input.nodeName.toLowerCase() !!== "input" ) { // find from button/image trigger			input = $( "input", input.parentNode )[ 0 ];		}		if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here			return;		}		var inst, beforeShow, beforeShowSettings, isFixed,			offset, showAnim, duration;		inst = $.datepicker._getInst( input );		if ( $.datepicker._curInst && $.datepicker._curInst !!== inst ) {			$.datepicker._curInst.dpDiv.stop( true, true );			if ( inst && $.datepicker._datepickerShowing ) {				$.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );			}		}		beforeShow = $.datepicker._get( inst, "beforeShow" );		beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};		if ( beforeShowSettings === false ) {			return;		}		datepicker_extendRemove( inst.settings, beforeShowSettings );		inst.lastVal = null;		$.datepicker._lastInput = input;		$.datepicker._setDateFromField( inst );		if ( $.datepicker._inDialog ) { // hide cursor			input.value = "";		}		if ( !!$.datepicker._pos ) { // position below input			$.datepicker._pos = $.datepicker._findPos( input );			$.datepicker._pos[ 1 ] += input.offsetHeight; // add the height		}		isFixed = false;		$( input ).parents().each( function() {			isFixed |= $( this ).css( "position" ) === "fixed";			return !!isFixed;		} );		offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };		$.datepicker._pos = null;		//to avoid flashes on Firefox		inst.dpDiv.empty();		// determine sizing offscreen		inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );		$.datepicker._updateDatepicker( inst );		// fix width for dynamic number of date pickers		// and adjust position before showing		offset = $.datepicker._checkOffset( inst, offset, isFixed );		inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?			"static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",			left: offset.left + "px", top: offset.top + "px" } );		if ( !!inst.inline ) {			showAnim = $.datepicker._get( inst, "showAnim" );			duration = $.datepicker._get( inst, "duration" );			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );			$.datepicker._datepickerShowing = true;			if ( $.effects && $.effects.effect[ showAnim ] ) {				inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );			} else {				inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );			}			if ( $.datepicker._shouldFocusInput( inst ) ) {				inst.input.trigger( "focus" );			}			$.datepicker._curInst = inst;		}	},	/* Generate the date picker content. */	_updateDatepicker: function( inst ) {		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)		datepicker_instActive = inst; // for delegate hover events		inst.dpDiv.empty().append( this._generateHTML( inst ) );		this._attachHandlers( inst );		var origyearshtml,			numMonths = this._getNumberOfMonths( inst ),			cols = numMonths[ 1 ],			width = 17,			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" ),			onUpdateDatepicker = $.datepicker._get( inst, "onUpdateDatepicker" );		if ( activeCell.length > 0 ) {			datepicker_handleMouseover.apply( activeCell.get( 0 ) );		}		inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );		if ( cols > 1 ) {			inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );		}		inst.dpDiv[ ( numMonths[ 0 ] !!== 1 || numMonths[ 1 ] !!== 1 ? "add" : "remove" ) +			"Class" ]( "ui-datepicker-multi" );		inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +			"Class" ]( "ui-datepicker-rtl" );		if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {			inst.input.trigger( "focus" );		}		// Deffered render of the years select (to avoid flashes on Firefox)		if ( inst.yearshtml ) {			origyearshtml = inst.yearshtml;			setTimeout( function() {				//assure that inst.yearshtml didn''t change.				if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {					inst.dpDiv.find( "select.ui-datepicker-year" ).first().replaceWith( inst.yearshtml );				}				origyearshtml = inst.yearshtml = null;			}, 0 );		}		if ( onUpdateDatepicker ) {			onUpdateDatepicker.apply( ( inst.input ? inst.input[ 0 ] : null ), [ inst ] );		}	},	// #6694 - don''t focus the input if it''s already focused	// this breaks the change event in IE	// Support: IE and jQuery <1.9	_shouldFocusInput: function( inst ) {		return inst.input && inst.input.is( ":visible" ) && !!inst.input.is( ":disabled" ) && !!inst.input.is( ":focus" );	},	/* Check positioning to remain on screen. */	_checkOffset: function( inst, offset, isFixed ) {		var dpWidth = inst.dpDiv.outerWidth(),			dpHeight = inst.dpDiv.outerHeight(),			inputWidth = inst.input ? inst.input.outerWidth() : 0,			inputHeight = inst.input ? inst.input.outerHeight() : 0,			viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),			viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );		offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );		offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;		offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;		// Now check if datepicker is showing outside window viewport - move to a better place if so.		offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?			Math.abs( offset.left + dpWidth - viewWidth ) : 0 );		offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?			Math.abs( dpHeight + inputHeight ) : 0 );		return offset;	},	/* Find an object''s position on the screen. */	_findPos: function( obj ) {		var position,			inst = this._getInst( obj ),			isRTL = this._get( inst, "isRTL" );		while ( obj && ( obj.type === "hidden" || obj.nodeType !!== 1 || $.expr.pseudos.hidden( obj ) ) ) {			obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];		}		position = $( obj ).offset();		return [ position.left, position.top ];	},	/* Hide the date picker from view.	 * @param  input  element - the input field attached to the date picker	 */	_hideDatepicker: function( input ) {		var showAnim, duration, postProcess, onClose,			inst = this._curInst;		if ( !!inst || ( input && inst !!== $.data( input, "datepicker" ) ) ) {			return;		}		if ( this._datepickerShowing ) {			showAnim = this._get( inst, "showAnim" );			duration = this._get( inst, "duration" );			postProcess = function() {				$.datepicker._tidyDialog( inst );			};			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {				inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );			} else {				inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :					( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );			}			if ( !!showAnim ) {				postProcess();			}			this._datepickerShowing = false;			onClose = this._get( inst, "onClose" );			if ( onClose ) {				onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );			}			this._lastInput = null;			if ( this._inDialog ) {				this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );				if ( $.blockUI ) {					$.unblockUI();					$( "body" ).append( this.dpDiv );				}			}			this._inDialog = false;		}	},	/* Tidy up after a dialog display. */	_tidyDialog: function( inst ) {		inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );	},	/* Close date picker if clicked elsewhere. */	_checkExternalClick: function( event ) {		if ( !!$.datepicker._curInst ) {			return;		}		var $target = $( event.target ),			inst = $.datepicker._getInst( $target[ 0 ] );		if ( ( ( $target[ 0 ].id !!== $.datepicker._mainDivId &&				$target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&				!!$target.hasClass( $.datepicker.markerClassName ) &&				!!$target.closest( "." + $.datepicker._triggerClass ).length &&				$.datepicker._datepickerShowing && !!( $.datepicker._inDialog && $.blockUI ) ) ) ||			( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !!== inst ) ) {				$.datepicker._hideDatepicker();		}	},	/* Adjust one of the date sub-fields. */	_adjustDate: function( id, offset, period ) {		var target = $( id ),			inst = this._getInst( target[ 0 ] );		if ( this._isDisabledDatepicker( target[ 0 ] ) ) {			return;		}		this._adjustInstDate( inst, offset, period );		this._updateDatepicker( inst );	},	/* Action for current link. */	_gotoToday: function( id ) {		var date,			target = $( id ),			inst = this._getInst( target[ 0 ] );		if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {			inst.selectedDay = inst.currentDay;			inst.drawMonth = inst.selectedMonth = inst.currentMonth;			inst.drawYear = inst.selectedYear = inst.currentYear;		} else {			date = new Date();			inst.selectedDay = date.getDate();			inst.drawMonth = inst.selectedMonth = date.getMonth();			inst.drawYear = inst.selectedYear = date.getFullYear();		}		this._notifyChange( inst );		this._adjustDate( target );	},	/* Action for selecting a new month/year. */	_selectMonthYear: function( id, select, period ) {		var target = $( id ),			inst = this._getInst( target[ 0 ] );		inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =		inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =			parseInt( select.options[ select.selectedIndex ].value, 10 );		this._notifyChange( inst );		this._adjustDate( target );	},	/* Action for selecting a day. */	_selectDay: function( id, month, year, td ) {		var inst,			target = $( id );		if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {			return;		}		inst = this._getInst( target[ 0 ] );		inst.selectedDay = inst.currentDay = parseInt( $( "a", td ).attr( "data-date" ) );		inst.selectedMonth = inst.currentMonth = month;		inst.selectedYear = inst.currentYear = year;		this._selectDate( id, this._formatDate( inst,			inst.currentDay, inst.currentMonth, inst.currentYear ) );	},	/* Erase the input field and hide the date picker. */	_clearDate: function( id ) {		var target = $( id );		this._selectDate( target, "" );	},	/* Update the input field with the selected date. */	_selectDate: function( id, dateStr ) {		var onSelect,			target = $( id ),			inst = this._getInst( target[ 0 ] );		dateStr = ( dateStr !!= null ? dateStr : this._formatDate( inst ) );		if ( inst.input ) {			inst.input.val( dateStr );		}		this._updateAlternate( inst );		onSelect = this._get( inst, "onSelect" );		if ( onSelect ) {			onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback		} else if ( inst.input ) {			inst.input.trigger( "change" ); // fire the change event		}		if ( inst.inline ) {			this._updateDatepicker( inst );		} else {			this._hideDatepicker();			this._lastInput = inst.input[ 0 ];			if ( typeof( inst.input[ 0 ] ) !!== "object" ) {				inst.input.trigger( "focus" ); // restore focus			}			this._lastInput = null;		}	},	/* Update any alternate field to synchronise with the main field. */	_updateAlternate: function( inst ) {		var altFormat, date, dateStr,			altField = this._get( inst, "altField" );		if ( altField ) { // update alternate field too			altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );			date = this._getDate( inst );			dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );			$( document ).find( altField ).val( dateStr );		}	},	/* Set as beforeShowDay function to prevent selection of weekends.	 * @param  date  Date - the date to customise	 * @return [boolean, string] - is this date selectable?, what is its CSS class?	 */	noWeekends: function( date ) {		var day = date.getDay();		return [ ( day > 0 && day < 6 ), "" ];	},	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.	 * @param  date  Date - the date to get the week for	 * @return  number - the number of the week within the year that contains this date	 */	iso8601Week: function( date ) {		var time,			checkDate = new Date( date.getTime() );		// Find Thursday of this week starting on Monday		checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );		time = checkDate.getTime();		checkDate.setMonth( 0 ); // Compare with Jan 1		checkDate.setDate( 1 );		return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;	},	/* Parse a string value into a date object.	 * See formatDate below for the possible formats.	 *	 * @param  format string - the expected format of the date	 * @param  value string - the date in the above format	 * @param  settings Object - attributes include:	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)	 *					dayNames		string[7] - names of the days from Sunday (optional)	 *					monthNamesShort string[12] - abbreviated names of the months (optional)	 *					monthNames		string[12] - names of the months (optional)	 * @return  Date - the extracted date value or null if value is blank	 */	parseDate: function( format, value, settings ) {		if ( format == null || value == null ) {			throw "Invalid arguments";		}		value = ( typeof value === "object" ? value.toString() : value + "" );		if ( value === "" ) {			return null;		}		var iFormat, dim, extra,			iValue = 0,			shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,			shortYearCutoff = ( typeof shortYearCutoffTemp !!== "string" ? shortYearCutoffTemp :				new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,			year = -1,			month = -1,			day = -1,			doy = -1,			literal = false,			date,			// Check whether a format character is doubled			lookAhead = function( match ) {				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );				if ( matches ) {					iFormat++;				}				return matches;			},			// Extract a number from the string value			getNumber = function( match ) {				var isDoubled = lookAhead( match ),					size = ( match === "@" ? 14 : ( match === "!!" ? 20 :					( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),					minSize = ( match === "y" ? size : 1 ),					digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),					num = value.substring( iValue ).match( digits );				if ( !!num ) {					throw "Missing number at position " + iValue;				}				iValue += num[ 0 ].length;				return parseInt( num[ 0 ], 10 );			},			// Extract a name from the string value and convert to an index			getName = function( match, shortNames, longNames ) {				var index = -1,					names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {						return [ [ k, v ] ];					} ).sort( function( a, b ) {						return -( a[ 1 ].length - b[ 1 ].length );					} );				$.each( names, function( i, pair ) {					var name = pair[ 1 ];					if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {						index = pair[ 0 ];						iValue += name.length;						return false;					}				} );				if ( index !!== -1 ) {					return index + 1;				} else {					throw "Unknown name at position " + iValue;				}			},			// Confirm that a literal character matches the string value			checkLiteral = function() {				if ( value.charAt( iValue ) !!== format.charAt( iFormat ) ) {					throw "Unexpected literal at position " + iValue;				}				iValue++;			};		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {			if ( literal ) {				if ( format.charAt( iFormat ) === "''" && !!lookAhead( "''" ) ) {					literal = false;				} else {					checkLiteral();				}			} else {				switch ( format.charAt( iFormat ) ) {					case "d":						day = getNumber( "d" );						break;					case "D":						getName( "D", dayNamesShort, dayNames );						break;					case "o":						doy = getNumber( "o" );						break;					case "m":						month = getNumber( "m" );						break;					case "M":						month = getName( "M", monthNamesShort, monthNames );						break;					case "y":						year = getNumber( "y" );						break;					case "@":						date = new Date( getNumber( "@" ) );						year = date.getFullYear();						month = date.getMonth() + 1;						day = date.getDate();						break;					case "!!":						date = new Date( ( getNumber( "!!" ) - this._ticksTo1970 ) / 10000 );						year = date.getFullYear();						month = date.getMonth() + 1;						day = date.getDate();						break;					case "''":						if ( lookAhead( "''" ) ) {							checkLiteral();						} else {							literal = true;						}						break;					default:						checkLiteral();				}			}		}		if ( iValue < value.length ) {			extra = value.substr( iValue );			if ( !!/^\s+/.test( extra ) ) {				throw "Extra/unparsed characters found in date: " + extra;			}		}		if ( year === -1 ) {			year = new Date().getFullYear();		} else if ( year < 100 ) {			year += new Date().getFullYear() - new Date().getFullYear() % 100 +				( year <= shortYearCutoff ? 0 : -100 );		}		if ( doy > -1 ) {			month = 1;			day = doy;			do {				dim = this._getDaysInMonth( year, month - 1 );				if ( day <= dim ) {					break;				}				month++;				day -= dim;			} while ( true );		}		date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );		if ( date.getFullYear() !!== year || date.getMonth() + 1 !!== month || date.getDate() !!== day ) {			throw "Invalid date"; // E.g. 31/02/00		}		return date;	},	/* Standard date formats. */	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)	COOKIE: "D, dd M yy",	ISO_8601: "yy-mm-dd",	RFC_822: "D, d M y",	RFC_850: "DD, dd-M-y",	RFC_1036: "D, d M y",	RFC_1123: "D, d M yy",	RFC_2822: "D, d M yy",	RSS: "D, d M y", // RFC 822	TICKS: "!!",	TIMESTAMP: "@",	W3C: "yy-mm-dd", // ISO 8601	_ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +		Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),	/* Format a date object into a string value.	 * The format can be combinations of the following:	 * d  - day of month (no leading zero)	 * dd - day of month (two digit)	 * o  - day of year (no leading zeros)	 * oo - day of year (three digit)	 * D  - day name short	 * DD - day name long	 * m  - month of year (no leading zero)	 * mm - month of year (two digit)	 * M  - month name short	 * MM - month name long	 * y  - year (two digit)	 * yy - year (four digit)	 * @ - Unix timestamp (ms since 01/01/1970)	 * !! - Windows ticks (100ns since 01/01/0001)	 * "..." - literal text	 * '''' - single quote	 *	 * @param  format string - the desired format of the date	 * @param  date Date - the date value to format	 * @param  settings Object - attributes include:	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)	 *					dayNames		string[7] - names of the days from Sunday (optional)	 *					monthNamesShort string[12] - abbreviated names of the months (optional)	 *					monthNames		string[12] - names of the months (optional)	 * @return  string - the date in the above format	 */	formatDate: function( format, date, settings ) {		if ( !!date ) {			return "";		}		var iFormat,			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,			// Check whether a format character is doubled			lookAhead = function( match ) {				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );				if ( matches ) {					iFormat++;				}				return matches;			},			// Format a number, with leading zero if necessary			formatNumber = function( match, value, len ) {				var num = "" + value;				if ( lookAhead( match ) ) {					while ( num.length < len ) {						num = "0" + num;					}				}				return num;			},			// Format a name, short or long as requested			formatName = function( match, value, shortNames, longNames ) {				return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );			},			output = "",			literal = false;		if ( date ) {			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {				if ( literal ) {					if ( format.charAt( iFormat ) === "''" && !!lookAhead( "''" ) ) {						literal = false;					} else {						output += format.charAt( iFormat );					}				} else {					switch ( format.charAt( iFormat ) ) {						case "d":							output += formatNumber( "d", date.getDate(), 2 );							break;						case "D":							output += formatName( "D", date.getDay(), dayNamesShort, dayNames );							break;						case "o":							output += formatNumber( "o",								Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );							break;						case "m":							output += formatNumber( "m", date.getMonth() + 1, 2 );							break;						case "M":							output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );							break;						case "y":							output += ( lookAhead( "y" ) ? date.getFullYear() :								( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );							break;						case "@":							output += date.getTime();							break;						case "!!":							output += date.getTime() * 10000 + this._ticksTo1970;							break;						case "''":							if ( lookAhead( "''" ) ) {								output += "''";							} else {								literal = true;							}							break;						default:							output += format.charAt( iFormat );					}				}			}		}		return output;	},	/* Extract all possible characters from the date format. */	_possibleChars: function( format ) {		var iFormat,			chars = "",			literal = false,			// Check whether a format character is doubled			lookAhead = function( match ) {				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );				if ( matches ) {					iFormat++;				}				return matches;			};		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {			if ( literal ) {				if ( format.charAt( iFormat ) === "''" && !!lookAhead( "''" ) ) {					literal = false;				} else {					chars += format.charAt( iFormat );				}			} else {				switch ( format.charAt( iFormat ) ) {					case "d": case "m": case "y": case "@":						chars += "0123456789";						break;					case "D": case "M":						return null; // Accept anything					case "''":						if ( lookAhead( "''" ) ) {							chars += "''";						} else {							literal = true;						}						break;					default:						chars += format.charAt( iFormat );				}			}		}		return chars;	},	/* Get a setting value, defaulting if necessary. */	_get: function( inst, name ) {		return inst.settings[ name ] !!== undefined ?			inst.settings[ name ] : this._defaults[ name ];	},	/* Parse existing date and initialise date picker. */	_setDateFromField: function( inst, noDefault ) {		if ( inst.input.val() === inst.lastVal ) {			return;		}		var dateFormat = this._get( inst, "dateFormat" ),			dates = inst.lastVal = inst.input ? inst.input.val() : null,			defaultDate = this._getDefaultDate( inst ),			date = defaultDate,			settings = this._getFormatConfig( inst );		try {			date = this.parseDate( dateFormat, dates, settings ) || defaultDate;		} catch ( event ) {			dates = ( noDefault ? "" : dates );		}		inst.selectedDay = date.getDate();		inst.drawMonth = inst.selectedMonth = date.getMonth();		inst.drawYear = inst.selectedYear = date.getFullYear();		inst.currentDay = ( dates ? date.getDate() : 0 );		inst.currentMonth = ( dates ? date.getMonth() : 0 );		inst.currentYear = ( dates ? date.getFullYear() : 0 );		this._adjustInstDate( inst );	},	/* Retrieve the default date shown on opening. */	_getDefaultDate: function( inst ) {		return this._restrictMinMax( inst,			this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );	},	/* A date may be specified as an exact value or a relative one. */	_determineDate: function( inst, date, defaultDate ) {		var offsetNumeric = function( offset ) {				var date = new Date();				date.setDate( date.getDate() + offset );				return date;			},			offsetString = function( offset ) {				try {					return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),						offset, $.datepicker._getFormatConfig( inst ) );				} catch ( e ) {					// Ignore				}				var date = ( offset.toLowerCase().match( /^c/ ) ?					$.datepicker._getDate( inst ) : null ) || new Date(),					year = date.getFullYear(),					month = date.getMonth(),					day = date.getDate(),					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,					matches = pattern.exec( offset );				while ( matches ) {					switch ( matches[ 2 ] || "d" ) {						case "d" : case "D" :							day += parseInt( matches[ 1 ], 10 ); break;						case "w" : case "W" :							day += parseInt( matches[ 1 ], 10 ) * 7; break;						case "m" : case "M" :							month += parseInt( matches[ 1 ], 10 );							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );							break;						case "y": case "Y" :							year += parseInt( matches[ 1 ], 10 );							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );							break;					}					matches = pattern.exec( offset );				}				return new Date( year, month, day );			},			newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :				( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );		newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );		if ( newDate ) {			newDate.setHours( 0 );			newDate.setMinutes( 0 );			newDate.setSeconds( 0 );			newDate.setMilliseconds( 0 );		}		return this._daylightSavingAdjust( newDate );	},	/* Handle switch to/from daylight saving.	 * Hours may be non-zero on daylight saving cut-over:	 * > 12 when midnight changeover, but then cannot generate	 * midnight datetime, so jump to 1AM, otherwise reset.	 * @param  date  (Date) the date to check	 * @return  (Date) the corrected date	 */	_daylightSavingAdjust: function( date ) {		if ( !!date ) {			return null;		}		date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );		return date;	},	/* Set the date(s) directly. */	_setDate: function( inst, date, noChange ) {		var clear = !!date,			origMonth = inst.selectedMonth,			origYear = inst.selectedYear,			newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );		inst.selectedDay = inst.currentDay = newDate.getDate();		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();		if ( ( origMonth !!== inst.selectedMonth || origYear !!== inst.selectedYear ) && !!noChange ) {			this._notifyChange( inst );		}		this._adjustInstDate( inst );		if ( inst.input ) {			inst.input.val( clear ? "" : this._formatDate( inst ) );		}	},	/* Retrieve the date(s) directly. */	_getDate: function( inst ) {		var startDate = ( !!inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :			this._daylightSavingAdjust( new Date(			inst.currentYear, inst.currentMonth, inst.currentDay ) ) );			return startDate;	},	/* Attach the onxxx handlers.  These are declared statically so	 * they work with static code transformers like Caja.	 */	_attachHandlers: function( inst ) {		var stepMonths = this._get( inst, "stepMonths" ),			id = "#" + inst.id.replace( /\\\\/g, "\\" );		inst.dpDiv.find( "[data-handler]" ).map( function() {			var handler = {				prev: function() {					$.datepicker._adjustDate( id, -stepMonths, "M" );				},				next: function() {					$.datepicker._adjustDate( id, +stepMonths, "M" );				},				hide: function() {					$.datepicker._hideDatepicker();				},				today: function() {					$.datepicker._gotoToday( id );				},				selectDay: function() {					$.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );					return false;				},				selectMonth: function() {					$.datepicker._selectMonthYear( id, this, "M" );					return false;				},				selectYear: function() {					$.datepicker._selectMonthYear( id, this, "Y" );					return false;				}			};			$( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );		} );	},	/* Generate the HTML for the current state of the date picker. */	_generateHTML: function( inst ) {		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,			printDate, dRow, tbody, daySettings, otherMonth, unselectable,			tempDate = new Date(),			today = this._daylightSavingAdjust(				new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time			isRTL = this._get( inst, "isRTL" ),			showButtonPanel = this._get( inst, "showButtonPanel" ),			hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),			navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),			numMonths = this._getNumberOfMonths( inst ),			showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),			stepMonths = this._get( inst, "stepMonths" ),			isMultiMonth = ( numMonths[ 0 ] !!== 1 || numMonths[ 1 ] !!== 1 ),			currentDate = this._daylightSavingAdjust( ( !!inst.currentDay ? new Date( 9999, 9, 9 ) :				new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),			minDate = this._getMinMaxDate( inst, "min" ),			maxDate = this._getMinMaxDate( inst, "max" ),			drawMonth = inst.drawMonth - showCurrentAtPos,			drawYear = inst.drawYear;		if ( drawMonth < 0 ) {			drawMonth += 12;			drawYear--;		}		if ( maxDate ) {			maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),				maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );			maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );			while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {				drawMonth--;				if ( drawMonth < 0 ) {					drawMonth = 11;					drawYear--;				}			}		}		inst.drawMonth = drawMonth;		inst.drawYear = drawYear;		prevText = this._get( inst, "prevText" );		prevText = ( !!navigationAsDateFormat ? prevText : this.formatDate( prevText,			this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),			this._getFormatConfig( inst ) ) );		if ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ) {			prev = $( "<a>" )				.attr( {					"class": "ui-datepicker-prev ui-corner-all",					"data-handler": "prev",					"data-event": "click",					title: prevText				} )				.append(					$( "<span>" )						.addClass( "ui-icon ui-icon-circle-triangle-" +							( isRTL ? "e" : "w" ) )						.text( prevText )				)[ 0 ].outerHTML;		} else if ( hideIfNoPrevNext ) {			prev = "";		} else {			prev = $( "<a>" )				.attr( {					"class": "ui-datepicker-prev ui-corner-all ui-state-disabled",					title: prevText				} )				.append(					$( "<span>" )						.addClass( "ui-icon ui-icon-circle-triangle-" +							( isRTL ? "e" : "w" ) )						.text( prevText )				)[ 0 ].outerHTML;		}		nextText = this._get( inst, "nextText" );		nextText = ( !!navigationAsDateFormat ? nextText : this.formatDate( nextText,			this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),			this._getFormatConfig( inst ) ) );		if ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ) {			next = $( "<a>" )				.attr( {					"class": "ui-datepicker-next ui-corner-all",					"data-handler": "next",					"data-event": "click",					title: nextText				} )				.append(					$( "<span>" )						.addClass( "ui-icon ui-icon-circle-triangle-" +							( isRTL ? "w" : "e" ) )						.text( nextText )				)[ 0 ].outerHTML;		} else if ( hideIfNoPrevNext ) {			next = "";		} else {			next = $( "<a>" )				.attr( {					"class": "ui-datepicker-next ui-corner-all ui-state-disabled",					title: nextText				} )				.append(					$( "<span>" )						.attr( "class", "ui-icon ui-icon-circle-triangle-" +							( isRTL ? "w" : "e" ) )						.text( nextText )				)[ 0 ].outerHTML;		}		currentText = this._get( inst, "currentText" );		gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );		currentText = ( !!navigationAsDateFormat ? currentText :			this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );		controls = "";		if ( !!inst.inline ) {			controls = $( "<button>" )				.attr( {					type: "button",					"class": "ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all",					"data-handler": "hide",					"data-event": "click"				} )				.text( this._get( inst, "closeText" ) )[ 0 ].outerHTML;		}		buttonPanel = "";		if ( showButtonPanel ) {			buttonPanel = $( "<div class=''ui-datepicker-buttonpane ui-widget-content''>" )				.append( isRTL ? controls : "" )				.append( this._isInRange( inst, gotoDate ) ?					$( "<button>" )						.attr( {							type: "button",							"class": "ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all",							"data-handler": "today",							"data-event": "click"						} )						.text( currentText ) :					"" )				.append( isRTL ? "" : controls )[ 0 ].outerHTML;		}		firstDay = parseInt( this._get( inst, "firstDay" ), 10 );		firstDay = ( isNaN( firstDay ) ? 0 : firstDay );		showWeek = this._get( inst, "showWeek" );		dayNames = this._get( inst, "dayNames" );		dayNamesMin = this._get( inst, "dayNamesMin" );		monthNames = this._get( inst, "monthNames" );		monthNamesShort = this._get( inst, "monthNamesShort" );		beforeShowDay = this._get( inst, "beforeShowDay" );		showOtherMonths = this._get( inst, "showOtherMonths" );		selectOtherMonths = this._get( inst, "selectOtherMonths" );		defaultDate = this._getDefaultDate( inst );		html = "";		for ( row = 0; row < numMonths[ 0 ]; row++ ) {			group = "";			this.maxRows = 4;			for ( col = 0; col < numMonths[ 1 ]; col++ ) {				selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );				cornerClass = " ui-corner-all";				calender = "";				if ( isMultiMonth ) {					calender += "<div class=''ui-datepicker-group";					if ( numMonths[ 1 ] > 1 ) {						switch ( col ) {							case 0: calender += " ui-datepicker-group-first";								cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;							case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";								cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;						}					}					calender += "''>";				}				calender += "<div class=''ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "''>" +					( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +					( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +					this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,					row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers					"</div><table class=''ui-datepicker-calendar''><thead>" +					"<tr>";				thead = ( showWeek ? "<th class=''ui-datepicker-week-col''>" + this._get( inst, "weekHeader" ) + "</th>" : "" );				for ( dow = 0; dow < 7; dow++ ) { // days of the week					day = ( dow + firstDay ) % 7;					thead += "<th scope=''col''" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class=''ui-datepicker-week-end''" : "" ) + ">" +						"<span title=''" + dayNames[ day ] + "''>" + dayNamesMin[ day ] + "</span></th>";				}				calender += thead + "</tr></thead><tbody>";				daysInMonth = this._getDaysInMonth( drawYear, drawMonth );				if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {					inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );				}				leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;				curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate				numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)				this.maxRows = numRows;				printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );				for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows					calender += "<tr>";					tbody = ( !!showWeek ? "" : "<td class=''ui-datepicker-week-col''>" +						this._get( inst, "calculateWeek" )( printDate ) + "</td>" );					for ( dow = 0; dow < 7; dow++ ) { // create date picker days						daySettings = ( beforeShowDay ?							beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );						otherMonth = ( printDate.getMonth() !!== drawMonth );						unselectable = ( otherMonth && !!selectOtherMonths ) || !!daySettings[ 0 ] ||							( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );						tbody += "<td class=''" +							( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends							( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months							( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key							( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?							// or defaultDate is current printedDate and defaultDate is selectedDate							" " + this._dayOverClass : "" ) + // highlight selected day							( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days							( otherMonth && !!showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates							( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day							( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "''" + // highlight today (if different)							( ( !!otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title=''" + daySettings[ 2 ].replace( /''/g, "&#39;" ) + "''" : "" ) + // cell title							( unselectable ? "" : " data-handler=''selectDay'' data-event=''click'' data-month=''" + printDate.getMonth() + "'' data-year=''" + printDate.getFullYear() + "''" ) + ">" + // actions							( otherMonth && !!showOtherMonths ? "&#xa0;" : // display for other months							( unselectable ? "<span class=''ui-state-default''>" + printDate.getDate() + "</span>" : "<a class=''ui-state-default" +							( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +							( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day							( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months							"'' href=''#'' aria-current=''" + ( printDate.getTime() === currentDate.getTime() ? "true" : "false" ) + // mark date as selected for screen reader							"'' data-date=''" + printDate.getDate() + // store date as data							"''>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date						printDate.setDate( printDate.getDate() + 1 );						printDate = this._daylightSavingAdjust( printDate );					}					calender += tbody + "</tr>";				}				drawMonth++;				if ( drawMonth > 11 ) {					drawMonth = 0;					drawYear++;				}				calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +							( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class=''ui-datepicker-row-break''></div>" : "" ) : "" );				group += calender;			}			html += group;		}		html += buttonPanel;		inst._keyEvent = false;		return html;	},	/* Generate the month and year header. */	_generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,			secondary, monthNames, monthNamesShort ) {		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,			changeMonth = this._get( inst, "changeMonth" ),			changeYear = this._get( inst, "changeYear" ),			showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),			selectMonthLabel = this._get( inst, "selectMonthLabel" ),			selectYearLabel = this._get( inst, "selectYearLabel" ),			html = "<div class=''ui-datepicker-title''>",			monthHtml = "";		// Month selection		if ( secondary || !!changeMonth ) {			monthHtml += "<span class=''ui-datepicker-month''>" + monthNames[ drawMonth ] + "</span>";		} else {			inMinYear = ( minDate && minDate.getFullYear() === drawYear );			inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );			monthHtml += "<select class=''ui-datepicker-month'' aria-label=''" + selectMonthLabel + "'' data-handler=''selectMonth'' data-event=''change''>";			for ( month = 0; month < 12; month++ ) {				if ( ( !!inMinYear || month >= minDate.getMonth() ) && ( !!inMaxYear || month <= maxDate.getMonth() ) ) {					monthHtml += "<option value=''" + month + "''" +						( month === drawMonth ? " selected=''selected''" : "" ) +						">" + monthNamesShort[ month ] + "</option>";				}			}			monthHtml += "</select>";		}		if ( !!showMonthAfterYear ) {			html += monthHtml + ( secondary || !!( changeMonth && changeYear ) ? "&#xa0;" : "" );		}		// Year selection		if ( !!inst.yearshtml ) {			inst.yearshtml = "";			if ( secondary || !!changeYear ) {				html += "<span class=''ui-datepicker-year''>" + drawYear + "</span>";			} else {				// determine range of years to display				years = this._get( inst, "yearRange" ).split( ":" );				thisYear = new Date().getFullYear();				determineYear = function( value ) {					var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :						( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :						parseInt( value, 10 ) ) );					return ( isNaN( year ) ? thisYear : year );				};				year = determineYear( years[ 0 ] );				endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );				year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );				endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );				inst.yearshtml += "<select class=''ui-datepicker-year'' aria-label=''" + selectYearLabel + "'' data-handler=''selectYear'' data-event=''change''>";				for ( ; year <= endYear; year++ ) {					inst.yearshtml += "<option value=''" + year + "''" +						( year === drawYear ? " selected=''selected''" : "" ) +						">" + year + "</option>";				}				inst.yearshtml += "</select>";				html += inst.yearshtml;				inst.yearshtml = null;			}		}		html += this._get( inst, "yearSuffix" );		if ( showMonthAfterYear ) {			html += ( secondary || !!( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;		}		html += "</div>"; // Close datepicker_header		return html;	},	/* Adjust one of the date sub-fields. */	_adjustInstDate: function( inst, offset, period ) {		var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),			month = inst.selectedMonth + ( period === "M" ? offset : 0 ),			day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),			date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );		inst.selectedDay = date.getDate();		inst.drawMonth = inst.selectedMonth = date.getMonth();		inst.drawYear = inst.selectedYear = date.getFullYear();		if ( period === "M" || period === "Y" ) {			this._notifyChange( inst );		}	},	/* Ensure a date is within any min/max bounds. */	_restrictMinMax: function( inst, date ) {		var minDate = this._getMinMaxDate( inst, "min" ),			maxDate = this._getMinMaxDate( inst, "max" ),			newDate = ( minDate && date < minDate ? minDate : date );		return ( maxDate && newDate > maxDate ? maxDate : newDate );	},	/* Notify change of month/year. */	_notifyChange: function( inst ) {		var onChange = this._get( inst, "onChangeMonthYear" );		if ( onChange ) {			onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),				[ inst.selectedYear, inst.selectedMonth + 1, inst ] );		}	},	/* Determine the number of months to show. */	_getNumberOfMonths: function( inst ) {		var numMonths = this._get( inst, "numberOfMonths" );		return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );	},	/* Determine the current maximum date - ensure no time components are set. */	_getMinMaxDate: function( inst, minMax ) {		return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );	},	/* Find the number of days in a given month. */	_getDaysInMonth: function( year, month ) {		return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();	},	/* Find the day of the week of the first of a month. */	_getFirstDayOfMonth: function( year, month ) {		return new Date( year, month, 1 ).getDay();	},	/* Determines if we should allow a "next/prev" month display change. */	_canAdjustMonth: function( inst, offset, curYear, curMonth ) {		var numMonths = this._getNumberOfMonths( inst ),			date = this._daylightSavingAdjust( new Date( curYear,			curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );		if ( offset < 0 ) {			date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );		}		return this._isInRange( inst, date );	},	/* Is the given date in the accepted range? */	_isInRange: function( inst, date ) {		var yearSplit, currentYear,			minDate = this._getMinMaxDate( inst, "min" ),			maxDate = this._getMinMaxDate( inst, "max" ),			minYear = null,			maxYear = null,			years = this._get( inst, "yearRange" );			if ( years ) {				yearSplit = years.split( ":" );				currentYear = new Date().getFullYear();				minYear = parseInt( yearSplit[ 0 ], 10 );				maxYear = parseInt( yearSplit[ 1 ], 10 );				if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {					minYear += currentYear;				}				if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {					maxYear += currentYear;				}			}		return ( ( !!minDate || date.getTime() >= minDate.getTime() ) &&			( !!maxDate || date.getTime() <= maxDate.getTime() ) &&			( !!minYear || date.getFullYear() >= minYear ) &&			( !!maxYear || date.getFullYear() <= maxYear ) );	},	/* Provide the configuration settings for formatting/parsing. */	_getFormatConfig: function( inst ) {		var shortYearCutoff = this._get( inst, "shortYearCutoff" );		shortYearCutoff = ( typeof shortYearCutoff !!== "string" ? shortYearCutoff :			new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );		return { shortYearCutoff: shortYearCutoff,			dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),			monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };	},	/* Format the given date for display. */	_formatDate: function( inst, day, month, year ) {		if ( !!day ) {			inst.currentDay = inst.selectedDay;			inst.currentMonth = inst.selectedMonth;			inst.currentYear = inst.selectedYear;		}		var date = ( day ? ( typeof day === "object" ? day :			this._daylightSavingAdjust( new Date( year, month, day ) ) ) :			this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );		return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );	}} );/* * Bind hover events for datepicker elements. * Done via delegate so the binding only occurs once in the lifetime of the parent div. * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker. */function datepicker_bindHover( dpDiv ) {	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";	return dpDiv.on( "mouseout", selector, function() {			$( this ).removeClass( "ui-state-hover" );			if ( this.className.indexOf( "ui-datepicker-prev" ) !!== -1 ) {				$( this ).removeClass( "ui-datepicker-prev-hover" );			}			if ( this.className.indexOf( "ui-datepicker-next" ) !!== -1 ) {				$( this ).removeClass( "ui-datepicker-next-hover" );			}		} )		.on( "mouseover", selector, datepicker_handleMouseover );}function datepicker_handleMouseover() {	if ( !!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {		$( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );		$( this ).addClass( "ui-state-hover" );		if ( this.className.indexOf( "ui-datepicker-prev" ) !!== -1 ) {			$( this ).addClass( "ui-datepicker-prev-hover" );		}		if ( this.className.indexOf( "ui-datepicker-next" ) !!== -1 ) {			$( this ).addClass( "ui-datepicker-next-hover" );		}	}}/* jQuery extend now ignores nulls!! */function datepicker_extendRemove( target, props ) {	$.extend( target, props );	for ( var name in props ) {		if ( props[ name ] == null ) {			target[ name ] = props[ name ];		}	}	return target;}/* Invoke the datepicker functionality.   @param  options  string - a command, optionally followed by additional parameters or					Object - settings for attaching new datepicker functionality   @return  jQuery object */$.fn.datepicker = function( options ) {	/* Verify an empty collection wasn''t passed - Fixes #6976 */	if ( !!this.length ) {		return this;	}	/* Initialise the date picker. */	if ( !!$.datepicker.initialized ) {		$( document ).on( "mousedown", $.datepicker._checkExternalClick );		$.datepicker.initialized = true;	}	/* Append datepicker main container to body if not exist. */	if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {		$( "body" ).append( $.datepicker.dpDiv );	}	var otherArgs = Array.prototype.slice.call( arguments, 1 );	if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {		return $.datepicker[ "_" + options + "Datepicker" ].			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );	}	if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {		return $.datepicker[ "_" + options + "Datepicker" ].			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );	}	return this.each( function() {		if ( typeof options === "string" ) {			$.datepicker[ "_" + options + "Datepicker" ]				.apply( $.datepicker, [ this ].concat( otherArgs ) );		} else {			$.datepicker._attachDatepicker( this, options );		}	} );};$.datepicker = new Datepicker(); // singleton instance$.datepicker.initialized = false;$.datepicker.uuid = new Date().getTime();$.datepicker.version = "1.13.2";var widgetsDatepicker = $.datepicker;// This file is deprecatedvar ie = $.ui.ie = !!!!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );/*!! * jQuery UI Mouse 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Mouse//>>group: Widgets//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.//>>docs: http://api.jqueryui.com/mouse/var mouseHandled = false;$( document ).on( "mouseup", function() {	mouseHandled = false;} );var widgetsMouse = $.widget( "ui.mouse", {	version: "1.13.2",	options: {		cancel: "input, textarea, button, select, option",		distance: 1,		delay: 0	},	_mouseInit: function() {		var that = this;		this.element			.on( "mousedown." + this.widgetName, function( event ) {				return that._mouseDown( event );			} )			.on( "click." + this.widgetName, function( event ) {				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {					$.removeData( event.target, that.widgetName + ".preventClickEvent" );					event.stopImmediatePropagation();					return false;				}			} );		this.started = false;	},	// TODO: make sure destroying one instance of mouse doesn''t mess with	// other instances of mouse	_mouseDestroy: function() {		this.element.off( "." + this.widgetName );		if ( this._mouseMoveDelegate ) {			this.document				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );		}	},	_mouseDown: function( event ) {		// don''t let more than one widget handle mouseStart		if ( mouseHandled ) {			return;		}		this._mouseMoved = false;		// We may have missed mouseup (out of window)		if ( this._mouseStarted ) {			this._mouseUp( event );		}		this._mouseDownEvent = event;		var that = this,			btnIsLeft = ( event.which === 1 ),			// event.target.nodeName works around a bug in IE 8 with			// disabled inputs (#7620)			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?				$( event.target ).closest( this.options.cancel ).length : false );		if ( !!btnIsLeft || elIsCancel || !!this._mouseCapture( event ) ) {			return true;		}		this.mouseDelayMet = !!this.options.delay;		if ( !!this.mouseDelayMet ) {			this._mouseDelayTimer = setTimeout( function() {				that.mouseDelayMet = true;			}, this.options.delay );		}		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {			this._mouseStarted = ( this._mouseStart( event ) !!== false );			if ( !!this._mouseStarted ) {				event.preventDefault();				return true;			}		}		// Click event may never have fired (Gecko & Opera)		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {			$.removeData( event.target, this.widgetName + ".preventClickEvent" );		}		// These delegates are required to keep context		this._mouseMoveDelegate = function( event ) {			return that._mouseMove( event );		};		this._mouseUpDelegate = function( event ) {			return that._mouseUp( event );		};		this.document			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );		event.preventDefault();		mouseHandled = true;		return true;	},	_mouseMove: function( event ) {		// Only check for mouseups outside the document if you''ve moved inside the document		// at least once. This prevents the firing of mouseup in the case of IE<9, which will		// fire a mousemove event if content is placed under the cursor. See #7778		// Support: IE <9		if ( this._mouseMoved ) {			// IE mouseup check - mouseup happened when mouse was out of window			if ( $.ui.ie && ( !!document.documentMode || document.documentMode < 9 ) &&					!!event.button ) {				return this._mouseUp( event );			// Iframe mouseup check - mouseup occurred in another document			} else if ( !!event.which ) {				// Support: Safari <=8 - 9				// Safari sets which to 0 if you press any of the following keys				// during a drag (#14461)				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {					this.ignoreMissingWhich = true;				} else if ( !!this.ignoreMissingWhich ) {					return this._mouseUp( event );				}			}		}		if ( event.which || event.button ) {			this._mouseMoved = true;		}		if ( this._mouseStarted ) {			this._mouseDrag( event );			return event.preventDefault();		}		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {			this._mouseStarted =				( this._mouseStart( this._mouseDownEvent, event ) !!== false );			if ( this._mouseStarted ) {				this._mouseDrag( event );			} else {				this._mouseUp( event );			}		}		return !!this._mouseStarted;	},	_mouseUp: function( event ) {		this.document			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );		if ( this._mouseStarted ) {			this._mouseStarted = false;			if ( event.target === this._mouseDownEvent.target ) {				$.data( event.target, this.widgetName + ".preventClickEvent", true );			}			this._mouseStop( event );		}		if ( this._mouseDelayTimer ) {			clearTimeout( this._mouseDelayTimer );			delete this._mouseDelayTimer;		}		this.ignoreMissingWhich = false;		mouseHandled = false;		event.preventDefault();	},	_mouseDistanceMet: function( event ) {		return ( Math.max(				Math.abs( this._mouseDownEvent.pageX - event.pageX ),				Math.abs( this._mouseDownEvent.pageY - event.pageY )			) >= this.options.distance		);	},	_mouseDelayMet: function( /* event */ ) {		return this.mouseDelayMet;	},	// These are placeholder methods, to be overriden by extending plugin	_mouseStart: function( /* event */ ) {},	_mouseDrag: function( /* event */ ) {},	_mouseStop: function( /* event */ ) {},	_mouseCapture: function( /* event */ ) {		return true;	}} );// $.ui.plugin is deprecated. Use $.widget() extensions instead.var plugin = $.ui.plugin = {	add: function( module, option, set ) {		var i,			proto = $.ui[ module ].prototype;		for ( i in set ) {			proto.plugins[ i ] = proto.plugins[ i ] || [];			proto.plugins[ i ].push( [ option, set[ i ] ] );		}	},	call: function( instance, name, args, allowDisconnected ) {		var i,			set = instance.plugins[ name ];		if ( !!set ) {			return;		}		if ( !!allowDisconnected && ( !!instance.element[ 0 ].parentNode ||				instance.element[ 0 ].parentNode.nodeType === 11 ) ) {			return;		}		for ( i = 0; i < set.length; i++ ) {			if ( instance.options[ set[ i ][ 0 ] ] ) {				set[ i ][ 1 ].apply( instance.element, args );			}		}	}};var safeBlur = $.ui.safeBlur = function( element ) {	// Support: IE9 - 10 only	// If the <body> is blurred, IE will switch windows, see #9420	if ( element && element.nodeName.toLowerCase() !!== "body" ) {		$( element ).trigger( "blur" );	}};/*!! * jQuery UI Draggable 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Draggable//>>group: Interactions//>>description: Enables dragging functionality for any element.//>>docs: http://api.jqueryui.com/draggable///>>demos: http://jqueryui.com/draggable///>>css.structure: ../../themes/base/draggable.css$.widget( "ui.draggable", $.ui.mouse, {	version: "1.13.2",	widgetEventPrefix: "drag",	options: {		addClasses: true,		appendTo: "parent",		axis: false,		connectToSortable: false,		containment: false,		cursor: "auto",		cursorAt: false,		grid: false,		handle: false,		helper: "original",		iframeFix: false,		opacity: false,		refreshPositions: false,		revert: false,		revertDuration: 500,		scope: "default",		scroll: true,		scrollSensitivity: 20,		scrollSpeed: 20,		snap: false,		snapMode: "both",		snapTolerance: 20,		stack: false,		zIndex: false,		// Callbacks		drag: null,		start: null,		stop: null	},	_create: function() {		if ( this.options.helper === "original" ) {			this._setPositionRelative();		}		if ( this.options.addClasses ) {			this._addClass( "ui-draggable" );		}		this._setHandleClassName();		this._mouseInit();	},	_setOption: function( key, value ) {		this._super( key, value );		if ( key === "handle" ) {			this._removeHandleClassName();			this._setHandleClassName();		}	},	_destroy: function() {		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {			this.destroyOnClear = true;			return;		}		this._removeHandleClassName();		this._mouseDestroy();	},	_mouseCapture: function( event ) {		var o = this.options;		// Among others, prevent a drag on a resizable-handle		if ( this.helper || o.disabled ||				$( event.target ).closest( ".ui-resizable-handle" ).length > 0 ) {			return false;		}		//Quit if we''re not on a valid handle		this.handle = this._getHandle( event );		if ( !!this.handle ) {			return false;		}		this._blurActiveElement( event );		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );		return true;	},	_blockFrames: function( selector ) {		this.iframeBlocks = this.document.find( selector ).map( function() {			var iframe = $( this );			return $( "<div>" )				.css( "position", "absolute" )				.appendTo( iframe.parent() )				.outerWidth( iframe.outerWidth() )				.outerHeight( iframe.outerHeight() )				.offset( iframe.offset() )[ 0 ];		} );	},	_unblockFrames: function() {		if ( this.iframeBlocks ) {			this.iframeBlocks.remove();			delete this.iframeBlocks;		}	},	_blurActiveElement: function( event ) {		var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),			target = $( event.target );		// Don''t blur if the event occurred on an element that is within		// the currently focused element		// See #10527, #12472		if ( target.closest( activeElement ).length ) {			return;		}		// Blur any element that currently has focus, see #4261		$.ui.safeBlur( activeElement );	},	_mouseStart: function( event ) {		var o = this.options;		//Create and append the visible helper		this.helper = this._createHelper( event );		this._addClass( this.helper, "ui-draggable-dragging" );		//Cache the helper size		this._cacheHelperProportions();		//If ddmanager is used for droppables, set the global draggable		if ( $.ui.ddmanager ) {			$.ui.ddmanager.current = this;		}		/*		 * - Position generation -		 * This block generates everything position related - it''s the core of draggables.		 */		//Cache the margins of the original element		this._cacheMargins();		//Store the helper''s css position		this.cssPosition = this.helper.css( "position" );		this.scrollParent = this.helper.scrollParent( true );		this.offsetParent = this.helper.offsetParent();		this.hasFixedAncestor = this.helper.parents().filter( function() {				return $( this ).css( "position" ) === "fixed";			} ).length > 0;		//The element''s absolute position on the page minus margins		this.positionAbs = this.element.offset();		this._refreshOffsets( event );		//Generate the original position		this.originalPosition = this.position = this._generatePosition( event, false );		this.originalPageX = event.pageX;		this.originalPageY = event.pageY;		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied		if ( o.cursorAt ) {			this._adjustOffsetFromHelper( o.cursorAt );		}		//Set a containment if given in the options		this._setContainment();		//Trigger event + callbacks		if ( this._trigger( "start", event ) === false ) {			this._clear();			return false;		}		//Recache the helper size		this._cacheHelperProportions();		//Prepare the droppable offsets		if ( $.ui.ddmanager && !!o.dropBehaviour ) {			$.ui.ddmanager.prepareOffsets( this, event );		}		// Execute the drag once - this causes the helper not to be visible before getting its		// correct position		this._mouseDrag( event, true );		// If the ddmanager is used for droppables, inform the manager that dragging has started		// (see #5003)		if ( $.ui.ddmanager ) {			$.ui.ddmanager.dragStart( this, event );		}		return true;	},	_refreshOffsets: function( event ) {		this.offset = {			top: this.positionAbs.top - this.margins.top,			left: this.positionAbs.left - this.margins.left,			scroll: false,			parent: this._getParentOffset(),			relative: this._getRelativeOffset()		};		this.offset.click = {			left: event.pageX - this.offset.left,			top: event.pageY - this.offset.top		};	},	_mouseDrag: function( event, noPropagation ) {		// reset any necessary cached properties (see #5009)		if ( this.hasFixedAncestor ) {			this.offset.parent = this._getParentOffset();		}		//Compute the helpers position		this.position = this._generatePosition( event, true );		this.positionAbs = this._convertPositionTo( "absolute" );		//Call plugins and callbacks and use the resulting position if something is returned		if ( !!noPropagation ) {			var ui = this._uiHash();			if ( this._trigger( "drag", event, ui ) === false ) {				this._mouseUp( new $.Event( "mouseup", event ) );				return false;			}			this.position = ui.position;		}		this.helper[ 0 ].style.left = this.position.left + "px";		this.helper[ 0 ].style.top = this.position.top + "px";		if ( $.ui.ddmanager ) {			$.ui.ddmanager.drag( this, event );		}		return false;	},	_mouseStop: function( event ) {		//If we are using droppables, inform the manager about the drop		var that = this,			dropped = false;		if ( $.ui.ddmanager && !!this.options.dropBehaviour ) {			dropped = $.ui.ddmanager.drop( this, event );		}		//if a drop comes from outside (a sortable)		if ( this.dropped ) {			dropped = this.dropped;			this.dropped = false;		}		if ( ( this.options.revert === "invalid" && !!dropped ) ||				( this.options.revert === "valid" && dropped ) ||				this.options.revert === true || ( typeof this.options.revert === "function" &&				this.options.revert.call( this.element, dropped ) )		) {			$( this.helper ).animate(				this.originalPosition,				parseInt( this.options.revertDuration, 10 ),				function() {					if ( that._trigger( "stop", event ) !!== false ) {						that._clear();					}				}			);		} else {			if ( this._trigger( "stop", event ) !!== false ) {				this._clear();			}		}		return false;	},	_mouseUp: function( event ) {		this._unblockFrames();		// If the ddmanager is used for droppables, inform the manager that dragging has stopped		// (see #5003)		if ( $.ui.ddmanager ) {			$.ui.ddmanager.dragStop( this, event );		}		// Only need to focus if the event occurred on the draggable itself, see #10527		if ( this.handleElement.is( event.target ) ) {			// The interaction is over; whether or not the click resulted in a drag,			// focus the element			this.element.trigger( "focus" );		}		return $.ui.mouse.prototype._mouseUp.call( this, event );	},	cancel: function() {		if ( this.helper.is( ".ui-draggable-dragging" ) ) {			this._mouseUp( new $.Event( "mouseup", { target: this.element[ 0 ] } ) );		} else {			this._clear();		}		return this;	},	_getHandle: function( event ) {		return this.options.handle ?			!!!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :			true;	},	_setHandleClassName: function() {		this.handleElement = this.options.handle ?			this.element.find( this.options.handle ) : this.element;		this._addClass( this.handleElement, "ui-draggable-handle" );	},	_removeHandleClassName: function() {		this._removeClass( this.handleElement, "ui-draggable-handle" );	},	_createHelper: function( event ) {		var o = this.options,			helperIsFunction = typeof o.helper === "function",			helper = helperIsFunction ?				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :				( o.helper === "clone" ?					this.element.clone().removeAttr( "id" ) :					this.element );		if ( !!helper.parents( "body" ).length ) {			helper.appendTo( ( o.appendTo === "parent" ?				this.element[ 0 ].parentNode :				o.appendTo ) );		}		// Http://bugs.jqueryui.com/ticket/9446		// a helper function can return the original element		// which wouldn''t have been set to relative in _create		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {			this._setPositionRelative();		}		if ( helper[ 0 ] !!== this.element[ 0 ] &&				!!( /(fixed|absolute)/ ).test( helper.css( "position" ) ) ) {			helper.css( "position", "absolute" );		}		return helper;	},	_setPositionRelative: function() {		if ( !!( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {			this.element[ 0 ].style.position = "relative";		}	},	_adjustOffsetFromHelper: function( obj ) {		if ( typeof obj === "string" ) {			obj = obj.split( " " );		}		if ( Array.isArray( obj ) ) {			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };		}		if ( "left" in obj ) {			this.offset.click.left = obj.left + this.margins.left;		}		if ( "right" in obj ) {			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;		}		if ( "top" in obj ) {			this.offset.click.top = obj.top + this.margins.top;		}		if ( "bottom" in obj ) {			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;		}	},	_isRootNode: function( element ) {		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];	},	_getParentOffset: function() {		//Get the offsetParent and cache its position		var po = this.offsetParent.offset(),			document = this.document[ 0 ];		// This is a special case where we need to modify a offset calculated on start, since the		// following happened:		// 1. The position of the helper is absolute, so it''s position is calculated based on the		// next positioned parent		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn''t		// the document, which means that the scroll is included in the initial calculation of the		// offset of the parent, and never recalculated upon drag		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !!== document &&				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {			po.left += this.scrollParent.scrollLeft();			po.top += this.scrollParent.scrollTop();		}		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {			po = { top: 0, left: 0 };		}		return {			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )		};	},	_getRelativeOffset: function() {		if ( this.cssPosition !!== "relative" ) {			return { top: 0, left: 0 };		}		var p = this.element.position(),			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );		return {			top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +				( !!scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),			left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +				( !!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )		};	},	_cacheMargins: function() {		this.margins = {			left: ( parseInt( this.element.css( "marginLeft" ), 10 ) || 0 ),			top: ( parseInt( this.element.css( "marginTop" ), 10 ) || 0 ),			right: ( parseInt( this.element.css( "marginRight" ), 10 ) || 0 ),			bottom: ( parseInt( this.element.css( "marginBottom" ), 10 ) || 0 )		};	},	_cacheHelperProportions: function() {		this.helperProportions = {			width: this.helper.outerWidth(),			height: this.helper.outerHeight()		};	},	_setContainment: function() {		var isUserScrollable, c, ce,			o = this.options,			document = this.document[ 0 ];		this.relativeContainer = null;		if ( !!o.containment ) {			this.containment = null;			return;		}		if ( o.containment === "window" ) {			this.containment = [				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,				$( window ).scrollLeft() + $( window ).width() -					this.helperProportions.width - this.margins.left,				$( window ).scrollTop() +					( $( window ).height() || document.body.parentNode.scrollHeight ) -					this.helperProportions.height - this.margins.top			];			return;		}		if ( o.containment === "document" ) {			this.containment = [				0,				0,				$( document ).width() - this.helperProportions.width - this.margins.left,				( $( document ).height() || document.body.parentNode.scrollHeight ) -					this.helperProportions.height - this.margins.top			];			return;		}		if ( o.containment.constructor === Array ) {			this.containment = o.containment;			return;		}		if ( o.containment === "parent" ) {			o.containment = this.helper[ 0 ].parentNode;		}		c = $( o.containment );		ce = c[ 0 ];		if ( !!ce ) {			return;		}		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );		this.containment = [			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) +				( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) +				( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -				this.helperProportions.width -				this.margins.left -				this.margins.right,			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -				this.helperProportions.height -				this.margins.top -				this.margins.bottom		];		this.relativeContainer = c;	},	_convertPositionTo: function( d, pos ) {		if ( !!pos ) {			pos = this.position;		}		var mod = d === "absolute" ? 1 : -1,			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );		return {			top: (				// The absolute mouse position				pos.top	+				// Only for relative positioned nodes: Relative offset from element to offset parent				this.offset.relative.top * mod +				// The offsetParent''s offset without borders (offset + border)				this.offset.parent.top * mod -				( ( this.cssPosition === "fixed" ?					-this.offset.scroll.top :					( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod )			),			left: (				// The absolute mouse position				pos.left +				// Only for relative positioned nodes: Relative offset from element to offset parent				this.offset.relative.left * mod +				// The offsetParent''s offset without borders (offset + border)				this.offset.parent.left * mod	-				( ( this.cssPosition === "fixed" ?					-this.offset.scroll.left :					( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod )			)		};	},	_generatePosition: function( event, constrainPosition ) {		var containment, co, top, left,			o = this.options,			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),			pageX = event.pageX,			pageY = event.pageY;		// Cache the scroll		if ( !!scrollIsRootNode || !!this.offset.scroll ) {			this.offset.scroll = {				top: this.scrollParent.scrollTop(),				left: this.scrollParent.scrollLeft()			};		}		/*		 * - Position constraining -		 * Constrain the position to a mix of grid, containment.		 */		// If we are not dragging yet, we won''t check for options		if ( constrainPosition ) {			if ( this.containment ) {				if ( this.relativeContainer ) {					co = this.relativeContainer.offset();					containment = [						this.containment[ 0 ] + co.left,						this.containment[ 1 ] + co.top,						this.containment[ 2 ] + co.left,						this.containment[ 3 ] + co.top					];				} else {					containment = this.containment;				}				if ( event.pageX - this.offset.click.left < containment[ 0 ] ) {					pageX = containment[ 0 ] + this.offset.click.left;				}				if ( event.pageY - this.offset.click.top < containment[ 1 ] ) {					pageY = containment[ 1 ] + this.offset.click.top;				}				if ( event.pageX - this.offset.click.left > containment[ 2 ] ) {					pageX = containment[ 2 ] + this.offset.click.left;				}				if ( event.pageY - this.offset.click.top > containment[ 3 ] ) {					pageY = containment[ 3 ] + this.offset.click.top;				}			}			if ( o.grid ) {				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid				// argument errors in IE (see ticket #6950)				top = o.grid[ 1 ] ? this.originalPageY + Math.round( ( pageY -					this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ] : this.originalPageY;				pageY = containment ? ( ( top - this.offset.click.top >= containment[ 1 ] ||					top - this.offset.click.top > containment[ 3 ] ) ?						top :						( ( top - this.offset.click.top >= containment[ 1 ] ) ?							top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top;				left = o.grid[ 0 ] ? this.originalPageX +					Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ] :					this.originalPageX;				pageX = containment ? ( ( left - this.offset.click.left >= containment[ 0 ] ||					left - this.offset.click.left > containment[ 2 ] ) ?						left :						( ( left - this.offset.click.left >= containment[ 0 ] ) ?							left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left;			}			if ( o.axis === "y" ) {				pageX = this.originalPageX;			}			if ( o.axis === "x" ) {				pageY = this.originalPageY;			}		}		return {			top: (				// The absolute mouse position				pageY -				// Click offset (relative to the element)				this.offset.click.top -				// Only for relative positioned nodes: Relative offset from element to offset parent				this.offset.relative.top -				// The offsetParent''s offset without borders (offset + border)				this.offset.parent.top +				( this.cssPosition === "fixed" ?					-this.offset.scroll.top :					( scrollIsRootNode ? 0 : this.offset.scroll.top ) )			),			left: (				// The absolute mouse position				pageX -				// Click offset (relative to the element)				this.offset.click.left -				// Only for relative positioned nodes: Relative offset from element to offset parent				this.offset.relative.left -				// The offsetParent''s offset without borders (offset + border)				this.offset.parent.left +				( this.cssPosition === "fixed" ?					-this.offset.scroll.left :					( scrollIsRootNode ? 0 : this.offset.scroll.left ) )			)		};	},	_clear: function() {		this._removeClass( this.helper, "ui-draggable-dragging" );		if ( this.helper[ 0 ] !!== this.element[ 0 ] && !!this.cancelHelperRemoval ) {			this.helper.remove();		}		this.helper = null;		this.cancelHelperRemoval = false;		if ( this.destroyOnClear ) {			this.destroy();		}	},	// From now on bulk stuff - mainly helpers	_trigger: function( type, event, ui ) {		ui = ui || this._uiHash();		$.ui.plugin.call( this, type, [ event, ui, this ], true );		// Absolute position and offset (see #6884 ) have to be recalculated after plugins		if ( /^(drag|start|stop)/.test( type ) ) {			this.positionAbs = this._convertPositionTo( "absolute" );			ui.offset = this.positionAbs;		}		return $.Widget.prototype._trigger.call( this, type, event, ui );	},	plugins: {},	_uiHash: function() {		return {			helper: this.helper,			position: this.position,			originalPosition: this.originalPosition,			offset: this.positionAbs		};	}} );$.ui.plugin.add( "draggable", "connectToSortable", {	start: function( event, ui, draggable ) {		var uiSortable = $.extend( {}, ui, {			item: draggable.element		} );		draggable.sortables = [];		$( draggable.options.connectToSortable ).each( function() {			var sortable = $( this ).sortable( "instance" );			if ( sortable && !!sortable.options.disabled ) {				draggable.sortables.push( sortable );				// RefreshPositions is called at drag start to refresh the containerCache				// which is used in drag. This ensures it''s initialized and synchronized				// with any changes that might have happened on the page since initialization.				sortable.refreshPositions();				sortable._trigger( "activate", event, uiSortable );			}		} );	},	stop: function( event, ui, draggable ) {		var uiSortable = $.extend( {}, ui, {			item: draggable.element		} );		draggable.cancelHelperRemoval = false;		$.each( draggable.sortables, function() {			var sortable = this;			if ( sortable.isOver ) {				sortable.isOver = 0;				// Allow this sortable to handle removing the helper				draggable.cancelHelperRemoval = true;				sortable.cancelHelperRemoval = false;				// Use _storedCSS To restore properties in the sortable,				// as this also handles revert (#9675) since the draggable				// may have modified them in unexpected ways (#8809)				sortable._storedCSS = {					position: sortable.placeholder.css( "position" ),					top: sortable.placeholder.css( "top" ),					left: sortable.placeholder.css( "left" )				};				sortable._mouseStop( event );				// Once drag has ended, the sortable should return to using				// its original helper, not the shared helper from draggable				sortable.options.helper = sortable.options._helper;			} else {				// Prevent this Sortable from removing the helper.				// However, don''t set the draggable to remove the helper				// either as another connected Sortable may yet handle the removal.				sortable.cancelHelperRemoval = true;				sortable._trigger( "deactivate", event, uiSortable );			}		} );	},	drag: function( event, ui, draggable ) {		$.each( draggable.sortables, function() {			var innermostIntersecting = false,				sortable = this;			// Copy over variables that sortable''s _intersectsWith uses			sortable.positionAbs = draggable.positionAbs;			sortable.helperProportions = draggable.helperProportions;			sortable.offset.click = draggable.offset.click;			if ( sortable._intersectsWith( sortable.containerCache ) ) {				innermostIntersecting = true;				$.each( draggable.sortables, function() {					// Copy over variables that sortable''s _intersectsWith uses					this.positionAbs = draggable.positionAbs;					this.helperProportions = draggable.helperProportions;					this.offset.click = draggable.offset.click;					if ( this !!== sortable &&							this._intersectsWith( this.containerCache ) &&							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {						innermostIntersecting = false;					}					return innermostIntersecting;				} );			}			if ( innermostIntersecting ) {				// If it intersects, we use a little isOver variable and set it once,				// so that the move-in stuff gets fired only once.				if ( !!sortable.isOver ) {					sortable.isOver = 1;					// Store draggable''s parent in case we need to reappend to it later.					draggable._parent = ui.helper.parent();					sortable.currentItem = ui.helper						.appendTo( sortable.element )						.data( "ui-sortable-item", true );					// Store helper option to later restore it					sortable.options._helper = sortable.options.helper;					sortable.options.helper = function() {						return ui.helper[ 0 ];					};					// Fire the start events of the sortable with our passed browser event,					// and our own helper (so it doesn''t create a new one)					event.target = sortable.currentItem[ 0 ];					sortable._mouseCapture( event, true );					sortable._mouseStart( event, true, true );					// Because the browser event is way off the new appended portlet,					// modify necessary variables to reflect the changes					sortable.offset.click.top = draggable.offset.click.top;					sortable.offset.click.left = draggable.offset.click.left;					sortable.offset.parent.left -= draggable.offset.parent.left -						sortable.offset.parent.left;					sortable.offset.parent.top -= draggable.offset.parent.top -						sortable.offset.parent.top;					draggable._trigger( "toSortable", event );					// Inform draggable that the helper is in a valid drop zone,					// used solely in the revert option to handle "valid/invalid".					draggable.dropped = sortable.element;					// Need to refreshPositions of all sortables in the case that					// adding to one sortable changes the location of the other sortables (#9675)					$.each( draggable.sortables, function() {						this.refreshPositions();					} );					// Hack so receive/update callbacks work (mostly)					draggable.currentItem = draggable.element;					sortable.fromOutside = draggable;				}				if ( sortable.currentItem ) {					sortable._mouseDrag( event );					// Copy the sortable''s position because the draggable''s can potentially reflect					// a relative position, while sortable is always absolute, which the dragged					// element has now become. (#8809)					ui.position = sortable.position;				}			} else {				// If it doesn''t intersect with the sortable, and it intersected before,				// we fake the drag stop of the sortable, but make sure it doesn''t remove				// the helper by using cancelHelperRemoval.				if ( sortable.isOver ) {					sortable.isOver = 0;					sortable.cancelHelperRemoval = true;					// Calling sortable''s mouseStop would trigger a revert,					// so revert must be temporarily false until after mouseStop is called.					sortable.options._revert = sortable.options.revert;					sortable.options.revert = false;					sortable._trigger( "out", event, sortable._uiHash( sortable ) );					sortable._mouseStop( event, true );					// Restore sortable behaviors that were modfied					// when the draggable entered the sortable area (#9481)					sortable.options.revert = sortable.options._revert;					sortable.options.helper = sortable.options._helper;					if ( sortable.placeholder ) {						sortable.placeholder.remove();					}					// Restore and recalculate the draggable''s offset considering the sortable					// may have modified them in unexpected ways. (#8809, #10669)					ui.helper.appendTo( draggable._parent );					draggable._refreshOffsets( event );					ui.position = draggable._generatePosition( event, true );					draggable._trigger( "fromSortable", event );					// Inform draggable that the helper is no longer in a valid drop zone					draggable.dropped = false;					// Need to refreshPositions of all sortables just in case removing					// from one sortable changes the location of other sortables (#9675)					$.each( draggable.sortables, function() {						this.refreshPositions();					} );				}			}		} );	}} );$.ui.plugin.add( "draggable", "cursor", {	start: function( event, ui, instance ) {		var t = $( "body" ),			o = instance.options;		if ( t.css( "cursor" ) ) {			o._cursor = t.css( "cursor" );		}		t.css( "cursor", o.cursor );	},	stop: function( event, ui, instance ) {		var o = instance.options;		if ( o._cursor ) {			$( "body" ).css( "cursor", o._cursor );		}	}} );$.ui.plugin.add( "draggable", "opacity", {	start: function( event, ui, instance ) {		var t = $( ui.helper ),			o = instance.options;		if ( t.css( "opacity" ) ) {			o._opacity = t.css( "opacity" );		}		t.css( "opacity", o.opacity );	},	stop: function( event, ui, instance ) {		var o = instance.options;		if ( o._opacity ) {			$( ui.helper ).css( "opacity", o._opacity );		}	}} );$.ui.plugin.add( "draggable", "scroll", {	start: function( event, ui, i ) {		if ( !!i.scrollParentNotHidden ) {			i.scrollParentNotHidden = i.helper.scrollParent( false );		}		if ( i.scrollParentNotHidden[ 0 ] !!== i.document[ 0 ] &&				i.scrollParentNotHidden[ 0 ].tagName !!== "HTML" ) {			i.overflowOffset = i.scrollParentNotHidden.offset();		}	},	drag: function( event, ui, i  ) {		var o = i.options,			scrolled = false,			scrollParent = i.scrollParentNotHidden[ 0 ],			document = i.document[ 0 ];		if ( scrollParent !!== document && scrollParent.tagName !!== "HTML" ) {			if ( !!o.axis || o.axis !!== "x" ) {				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY <						o.scrollSensitivity ) {					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;				}			}			if ( !!o.axis || o.axis !!== "y" ) {				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX <						o.scrollSensitivity ) {					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;				}			}		} else {			if ( !!o.axis || o.axis !!== "x" ) {				if ( event.pageY - $( document ).scrollTop() < o.scrollSensitivity ) {					scrolled = $( document ).scrollTop( $( document ).scrollTop() - o.scrollSpeed );				} else if ( $( window ).height() - ( event.pageY - $( document ).scrollTop() ) <						o.scrollSensitivity ) {					scrolled = $( document ).scrollTop( $( document ).scrollTop() + o.scrollSpeed );				}			}			if ( !!o.axis || o.axis !!== "y" ) {				if ( event.pageX - $( document ).scrollLeft() < o.scrollSensitivity ) {					scrolled = $( document ).scrollLeft(						$( document ).scrollLeft() - o.scrollSpeed					);				} else if ( $( window ).width() - ( event.pageX - $( document ).scrollLeft() ) <						o.scrollSensitivity ) {					scrolled = $( document ).scrollLeft(						$( document ).scrollLeft() + o.scrollSpeed					);				}			}		}		if ( scrolled !!== false && $.ui.ddmanager && !!o.dropBehaviour ) {			$.ui.ddmanager.prepareOffsets( i, event );		}	}} );$.ui.plugin.add( "draggable", "snap", {	start: function( event, ui, i ) {		var o = i.options;		i.snapElements = [];		$( o.snap.constructor !!== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap )			.each( function() {				var $t = $( this ),					$o = $t.offset();				if ( this !!== i.element[ 0 ] ) {					i.snapElements.push( {						item: this,						width: $t.outerWidth(), height: $t.outerHeight(),						top: $o.top, left: $o.left					} );				}			} );	},	drag: function( event, ui, inst ) {		var ts, bs, ls, rs, l, r, t, b, i, first,			o = inst.options,			d = o.snapTolerance,			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;		for ( i = inst.snapElements.length - 1; i >= 0; i-- ) {			l = inst.snapElements[ i ].left - inst.margins.left;			r = l + inst.snapElements[ i ].width;			t = inst.snapElements[ i ].top - inst.margins.top;			b = t + inst.snapElements[ i ].height;			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||					!!$.contains( inst.snapElements[ i ].item.ownerDocument,					inst.snapElements[ i ].item ) ) {				if ( inst.snapElements[ i ].snapping ) {					if ( inst.options.snap.release ) {						inst.options.snap.release.call(							inst.element,							event,							$.extend( inst._uiHash(), { snapItem: inst.snapElements[ i ].item } )						);					}				}				inst.snapElements[ i ].snapping = false;				continue;			}			if ( o.snapMode !!== "inner" ) {				ts = Math.abs( t - y2 ) <= d;				bs = Math.abs( b - y1 ) <= d;				ls = Math.abs( l - x2 ) <= d;				rs = Math.abs( r - x1 ) <= d;				if ( ts ) {					ui.position.top = inst._convertPositionTo( "relative", {						top: t - inst.helperProportions.height,						left: 0					} ).top;				}				if ( bs ) {					ui.position.top = inst._convertPositionTo( "relative", {						top: b,						left: 0					} ).top;				}				if ( ls ) {					ui.position.left = inst._convertPositionTo( "relative", {						top: 0,						left: l - inst.helperProportions.width					} ).left;				}				if ( rs ) {					ui.position.left = inst._convertPositionTo( "relative", {						top: 0,						left: r					} ).left;				}			}			first = ( ts || bs || ls || rs );			if ( o.snapMode !!== "outer" ) {				ts = Math.abs( t - y1 ) <= d;				bs = Math.abs( b - y2 ) <= d;				ls = Math.abs( l - x1 ) <= d;				rs = Math.abs( r - x2 ) <= d;				if ( ts ) {					ui.position.top = inst._convertPositionTo( "relative", {						top: t,						left: 0					} ).top;				}				if ( bs ) {					ui.position.top = inst._convertPositionTo( "relative", {						top: b - inst.helperProportions.height,						left: 0					} ).top;				}				if ( ls ) {					ui.position.left = inst._convertPositionTo( "relative", {						top: 0,						left: l					} ).left;				}				if ( rs ) {					ui.position.left = inst._convertPositionTo( "relative", {						top: 0,						left: r - inst.helperProportions.width					} ).left;				}			}			if ( !!inst.snapElements[ i ].snapping && ( ts || bs || ls || rs || first ) ) {				if ( inst.options.snap.snap ) {					inst.options.snap.snap.call(						inst.element,						event,						$.extend( inst._uiHash(), {							snapItem: inst.snapElements[ i ].item						} ) );				}			}			inst.snapElements[ i ].snapping = ( ts || bs || ls || rs || first );		}	}} );$.ui.plugin.add( "draggable", "stack", {	start: function( event, ui, instance ) {		var min,			o = instance.options,			group = $.makeArray( $( o.stack ) ).sort( function( a, b ) {				return ( parseInt( $( a ).css( "zIndex" ), 10 ) || 0 ) -					( parseInt( $( b ).css( "zIndex" ), 10 ) || 0 );			} );		if ( !!group.length ) {			return;		}		min = parseInt( $( group[ 0 ] ).css( "zIndex" ), 10 ) || 0;		$( group ).each( function( i ) {			$( this ).css( "zIndex", min + i );		} );		this.css( "zIndex", ( min + group.length ) );	}} );$.ui.plugin.add( "draggable", "zIndex", {	start: function( event, ui, instance ) {		var t = $( ui.helper ),			o = instance.options;		if ( t.css( "zIndex" ) ) {			o._zIndex = t.css( "zIndex" );		}		t.css( "zIndex", o.zIndex );	},	stop: function( event, ui, instance ) {		var o = instance.options;		if ( o._zIndex ) {			$( ui.helper ).css( "zIndex", o._zIndex );		}	}} );var widgetsDraggable = $.ui.draggable;/*!! * jQuery UI Resizable 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Resizable//>>group: Interactions//>>description: Enables resize functionality for any element.//>>docs: http://api.jqueryui.com/resizable///>>demos: http://jqueryui.com/resizable///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/resizable.css//>>css.theme: ../../themes/base/theme.css$.widget( "ui.resizable", $.ui.mouse, {	version: "1.13.2",	widgetEventPrefix: "resize",	options: {		alsoResize: false,		animate: false,		animateDuration: "slow",		animateEasing: "swing",		aspectRatio: false,		autoHide: false,		classes: {			"ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"		},		containment: false,		ghost: false,		grid: false,		handles: "e,s,se",		helper: false,		maxHeight: null,		maxWidth: null,		minHeight: 10,		minWidth: 10,		// See #7960		zIndex: 90,		// Callbacks		resize: null,		start: null,		stop: null	},	_num: function( value ) {		return parseFloat( value ) || 0;	},	_isNumber: function( value ) {		return !!isNaN( parseFloat( value ) );	},	_hasScroll: function( el, a ) {		if ( $( el ).css( "overflow" ) === "hidden" ) {			return false;		}		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",			has = false;		if ( el[ scroll ] > 0 ) {			return true;		}		// TODO: determine which cases actually cause this to happen		// if the element doesn''t have the scroll set, see if it''s possible to		// set the scroll		try {			el[ scroll ] = 1;			has = ( el[ scroll ] > 0 );			el[ scroll ] = 0;		} catch ( e ) {			// `el` might be a string, then setting `scroll` will throw			// an error in strict mode; ignore it.		}		return has;	},	_create: function() {		var margins,			o = this.options,			that = this;		this._addClass( "ui-resizable" );		$.extend( this, {			_aspectRatio: !!!!( o.aspectRatio ),			aspectRatio: o.aspectRatio,			originalElement: this.element,			_proportionallyResizeElements: [],			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null		} );		// Wrap the element if it cannot hold child nodes		if ( this.element[ 0 ].nodeName.match( /^(canvas|textarea|input|select|button|img)$/i ) ) {			this.element.wrap(				$( "<div class=''ui-wrapper''></div>" ).css( {					overflow: "hidden",					position: this.element.css( "position" ),					width: this.element.outerWidth(),					height: this.element.outerHeight(),					top: this.element.css( "top" ),					left: this.element.css( "left" )				} )			);			this.element = this.element.parent().data(				"ui-resizable", this.element.resizable( "instance" )			);			this.elementIsWrapper = true;			margins = {				marginTop: this.originalElement.css( "marginTop" ),				marginRight: this.originalElement.css( "marginRight" ),				marginBottom: this.originalElement.css( "marginBottom" ),				marginLeft: this.originalElement.css( "marginLeft" )			};			this.element.css( margins );			this.originalElement.css( "margin", 0 );			// support: Safari			// Prevent Safari textarea resize			this.originalResizeStyle = this.originalElement.css( "resize" );			this.originalElement.css( "resize", "none" );			this._proportionallyResizeElements.push( this.originalElement.css( {				position: "static",				zoom: 1,				display: "block"			} ) );			// Support: IE9			// avoid IE jump (hard set the margin)			this.originalElement.css( margins );			this._proportionallyResize();		}		this._setupHandles();		if ( o.autoHide ) {			$( this.element )				.on( "mouseenter", function() {					if ( o.disabled ) {						return;					}					that._removeClass( "ui-resizable-autohide" );					that._handles.show();				} )				.on( "mouseleave", function() {					if ( o.disabled ) {						return;					}					if ( !!that.resizing ) {						that._addClass( "ui-resizable-autohide" );						that._handles.hide();					}				} );		}		this._mouseInit();	},	_destroy: function() {		this._mouseDestroy();		this._addedHandles.remove();		var wrapper,			_destroy = function( exp ) {				$( exp )					.removeData( "resizable" )					.removeData( "ui-resizable" )					.off( ".resizable" );			};		// TODO: Unwrap at same DOM position		if ( this.elementIsWrapper ) {			_destroy( this.element );			wrapper = this.element;			this.originalElement.css( {				position: wrapper.css( "position" ),				width: wrapper.outerWidth(),				height: wrapper.outerHeight(),				top: wrapper.css( "top" ),				left: wrapper.css( "left" )			} ).insertAfter( wrapper );			wrapper.remove();		}		this.originalElement.css( "resize", this.originalResizeStyle );		_destroy( this.originalElement );		return this;	},	_setOption: function( key, value ) {		this._super( key, value );		switch ( key ) {		case "handles":			this._removeHandles();			this._setupHandles();			break;		case "aspectRatio":			this._aspectRatio = !!!!value;			break;		default:			break;		}	},	_setupHandles: function() {		var o = this.options, handle, i, n, hname, axis, that = this;		this.handles = o.handles ||			( !!$( ".ui-resizable-handle", this.element ).length ?				"e,s,se" : {					n: ".ui-resizable-n",					e: ".ui-resizable-e",					s: ".ui-resizable-s",					w: ".ui-resizable-w",					se: ".ui-resizable-se",					sw: ".ui-resizable-sw",					ne: ".ui-resizable-ne",					nw: ".ui-resizable-nw"				} );		this._handles = $();		this._addedHandles = $();		if ( this.handles.constructor === String ) {			if ( this.handles === "all" ) {				this.handles = "n,e,s,w,se,sw,ne,nw";			}			n = this.handles.split( "," );			this.handles = {};			for ( i = 0; i < n.length; i++ ) {				handle = String.prototype.trim.call( n[ i ] );				hname = "ui-resizable-" + handle;				axis = $( "<div>" );				this._addClass( axis, "ui-resizable-handle " + hname );				axis.css( { zIndex: o.zIndex } );				this.handles[ handle ] = ".ui-resizable-" + handle;				if ( !!this.element.children( this.handles[ handle ] ).length ) {					this.element.append( axis );					this._addedHandles = this._addedHandles.add( axis );				}			}		}		this._renderAxis = function( target ) {			var i, axis, padPos, padWrapper;			target = target || this.element;			for ( i in this.handles ) {				if ( this.handles[ i ].constructor === String ) {					this.handles[ i ] = this.element.children( this.handles[ i ] ).first().show();				} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {					this.handles[ i ] = $( this.handles[ i ] );					this._on( this.handles[ i ], { "mousedown": that._mouseDown } );				}				if ( this.elementIsWrapper &&						this.originalElement[ 0 ]							.nodeName							.match( /^(textarea|input|select|button)$/i ) ) {					axis = $( this.handles[ i ], this.element );					padWrapper = /sw|ne|nw|se|n|s/.test( i ) ?						axis.outerHeight() :						axis.outerWidth();					padPos = [ "padding",						/ne|nw|n/.test( i ) ? "Top" :						/se|sw|s/.test( i ) ? "Bottom" :						/^e$/.test( i ) ? "Right" : "Left" ].join( "" );					target.css( padPos, padWrapper );					this._proportionallyResize();				}				this._handles = this._handles.add( this.handles[ i ] );			}		};		// TODO: make renderAxis a prototype function		this._renderAxis( this.element );		this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );		this._handles.disableSelection();		this._handles.on( "mouseover", function() {			if ( !!that.resizing ) {				if ( this.className ) {					axis = this.className.match( /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i );				}				that.axis = axis && axis[ 1 ] ? axis[ 1 ] : "se";			}		} );		if ( o.autoHide ) {			this._handles.hide();			this._addClass( "ui-resizable-autohide" );		}	},	_removeHandles: function() {		this._addedHandles.remove();	},	_mouseCapture: function( event ) {		var i, handle,			capture = false;		for ( i in this.handles ) {			handle = $( this.handles[ i ] )[ 0 ];			if ( handle === event.target || $.contains( handle, event.target ) ) {				capture = true;			}		}		return !!this.options.disabled && capture;	},	_mouseStart: function( event ) {		var curleft, curtop, cursor,			o = this.options,			el = this.element;		this.resizing = true;		this._renderProxy();		curleft = this._num( this.helper.css( "left" ) );		curtop = this._num( this.helper.css( "top" ) );		if ( o.containment ) {			curleft += $( o.containment ).scrollLeft() || 0;			curtop += $( o.containment ).scrollTop() || 0;		}		this.offset = this.helper.offset();		this.position = { left: curleft, top: curtop };		this.size = this._helper ? {				width: this.helper.width(),				height: this.helper.height()			} : {				width: el.width(),				height: el.height()			};		this.originalSize = this._helper ? {				width: el.outerWidth(),				height: el.outerHeight()			} : {				width: el.width(),				height: el.height()			};		this.sizeDiff = {			width: el.outerWidth() - el.width(),			height: el.outerHeight() - el.height()		};		this.originalPosition = { left: curleft, top: curtop };		this.originalMousePosition = { left: event.pageX, top: event.pageY };		this.aspectRatio = ( typeof o.aspectRatio === "number" ) ?			o.aspectRatio :			( ( this.originalSize.width / this.originalSize.height ) || 1 );		cursor = $( ".ui-resizable-" + this.axis ).css( "cursor" );		$( "body" ).css( "cursor", cursor === "auto" ? this.axis + "-resize" : cursor );		this._addClass( "ui-resizable-resizing" );		this._propagate( "start", event );		return true;	},	_mouseDrag: function( event ) {		var data, props,			smp = this.originalMousePosition,			a = this.axis,			dx = ( event.pageX - smp.left ) || 0,			dy = ( event.pageY - smp.top ) || 0,			trigger = this._change[ a ];		this._updatePrevProperties();		if ( !!trigger ) {			return false;		}		data = trigger.apply( this, [ event, dx, dy ] );		this._updateVirtualBoundaries( event.shiftKey );		if ( this._aspectRatio || event.shiftKey ) {			data = this._updateRatio( data, event );		}		data = this._respectSize( data, event );		this._updateCache( data );		this._propagate( "resize", event );		props = this._applyChanges();		if ( !!this._helper && this._proportionallyResizeElements.length ) {			this._proportionallyResize();		}		if ( !!$.isEmptyObject( props ) ) {			this._updatePrevProperties();			this._trigger( "resize", event, this.ui() );			this._applyChanges();		}		return false;	},	_mouseStop: function( event ) {		this.resizing = false;		var pr, ista, soffseth, soffsetw, s, left, top,			o = this.options, that = this;		if ( this._helper ) {			pr = this._proportionallyResizeElements;			ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName );			soffseth = ista && this._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height;			soffsetw = ista ? 0 : that.sizeDiff.width;			s = {				width: ( that.helper.width()  - soffsetw ),				height: ( that.helper.height() - soffseth )			};			left = ( parseFloat( that.element.css( "left" ) ) +				( that.position.left - that.originalPosition.left ) ) || null;			top = ( parseFloat( that.element.css( "top" ) ) +				( that.position.top - that.originalPosition.top ) ) || null;			if ( !!o.animate ) {				this.element.css( $.extend( s, { top: top, left: left } ) );			}			that.helper.height( that.size.height );			that.helper.width( that.size.width );			if ( this._helper && !!o.animate ) {				this._proportionallyResize();			}		}		$( "body" ).css( "cursor", "auto" );		this._removeClass( "ui-resizable-resizing" );		this._propagate( "stop", event );		if ( this._helper ) {			this.helper.remove();		}		return false;	},	_updatePrevProperties: function() {		this.prevPosition = {			top: this.position.top,			left: this.position.left		};		this.prevSize = {			width: this.size.width,			height: this.size.height		};	},	_applyChanges: function() {		var props = {};		if ( this.position.top !!== this.prevPosition.top ) {			props.top = this.position.top + "px";		}		if ( this.position.left !!== this.prevPosition.left ) {			props.left = this.position.left + "px";		}		if ( this.size.width !!== this.prevSize.width ) {			props.width = this.size.width + "px";		}		if ( this.size.height !!== this.prevSize.height ) {			props.height = this.size.height + "px";		}		this.helper.css( props );		return props;	},	_updateVirtualBoundaries: function( forceAspectRatio ) {		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,			o = this.options;		b = {			minWidth: this._isNumber( o.minWidth ) ? o.minWidth : 0,			maxWidth: this._isNumber( o.maxWidth ) ? o.maxWidth : Infinity,			minHeight: this._isNumber( o.minHeight ) ? o.minHeight : 0,			maxHeight: this._isNumber( o.maxHeight ) ? o.maxHeight : Infinity		};		if ( this._aspectRatio || forceAspectRatio ) {			pMinWidth = b.minHeight * this.aspectRatio;			pMinHeight = b.minWidth / this.aspectRatio;			pMaxWidth = b.maxHeight * this.aspectRatio;			pMaxHeight = b.maxWidth / this.aspectRatio;			if ( pMinWidth > b.minWidth ) {				b.minWidth = pMinWidth;			}			if ( pMinHeight > b.minHeight ) {				b.minHeight = pMinHeight;			}			if ( pMaxWidth < b.maxWidth ) {				b.maxWidth = pMaxWidth;			}			if ( pMaxHeight < b.maxHeight ) {				b.maxHeight = pMaxHeight;			}		}		this._vBoundaries = b;	},	_updateCache: function( data ) {		this.offset = this.helper.offset();		if ( this._isNumber( data.left ) ) {			this.position.left = data.left;		}		if ( this._isNumber( data.top ) ) {			this.position.top = data.top;		}		if ( this._isNumber( data.height ) ) {			this.size.height = data.height;		}		if ( this._isNumber( data.width ) ) {			this.size.width = data.width;		}	},	_updateRatio: function( data ) {		var cpos = this.position,			csize = this.size,			a = this.axis;		if ( this._isNumber( data.height ) ) {			data.width = ( data.height * this.aspectRatio );		} else if ( this._isNumber( data.width ) ) {			data.height = ( data.width / this.aspectRatio );		}		if ( a === "sw" ) {			data.left = cpos.left + ( csize.width - data.width );			data.top = null;		}		if ( a === "nw" ) {			data.top = cpos.top + ( csize.height - data.height );			data.left = cpos.left + ( csize.width - data.width );		}		return data;	},	_respectSize: function( data ) {		var o = this._vBoundaries,			a = this.axis,			ismaxw = this._isNumber( data.width ) && o.maxWidth && ( o.maxWidth < data.width ),			ismaxh = this._isNumber( data.height ) && o.maxHeight && ( o.maxHeight < data.height ),			isminw = this._isNumber( data.width ) && o.minWidth && ( o.minWidth > data.width ),			isminh = this._isNumber( data.height ) && o.minHeight && ( o.minHeight > data.height ),			dw = this.originalPosition.left + this.originalSize.width,			dh = this.originalPosition.top + this.originalSize.height,			cw = /sw|nw|w/.test( a ), ch = /nw|ne|n/.test( a );		if ( isminw ) {			data.width = o.minWidth;		}		if ( isminh ) {			data.height = o.minHeight;		}		if ( ismaxw ) {			data.width = o.maxWidth;		}		if ( ismaxh ) {			data.height = o.maxHeight;		}		if ( isminw && cw ) {			data.left = dw - o.minWidth;		}		if ( ismaxw && cw ) {			data.left = dw - o.maxWidth;		}		if ( isminh && ch ) {			data.top = dh - o.minHeight;		}		if ( ismaxh && ch ) {			data.top = dh - o.maxHeight;		}		// Fixing jump error on top/left - bug #2330		if ( !!data.width && !!data.height && !!data.left && data.top ) {			data.top = null;		} else if ( !!data.width && !!data.height && !!data.top && data.left ) {			data.left = null;		}		return data;	},	_getPaddingPlusBorderDimensions: function( element ) {		var i = 0,			widths = [],			borders = [				element.css( "borderTopWidth" ),				element.css( "borderRightWidth" ),				element.css( "borderBottomWidth" ),				element.css( "borderLeftWidth" )			],			paddings = [				element.css( "paddingTop" ),				element.css( "paddingRight" ),				element.css( "paddingBottom" ),				element.css( "paddingLeft" )			];		for ( ; i < 4; i++ ) {			widths[ i ] = ( parseFloat( borders[ i ] ) || 0 );			widths[ i ] += ( parseFloat( paddings[ i ] ) || 0 );		}		return {			height: widths[ 0 ] + widths[ 2 ],			width: widths[ 1 ] + widths[ 3 ]		};	},	_proportionallyResize: function() {		if ( !!this._proportionallyResizeElements.length ) {			return;		}		var prel,			i = 0,			element = this.helper || this.element;		for ( ; i < this._proportionallyResizeElements.length; i++ ) {			prel = this._proportionallyResizeElements[ i ];			// TODO: Seems like a bug to cache this.outerDimensions			// considering that we are in a loop.			if ( !!this.outerDimensions ) {				this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );			}			prel.css( {				height: ( element.height() - this.outerDimensions.height ) || 0,				width: ( element.width() - this.outerDimensions.width ) || 0			} );		}	},	_renderProxy: function() {		var el = this.element, o = this.options;		this.elementOffset = el.offset();		if ( this._helper ) {			this.helper = this.helper || $( "<div></div>" ).css( { overflow: "hidden" } );			this._addClass( this.helper, this._helper );			this.helper.css( {				width: this.element.outerWidth(),				height: this.element.outerHeight(),				position: "absolute",				left: this.elementOffset.left + "px",				top: this.elementOffset.top + "px",				zIndex: ++o.zIndex //TODO: Don''t modify option			} );			this.helper				.appendTo( "body" )				.disableSelection();		} else {			this.helper = this.element;		}	},	_change: {		e: function( event, dx ) {			return { width: this.originalSize.width + dx };		},		w: function( event, dx ) {			var cs = this.originalSize, sp = this.originalPosition;			return { left: sp.left + dx, width: cs.width - dx };		},		n: function( event, dx, dy ) {			var cs = this.originalSize, sp = this.originalPosition;			return { top: sp.top + dy, height: cs.height - dy };		},		s: function( event, dx, dy ) {			return { height: this.originalSize.height + dy };		},		se: function( event, dx, dy ) {			return $.extend( this._change.s.apply( this, arguments ),				this._change.e.apply( this, [ event, dx, dy ] ) );		},		sw: function( event, dx, dy ) {			return $.extend( this._change.s.apply( this, arguments ),				this._change.w.apply( this, [ event, dx, dy ] ) );		},		ne: function( event, dx, dy ) {			return $.extend( this._change.n.apply( this, arguments ),				this._change.e.apply( this, [ event, dx, dy ] ) );		},		nw: function( event, dx, dy ) {			return $.extend( this._change.n.apply( this, arguments ),				this._change.w.apply( this, [ event, dx, dy ] ) );		}	},	_propagate: function( n, event ) {		$.ui.plugin.call( this, n, [ event, this.ui() ] );		if ( n !!== "resize" ) {			this._trigger( n, event, this.ui() );		}	},	plugins: {},	ui: function() {		return {			originalElement: this.originalElement,			element: this.element,			helper: this.helper,			position: this.position,			size: this.size,			originalSize: this.originalSize,			originalPosition: this.originalPosition		};	}} );/* * Resizable Extensions */$.ui.plugin.add( "resizable", "animate", {	stop: function( event ) {		var that = $( this ).resizable( "instance" ),			o = that.options,			pr = that._proportionallyResizeElements,			ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName ),			soffseth = ista && that._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height,			soffsetw = ista ? 0 : that.sizeDiff.width,			style = {				width: ( that.size.width - soffsetw ),				height: ( that.size.height - soffseth )			},			left = ( parseFloat( that.element.css( "left" ) ) +				( that.position.left - that.originalPosition.left ) ) || null,			top = ( parseFloat( that.element.css( "top" ) ) +				( that.position.top - that.originalPosition.top ) ) || null;		that.element.animate(			$.extend( style, top && left ? { top: top, left: left } : {} ), {				duration: o.animateDuration,				easing: o.animateEasing,				step: function() {					var data = {						width: parseFloat( that.element.css( "width" ) ),						height: parseFloat( that.element.css( "height" ) ),						top: parseFloat( that.element.css( "top" ) ),						left: parseFloat( that.element.css( "left" ) )					};					if ( pr && pr.length ) {						$( pr[ 0 ] ).css( { width: data.width, height: data.height } );					}					// Propagating resize, and updating values for each animation step					that._updateCache( data );					that._propagate( "resize", event );				}			}		);	}} );$.ui.plugin.add( "resizable", "containment", {	start: function() {		var element, p, co, ch, cw, width, height,			that = $( this ).resizable( "instance" ),			o = that.options,			el = that.element,			oc = o.containment,			ce = ( oc instanceof $ ) ?				oc.get( 0 ) :				( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;		if ( !!ce ) {			return;		}		that.containerElement = $( ce );		if ( /document/.test( oc ) || oc === document ) {			that.containerOffset = {				left: 0,				top: 0			};			that.containerPosition = {				left: 0,				top: 0			};			that.parentData = {				element: $( document ),				left: 0,				top: 0,				width: $( document ).width(),				height: $( document ).height() || document.body.parentNode.scrollHeight			};		} else {			element = $( ce );			p = [];			$( [ "Top", "Right", "Left", "Bottom" ] ).each( function( i, name ) {				p[ i ] = that._num( element.css( "padding" + name ) );			} );			that.containerOffset = element.offset();			that.containerPosition = element.position();			that.containerSize = {				height: ( element.innerHeight() - p[ 3 ] ),				width: ( element.innerWidth() - p[ 1 ] )			};			co = that.containerOffset;			ch = that.containerSize.height;			cw = that.containerSize.width;			width = ( that._hasScroll( ce, "left" ) ? ce.scrollWidth : cw );			height = ( that._hasScroll( ce ) ? ce.scrollHeight : ch );			that.parentData = {				element: ce,				left: co.left,				top: co.top,				width: width,				height: height			};		}	},	resize: function( event ) {		var woset, hoset, isParent, isOffsetRelative,			that = $( this ).resizable( "instance" ),			o = that.options,			co = that.containerOffset,			cp = that.position,			pRatio = that._aspectRatio || event.shiftKey,			cop = {				top: 0,				left: 0			},			ce = that.containerElement,			continueResize = true;		if ( ce[ 0 ] !!== document && ( /static/ ).test( ce.css( "position" ) ) ) {			cop = co;		}		if ( cp.left < ( that._helper ? co.left : 0 ) ) {			that.size.width = that.size.width +				( that._helper ?					( that.position.left - co.left ) :					( that.position.left - cop.left ) );			if ( pRatio ) {				that.size.height = that.size.width / that.aspectRatio;				continueResize = false;			}			that.position.left = o.helper ? co.left : 0;		}		if ( cp.top < ( that._helper ? co.top : 0 ) ) {			that.size.height = that.size.height +				( that._helper ?					( that.position.top - co.top ) :					that.position.top );			if ( pRatio ) {				that.size.width = that.size.height * that.aspectRatio;				continueResize = false;			}			that.position.top = that._helper ? co.top : 0;		}		isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );		isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );		if ( isParent && isOffsetRelative ) {			that.offset.left = that.parentData.left + that.position.left;			that.offset.top = that.parentData.top + that.position.top;		} else {			that.offset.left = that.element.offset().left;			that.offset.top = that.element.offset().top;		}		woset = Math.abs( that.sizeDiff.width +			( that._helper ?				that.offset.left - cop.left :				( that.offset.left - co.left ) ) );		hoset = Math.abs( that.sizeDiff.height +			( that._helper ?				that.offset.top - cop.top :				( that.offset.top - co.top ) ) );		if ( woset + that.size.width >= that.parentData.width ) {			that.size.width = that.parentData.width - woset;			if ( pRatio ) {				that.size.height = that.size.width / that.aspectRatio;				continueResize = false;			}		}		if ( hoset + that.size.height >= that.parentData.height ) {			that.size.height = that.parentData.height - hoset;			if ( pRatio ) {				that.size.width = that.size.height * that.aspectRatio;				continueResize = false;			}		}		if ( !!continueResize ) {			that.position.left = that.prevPosition.left;			that.position.top = that.prevPosition.top;			that.size.width = that.prevSize.width;			that.size.height = that.prevSize.height;		}	},	stop: function() {		var that = $( this ).resizable( "instance" ),			o = that.options,			co = that.containerOffset,			cop = that.containerPosition,			ce = that.containerElement,			helper = $( that.helper ),			ho = helper.offset(),			w = helper.outerWidth() - that.sizeDiff.width,			h = helper.outerHeight() - that.sizeDiff.height;		if ( that._helper && !!o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {			$( this ).css( {				left: ho.left - cop.left - co.left,				width: w,				height: h			} );		}		if ( that._helper && !!o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {			$( this ).css( {				left: ho.left - cop.left - co.left,				width: w,				height: h			} );		}	}} );$.ui.plugin.add( "resizable", "alsoResize", {	start: function() {		var that = $( this ).resizable( "instance" ),			o = that.options;		$( o.alsoResize ).each( function() {			var el = $( this );			el.data( "ui-resizable-alsoresize", {				width: parseFloat( el.width() ), height: parseFloat( el.height() ),				left: parseFloat( el.css( "left" ) ), top: parseFloat( el.css( "top" ) )			} );		} );	},	resize: function( event, ui ) {		var that = $( this ).resizable( "instance" ),			o = that.options,			os = that.originalSize,			op = that.originalPosition,			delta = {				height: ( that.size.height - os.height ) || 0,				width: ( that.size.width - os.width ) || 0,				top: ( that.position.top - op.top ) || 0,				left: ( that.position.left - op.left ) || 0			};			$( o.alsoResize ).each( function() {				var el = $( this ), start = $( this ).data( "ui-resizable-alsoresize" ), style = {},					css = el.parents( ui.originalElement[ 0 ] ).length ?							[ "width", "height" ] :							[ "width", "height", "top", "left" ];				$.each( css, function( i, prop ) {					var sum = ( start[ prop ] || 0 ) + ( delta[ prop ] || 0 );					if ( sum && sum >= 0 ) {						style[ prop ] = sum || null;					}				} );				el.css( style );			} );	},	stop: function() {		$( this ).removeData( "ui-resizable-alsoresize" );	}} );$.ui.plugin.add( "resizable", "ghost", {	start: function() {		var that = $( this ).resizable( "instance" ), cs = that.size;		that.ghost = that.originalElement.clone();		that.ghost.css( {			opacity: 0.25,			display: "block",			position: "relative",			height: cs.height,			width: cs.width,			margin: 0,			left: 0,			top: 0		} );		that._addClass( that.ghost, "ui-resizable-ghost" );		// DEPRECATED		// TODO: remove after 1.12		if ( $.uiBackCompat !!== false && typeof that.options.ghost === "string" ) {			// Ghost option			that.ghost.addClass( this.options.ghost );		}		that.ghost.appendTo( that.helper );	},	resize: function() {		var that = $( this ).resizable( "instance" );		if ( that.ghost ) {			that.ghost.css( {				position: "relative",				height: that.size.height,				width: that.size.width			} );		}	},	stop: function() {		var that = $( this ).resizable( "instance" );		if ( that.ghost && that.helper ) {			that.helper.get( 0 ).removeChild( that.ghost.get( 0 ) );		}	}} );$.ui.plugin.add( "resizable", "grid", {	resize: function() {		var outerDimensions,			that = $( this ).resizable( "instance" ),			o = that.options,			cs = that.size,			os = that.originalSize,			op = that.originalPosition,			a = that.axis,			grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,			gridX = ( grid[ 0 ] || 1 ),			gridY = ( grid[ 1 ] || 1 ),			ox = Math.round( ( cs.width - os.width ) / gridX ) * gridX,			oy = Math.round( ( cs.height - os.height ) / gridY ) * gridY,			newWidth = os.width + ox,			newHeight = os.height + oy,			isMaxWidth = o.maxWidth && ( o.maxWidth < newWidth ),			isMaxHeight = o.maxHeight && ( o.maxHeight < newHeight ),			isMinWidth = o.minWidth && ( o.minWidth > newWidth ),			isMinHeight = o.minHeight && ( o.minHeight > newHeight );		o.grid = grid;		if ( isMinWidth ) {			newWidth += gridX;		}		if ( isMinHeight ) {			newHeight += gridY;		}		if ( isMaxWidth ) {			newWidth -= gridX;		}		if ( isMaxHeight ) {			newHeight -= gridY;		}		if ( /^(se|s|e)$/.test( a ) ) {			that.size.width = newWidth;			that.size.height = newHeight;		} else if ( /^(ne)$/.test( a ) ) {			that.size.width = newWidth;			that.size.height = newHeight;			that.position.top = op.top - oy;		} else if ( /^(sw)$/.test( a ) ) {			that.size.width = newWidth;			that.size.height = newHeight;			that.position.left = op.left - ox;		} else {			if ( newHeight - gridY <= 0 || newWidth - gridX <= 0 ) {				outerDimensions = that._getPaddingPlusBorderDimensions( this );			}			if ( newHeight - gridY > 0 ) {				that.size.height = newHeight;				that.position.top = op.top - oy;			} else {				newHeight = gridY - outerDimensions.height;				that.size.height = newHeight;				that.position.top = op.top + os.height - newHeight;			}			if ( newWidth - gridX > 0 ) {				that.size.width = newWidth;				that.position.left = op.left - ox;			} else {				newWidth = gridX - outerDimensions.width;				that.size.width = newWidth;				that.position.left = op.left + os.width - newWidth;			}		}	}} );var widgetsResizable = $.ui.resizable;/*!! * jQuery UI Dialog 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Dialog//>>group: Widgets//>>description: Displays customizable dialog windows.//>>docs: http://api.jqueryui.com/dialog///>>demos: http://jqueryui.com/dialog///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/dialog.css//>>css.theme: ../../themes/base/theme.css$.widget( "ui.dialog", {	version: "1.13.2",	options: {		appendTo: "body",		autoOpen: true,		buttons: [],		classes: {			"ui-dialog": "ui-corner-all",			"ui-dialog-titlebar": "ui-corner-all"		},		closeOnEscape: true,		closeText: "Close",		draggable: true,		hide: null,		height: "auto",		maxHeight: null,		maxWidth: null,		minHeight: 150,		minWidth: 150,		modal: false,		position: {			my: "center",			at: "center",			of: window,			collision: "fit",			// Ensure the titlebar is always visible			using: function( pos ) {				var topOffset = $( this ).css( pos ).offset().top;				if ( topOffset < 0 ) {					$( this ).css( "top", pos.top - topOffset );				}			}		},		resizable: true,		show: null,		title: null,		width: 300,		// Callbacks		beforeClose: null,		close: null,		drag: null,		dragStart: null,		dragStop: null,		focus: null,		open: null,		resize: null,		resizeStart: null,		resizeStop: null	},	sizeRelatedOptions: {		buttons: true,		height: true,		maxHeight: true,		maxWidth: true,		minHeight: true,		minWidth: true,		width: true	},	resizableRelatedOptions: {		maxHeight: true,		maxWidth: true,		minHeight: true,		minWidth: true	},	_create: function() {		this.originalCss = {			display: this.element[ 0 ].style.display,			width: this.element[ 0 ].style.width,			minHeight: this.element[ 0 ].style.minHeight,			maxHeight: this.element[ 0 ].style.maxHeight,			height: this.element[ 0 ].style.height		};		this.originalPosition = {			parent: this.element.parent(),			index: this.element.parent().children().index( this.element )		};		this.originalTitle = this.element.attr( "title" );		if ( this.options.title == null && this.originalTitle !!= null ) {			this.options.title = this.originalTitle;		}		// Dialogs can''t be disabled		if ( this.options.disabled ) {			this.options.disabled = false;		}		this._createWrapper();		this.element			.show()			.removeAttr( "title" )			.appendTo( this.uiDialog );		this._addClass( "ui-dialog-content", "ui-widget-content" );		this._createTitlebar();		this._createButtonPane();		if ( this.options.draggable && $.fn.draggable ) {			this._makeDraggable();		}		if ( this.options.resizable && $.fn.resizable ) {			this._makeResizable();		}		this._isOpen = false;		this._trackFocus();	},	_init: function() {		if ( this.options.autoOpen ) {			this.open();		}	},	_appendTo: function() {		var element = this.options.appendTo;		if ( element && ( element.jquery || element.nodeType ) ) {			return $( element );		}		return this.document.find( element || "body" ).eq( 0 );	},	_destroy: function() {		var next,			originalPosition = this.originalPosition;		this._untrackInstance();		this._destroyOverlay();		this.element			.removeUniqueId()			.css( this.originalCss )			// Without detaching first, the following becomes really slow			.detach();		this.uiDialog.remove();		if ( this.originalTitle ) {			this.element.attr( "title", this.originalTitle );		}		next = originalPosition.parent.children().eq( originalPosition.index );		// Don''t try to place the dialog next to itself (#8613)		if ( next.length && next[ 0 ] !!== this.element[ 0 ] ) {			next.before( this.element );		} else {			originalPosition.parent.append( this.element );		}	},	widget: function() {		return this.uiDialog;	},	disable: $.noop,	enable: $.noop,	close: function( event ) {		var that = this;		if ( !!this._isOpen || this._trigger( "beforeClose", event ) === false ) {			return;		}		this._isOpen = false;		this._focusedElement = null;		this._destroyOverlay();		this._untrackInstance();		if ( !!this.opener.filter( ":focusable" ).trigger( "focus" ).length ) {			// Hiding a focused element doesn''t trigger blur in WebKit			// so in case we have nothing to focus on, explicitly blur the active element			// https://bugs.webkit.org/show_bug.cgi?id=47182			$.ui.safeBlur( $.ui.safeActiveElement( this.document[ 0 ] ) );		}		this._hide( this.uiDialog, this.options.hide, function() {			that._trigger( "close", event );		} );	},	isOpen: function() {		return this._isOpen;	},	moveToTop: function() {		this._moveToTop();	},	_moveToTop: function( event, silent ) {		var moved = false,			zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map( function() {				return +$( this ).css( "z-index" );			} ).get(),			zIndexMax = Math.max.apply( null, zIndices );		if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {			this.uiDialog.css( "z-index", zIndexMax + 1 );			moved = true;		}		if ( moved && !!silent ) {			this._trigger( "focus", event );		}		return moved;	},	open: function() {		var that = this;		if ( this._isOpen ) {			if ( this._moveToTop() ) {				this._focusTabbable();			}			return;		}		this._isOpen = true;		this.opener = $( $.ui.safeActiveElement( this.document[ 0 ] ) );		this._size();		this._position();		this._createOverlay();		this._moveToTop( null, true );		// Ensure the overlay is moved to the top with the dialog, but only when		// opening. The overlay shouldn''t move after the dialog is open so that		// modeless dialogs opened after the modal dialog stack properly.		if ( this.overlay ) {			this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );		}		this._show( this.uiDialog, this.options.show, function() {			that._focusTabbable();			that._trigger( "focus" );		} );		// Track the dialog immediately upon opening in case a focus event		// somehow occurs outside of the dialog before an element inside the		// dialog is focused (#10152)		this._makeFocusTarget();		this._trigger( "open" );	},	_focusTabbable: function() {		// Set focus to the first match:		// 1. An element that was focused previously		// 2. First element inside the dialog matching [autofocus]		// 3. Tabbable element inside the content element		// 4. Tabbable element inside the buttonpane		// 5. The close button		// 6. The dialog itself		var hasFocus = this._focusedElement;		if ( !!hasFocus ) {			hasFocus = this.element.find( "[autofocus]" );		}		if ( !!hasFocus.length ) {			hasFocus = this.element.find( ":tabbable" );		}		if ( !!hasFocus.length ) {			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );		}		if ( !!hasFocus.length ) {			hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );		}		if ( !!hasFocus.length ) {			hasFocus = this.uiDialog;		}		hasFocus.eq( 0 ).trigger( "focus" );	},	_restoreTabbableFocus: function() {		var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),			isActive = this.uiDialog[ 0 ] === activeElement ||				$.contains( this.uiDialog[ 0 ], activeElement );		if ( !!isActive ) {			this._focusTabbable();		}	},	_keepFocus: function( event ) {		event.preventDefault();		this._restoreTabbableFocus();		// support: IE		// IE <= 8 doesn''t prevent moving focus even with event.preventDefault()		// so we check again later		this._delay( this._restoreTabbableFocus );	},	_createWrapper: function() {		this.uiDialog = $( "<div>" )			.hide()			.attr( {				// Setting tabIndex makes the div focusable				tabIndex: -1,				role: "dialog"			} )			.appendTo( this._appendTo() );		this._addClass( this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front" );		this._on( this.uiDialog, {			keydown: function( event ) {				if ( this.options.closeOnEscape && !!event.isDefaultPrevented() && event.keyCode &&						event.keyCode === $.ui.keyCode.ESCAPE ) {					event.preventDefault();					this.close( event );					return;				}				// Prevent tabbing out of dialogs				if ( event.keyCode !!== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {					return;				}				var tabbables = this.uiDialog.find( ":tabbable" ),					first = tabbables.first(),					last = tabbables.last();				if ( ( event.target === last[ 0 ] || event.target === this.uiDialog[ 0 ] ) &&						!!event.shiftKey ) {					this._delay( function() {						first.trigger( "focus" );					} );					event.preventDefault();				} else if ( ( event.target === first[ 0 ] ||						event.target === this.uiDialog[ 0 ] ) && event.shiftKey ) {					this._delay( function() {						last.trigger( "focus" );					} );					event.preventDefault();				}			},			mousedown: function( event ) {				if ( this._moveToTop( event ) ) {					this._focusTabbable();				}			}		} );		// We assume that any existing aria-describedby attribute means		// that the dialog content is marked up properly		// otherwise we brute force the content as the description		if ( !!this.element.find( "[aria-describedby]" ).length ) {			this.uiDialog.attr( {				"aria-describedby": this.element.uniqueId().attr( "id" )			} );		}	},	_createTitlebar: function() {		var uiDialogTitle;		this.uiDialogTitlebar = $( "<div>" );		this._addClass( this.uiDialogTitlebar,			"ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix" );		this._on( this.uiDialogTitlebar, {			mousedown: function( event ) {				// Don''t prevent click on close button (#8838)				// Focusing a dialog that is partially scrolled out of view				// causes the browser to scroll it into view, preventing the click event				if ( !!$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {					// Dialog isn''t getting focus when dragging (#8063)					this.uiDialog.trigger( "focus" );				}			}		} );		// Support: IE		// Use type="button" to prevent enter keypresses in textboxes from closing the		// dialog in IE (#9312)		this.uiDialogTitlebarClose = $( "<button type=''button''></button>" )			.button( {				label: $( "<a>" ).text( this.options.closeText ).html(),				icon: "ui-icon-closethick",				showLabel: false			} )			.appendTo( this.uiDialogTitlebar );		this._addClass( this.uiDialogTitlebarClose, "ui-dialog-titlebar-close" );		this._on( this.uiDialogTitlebarClose, {			click: function( event ) {				event.preventDefault();				this.close( event );			}		} );		uiDialogTitle = $( "<span>" ).uniqueId().prependTo( this.uiDialogTitlebar );		this._addClass( uiDialogTitle, "ui-dialog-title" );		this._title( uiDialogTitle );		this.uiDialogTitlebar.prependTo( this.uiDialog );		this.uiDialog.attr( {			"aria-labelledby": uiDialogTitle.attr( "id" )		} );	},	_title: function( title ) {		if ( this.options.title ) {			title.text( this.options.title );		} else {			title.html( "&#160;" );		}	},	_createButtonPane: function() {		this.uiDialogButtonPane = $( "<div>" );		this._addClass( this.uiDialogButtonPane, "ui-dialog-buttonpane",			"ui-widget-content ui-helper-clearfix" );		this.uiButtonSet = $( "<div>" )			.appendTo( this.uiDialogButtonPane );		this._addClass( this.uiButtonSet, "ui-dialog-buttonset" );		this._createButtons();	},	_createButtons: function() {		var that = this,			buttons = this.options.buttons;		// If we already have a button pane, remove it		this.uiDialogButtonPane.remove();		this.uiButtonSet.empty();		if ( $.isEmptyObject( buttons ) || ( Array.isArray( buttons ) && !!buttons.length ) ) {			this._removeClass( this.uiDialog, "ui-dialog-buttons" );			return;		}		$.each( buttons, function( name, props ) {			var click, buttonOptions;			props = typeof props === "function" ?				{ click: props, text: name } :				props;			// Default to a non-submitting button			props = $.extend( { type: "button" }, props );			// Change the context for the click callback to be the main element			click = props.click;			buttonOptions = {				icon: props.icon,				iconPosition: props.iconPosition,				showLabel: props.showLabel,				// Deprecated options				icons: props.icons,				text: props.text			};			delete props.click;			delete props.icon;			delete props.iconPosition;			delete props.showLabel;			// Deprecated options			delete props.icons;			if ( typeof props.text === "boolean" ) {				delete props.text;			}			$( "<button></button>", props )				.button( buttonOptions )				.appendTo( that.uiButtonSet )				.on( "click", function() {					click.apply( that.element[ 0 ], arguments );				} );		} );		this._addClass( this.uiDialog, "ui-dialog-buttons" );		this.uiDialogButtonPane.appendTo( this.uiDialog );	},	_makeDraggable: function() {		var that = this,			options = this.options;		function filteredUi( ui ) {			return {				position: ui.position,				offset: ui.offset			};		}		this.uiDialog.draggable( {			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",			handle: ".ui-dialog-titlebar",			containment: "document",			start: function( event, ui ) {				that._addClass( $( this ), "ui-dialog-dragging" );				that._blockFrames();				that._trigger( "dragStart", event, filteredUi( ui ) );			},			drag: function( event, ui ) {				that._trigger( "drag", event, filteredUi( ui ) );			},			stop: function( event, ui ) {				var left = ui.offset.left - that.document.scrollLeft(),					top = ui.offset.top - that.document.scrollTop();				options.position = {					my: "left top",					at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +						"top" + ( top >= 0 ? "+" : "" ) + top,					of: that.window				};				that._removeClass( $( this ), "ui-dialog-dragging" );				that._unblockFrames();				that._trigger( "dragStop", event, filteredUi( ui ) );			}		} );	},	_makeResizable: function() {		var that = this,			options = this.options,			handles = options.resizable,			// .ui-resizable has position: relative defined in the stylesheet			// but dialogs have to use absolute or fixed positioning			position = this.uiDialog.css( "position" ),			resizeHandles = typeof handles === "string" ?				handles :				"n,e,s,w,se,sw,ne,nw";		function filteredUi( ui ) {			return {				originalPosition: ui.originalPosition,				originalSize: ui.originalSize,				position: ui.position,				size: ui.size			};		}		this.uiDialog.resizable( {			cancel: ".ui-dialog-content",			containment: "document",			alsoResize: this.element,			maxWidth: options.maxWidth,			maxHeight: options.maxHeight,			minWidth: options.minWidth,			minHeight: this._minHeight(),			handles: resizeHandles,			start: function( event, ui ) {				that._addClass( $( this ), "ui-dialog-resizing" );				that._blockFrames();				that._trigger( "resizeStart", event, filteredUi( ui ) );			},			resize: function( event, ui ) {				that._trigger( "resize", event, filteredUi( ui ) );			},			stop: function( event, ui ) {				var offset = that.uiDialog.offset(),					left = offset.left - that.document.scrollLeft(),					top = offset.top - that.document.scrollTop();				options.height = that.uiDialog.height();				options.width = that.uiDialog.width();				options.position = {					my: "left top",					at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +						"top" + ( top >= 0 ? "+" : "" ) + top,					of: that.window				};				that._removeClass( $( this ), "ui-dialog-resizing" );				that._unblockFrames();				that._trigger( "resizeStop", event, filteredUi( ui ) );			}		} )			.css( "position", position );	},	_trackFocus: function() {		this._on( this.widget(), {			focusin: function( event ) {				this._makeFocusTarget();				this._focusedElement = $( event.target );			}		} );	},	_makeFocusTarget: function() {		this._untrackInstance();		this._trackingInstances().unshift( this );	},	_untrackInstance: function() {		var instances = this._trackingInstances(),			exists = $.inArray( this, instances );		if ( exists !!== -1 ) {			instances.splice( exists, 1 );		}	},	_trackingInstances: function() {		var instances = this.document.data( "ui-dialog-instances" );		if ( !!instances ) {			instances = [];			this.document.data( "ui-dialog-instances", instances );		}		return instances;	},	_minHeight: function() {		var options = this.options;		return options.height === "auto" ?			options.minHeight :			Math.min( options.minHeight, options.height );	},	_position: function() {		// Need to show the dialog to get the actual offset in the position plugin		var isVisible = this.uiDialog.is( ":visible" );		if ( !!isVisible ) {			this.uiDialog.show();		}		this.uiDialog.position( this.options.position );		if ( !!isVisible ) {			this.uiDialog.hide();		}	},	_setOptions: function( options ) {		var that = this,			resize = false,			resizableOptions = {};		$.each( options, function( key, value ) {			that._setOption( key, value );			if ( key in that.sizeRelatedOptions ) {				resize = true;			}			if ( key in that.resizableRelatedOptions ) {				resizableOptions[ key ] = value;			}		} );		if ( resize ) {			this._size();			this._position();		}		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {			this.uiDialog.resizable( "option", resizableOptions );		}	},	_setOption: function( key, value ) {		var isDraggable, isResizable,			uiDialog = this.uiDialog;		if ( key === "disabled" ) {			return;		}		this._super( key, value );		if ( key === "appendTo" ) {			this.uiDialog.appendTo( this._appendTo() );		}		if ( key === "buttons" ) {			this._createButtons();		}		if ( key === "closeText" ) {			this.uiDialogTitlebarClose.button( {				// Ensure that we always pass a string				label: $( "<a>" ).text( "" + this.options.closeText ).html()			} );		}		if ( key === "draggable" ) {			isDraggable = uiDialog.is( ":data(ui-draggable)" );			if ( isDraggable && !!value ) {				uiDialog.draggable( "destroy" );			}			if ( !!isDraggable && value ) {				this._makeDraggable();			}		}		if ( key === "position" ) {			this._position();		}		if ( key === "resizable" ) {			// currently resizable, becoming non-resizable			isResizable = uiDialog.is( ":data(ui-resizable)" );			if ( isResizable && !!value ) {				uiDialog.resizable( "destroy" );			}			// Currently resizable, changing handles			if ( isResizable && typeof value === "string" ) {				uiDialog.resizable( "option", "handles", value );			}			// Currently non-resizable, becoming resizable			if ( !!isResizable && value !!== false ) {				this._makeResizable();			}		}		if ( key === "title" ) {			this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );		}	},	_size: function() {		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content		// divs will both have width and height set, so we need to reset them		var nonContentHeight, minContentHeight, maxContentHeight,			options = this.options;		// Reset content sizing		this.element.show().css( {			width: "auto",			minHeight: 0,			maxHeight: "none",			height: 0		} );		if ( options.minWidth > options.width ) {			options.width = options.minWidth;		}		// Reset wrapper sizing		// determine the height of all the non-content elements		nonContentHeight = this.uiDialog.css( {			height: "auto",			width: options.width		} )			.outerHeight();		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );		maxContentHeight = typeof options.maxHeight === "number" ?			Math.max( 0, options.maxHeight - nonContentHeight ) :			"none";		if ( options.height === "auto" ) {			this.element.css( {				minHeight: minContentHeight,				maxHeight: maxContentHeight,				height: "auto"			} );		} else {			this.element.height( Math.max( 0, options.height - nonContentHeight ) );		}		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );		}	},	_blockFrames: function() {		this.iframeBlocks = this.document.find( "iframe" ).map( function() {			var iframe = $( this );			return $( "<div>" )				.css( {					position: "absolute",					width: iframe.outerWidth(),					height: iframe.outerHeight()				} )				.appendTo( iframe.parent() )				.offset( iframe.offset() )[ 0 ];		} );	},	_unblockFrames: function() {		if ( this.iframeBlocks ) {			this.iframeBlocks.remove();			delete this.iframeBlocks;		}	},	_allowInteraction: function( event ) {		if ( $( event.target ).closest( ".ui-dialog" ).length ) {			return true;		}		// TODO: Remove hack when datepicker implements		// the .ui-front logic (#8989)		return !!!!$( event.target ).closest( ".ui-datepicker" ).length;	},	_createOverlay: function() {		if ( !!this.options.modal ) {			return;		}		var jqMinor = $.fn.jquery.substring( 0, 4 );		// We use a delay in case the overlay is created from an		// event that we''re going to be cancelling (#2804)		var isOpening = true;		this._delay( function() {			isOpening = false;		} );		if ( !!this.document.data( "ui-dialog-overlays" ) ) {			// Prevent use of anchors and inputs			// This doesn''t use `_on()` because it is a shared event handler			// across all open modal dialogs.			this.document.on( "focusin.ui-dialog", function( event ) {				if ( isOpening ) {					return;				}				var instance = this._trackingInstances()[ 0 ];				if ( !!instance._allowInteraction( event ) ) {					event.preventDefault();					instance._focusTabbable();					// Support: jQuery >=3.4 <3.6 only					// Focus re-triggering in jQuery 3.4/3.5 makes the original element					// have its focus event propagated last, breaking the re-targeting.					// Trigger focus in a delay in addition if needed to avoid the issue					// See https://github.com/jquery/jquery/issues/4382					if ( jqMinor === "3.4." || jqMinor === "3.5." ) {						instance._delay( instance._restoreTabbableFocus );					}				}			}.bind( this ) );		}		this.overlay = $( "<div>" )			.appendTo( this._appendTo() );		this._addClass( this.overlay, null, "ui-widget-overlay ui-front" );		this._on( this.overlay, {			mousedown: "_keepFocus"		} );		this.document.data( "ui-dialog-overlays",			( this.document.data( "ui-dialog-overlays" ) || 0 ) + 1 );	},	_destroyOverlay: function() {		if ( !!this.options.modal ) {			return;		}		if ( this.overlay ) {			var overlays = this.document.data( "ui-dialog-overlays" ) - 1;			if ( !!overlays ) {				this.document.off( "focusin.ui-dialog" );				this.document.removeData( "ui-dialog-overlays" );			} else {				this.document.data( "ui-dialog-overlays", overlays );			}			this.overlay.remove();			this.overlay = null;		}	}} );// DEPRECATED// TODO: switch return back to widget declaration at top of file when this is removedif ( $.uiBackCompat !!== false ) {	// Backcompat for dialogClass option	$.widget( "ui.dialog", $.ui.dialog, {		options: {			dialogClass: ""		},		_createWrapper: function() {			this._super();			this.uiDialog.addClass( this.options.dialogClass );		},		_setOption: function( key, value ) {			if ( key === "dialogClass" ) {				this.uiDialog					.removeClass( this.options.dialogClass )					.addClass( value );			}			this._superApply( arguments );		}	} );}var widgetsDialog = $.ui.dialog;/*!! * jQuery UI Droppable 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Droppable//>>group: Interactions//>>description: Enables drop targets for draggable elements.//>>docs: http://api.jqueryui.com/droppable///>>demos: http://jqueryui.com/droppable/$.widget( "ui.droppable", {	version: "1.13.2",	widgetEventPrefix: "drop",	options: {		accept: "*",		addClasses: true,		greedy: false,		scope: "default",		tolerance: "intersect",		// Callbacks		activate: null,		deactivate: null,		drop: null,		out: null,		over: null	},	_create: function() {		var proportions,			o = this.options,			accept = o.accept;		this.isover = false;		this.isout = true;		this.accept = typeof accept === "function" ? accept : function( d ) {			return d.is( accept );		};		this.proportions = function( /* valueToWrite */ ) {			if ( arguments.length ) {				// Store the droppable''s proportions				proportions = arguments[ 0 ];			} else {				// Retrieve or derive the droppable''s proportions				return proportions ?					proportions :					proportions = {						width: this.element[ 0 ].offsetWidth,						height: this.element[ 0 ].offsetHeight					};			}		};		this._addToManager( o.scope );		if ( o.addClasses ) {			this._addClass( "ui-droppable" );		}	},	_addToManager: function( scope ) {		// Add the reference and positions to the manager		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];		$.ui.ddmanager.droppables[ scope ].push( this );	},	_splice: function( drop ) {		var i = 0;		for ( ; i < drop.length; i++ ) {			if ( drop[ i ] === this ) {				drop.splice( i, 1 );			}		}	},	_destroy: function() {		var drop = $.ui.ddmanager.droppables[ this.options.scope ];		this._splice( drop );	},	_setOption: function( key, value ) {		if ( key === "accept" ) {			this.accept = typeof value === "function" ? value : function( d ) {				return d.is( value );			};		} else if ( key === "scope" ) {			var drop = $.ui.ddmanager.droppables[ this.options.scope ];			this._splice( drop );			this._addToManager( value );		}		this._super( key, value );	},	_activate: function( event ) {		var draggable = $.ui.ddmanager.current;		this._addActiveClass();		if ( draggable ) {			this._trigger( "activate", event, this.ui( draggable ) );		}	},	_deactivate: function( event ) {		var draggable = $.ui.ddmanager.current;		this._removeActiveClass();		if ( draggable ) {			this._trigger( "deactivate", event, this.ui( draggable ) );		}	},	_over: function( event ) {		var draggable = $.ui.ddmanager.current;		// Bail if draggable and droppable are same element		if ( !!draggable || ( draggable.currentItem ||				draggable.element )[ 0 ] === this.element[ 0 ] ) {			return;		}		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||				draggable.element ) ) ) {			this._addHoverClass();			this._trigger( "over", event, this.ui( draggable ) );		}	},	_out: function( event ) {		var draggable = $.ui.ddmanager.current;		// Bail if draggable and droppable are same element		if ( !!draggable || ( draggable.currentItem ||				draggable.element )[ 0 ] === this.element[ 0 ] ) {			return;		}		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||				draggable.element ) ) ) {			this._removeHoverClass();			this._trigger( "out", event, this.ui( draggable ) );		}	},	_drop: function( event, custom ) {		var draggable = custom || $.ui.ddmanager.current,			childrenIntersection = false;		// Bail if draggable and droppable are same element		if ( !!draggable || ( draggable.currentItem ||				draggable.element )[ 0 ] === this.element[ 0 ] ) {			return false;		}		this.element			.find( ":data(ui-droppable)" )			.not( ".ui-draggable-dragging" )			.each( function() {				var inst = $( this ).droppable( "instance" );				if (					inst.options.greedy &&					!!inst.options.disabled &&					inst.options.scope === draggable.options.scope &&					inst.accept.call(						inst.element[ 0 ], ( draggable.currentItem || draggable.element )					) &&					$.ui.intersect(						draggable,						$.extend( inst, { offset: inst.element.offset() } ),						inst.options.tolerance, event					)				) {					childrenIntersection = true;					return false;				}			} );		if ( childrenIntersection ) {			return false;		}		if ( this.accept.call( this.element[ 0 ],				( draggable.currentItem || draggable.element ) ) ) {			this._removeActiveClass();			this._removeHoverClass();			this._trigger( "drop", event, this.ui( draggable ) );			return this.element;		}		return false;	},	ui: function( c ) {		return {			draggable: ( c.currentItem || c.element ),			helper: c.helper,			position: c.position,			offset: c.positionAbs		};	},	// Extension points just to make backcompat sane and avoid duplicating logic	// TODO: Remove in 1.14 along with call to it below	_addHoverClass: function() {		this._addClass( "ui-droppable-hover" );	},	_removeHoverClass: function() {		this._removeClass( "ui-droppable-hover" );	},	_addActiveClass: function() {		this._addClass( "ui-droppable-active" );	},	_removeActiveClass: function() {		this._removeClass( "ui-droppable-active" );	}} );$.ui.intersect = ( function() {	function isOverAxis( x, reference, size ) {		return ( x >= reference ) && ( x < ( reference + size ) );	}	return function( draggable, droppable, toleranceMode, event ) {		if ( !!droppable.offset ) {			return false;		}		var x1 = ( draggable.positionAbs ||				draggable.position.absolute ).left + draggable.margins.left,			y1 = ( draggable.positionAbs ||				draggable.position.absolute ).top + draggable.margins.top,			x2 = x1 + draggable.helperProportions.width,			y2 = y1 + draggable.helperProportions.height,			l = droppable.offset.left,			t = droppable.offset.top,			r = l + droppable.proportions().width,			b = t + droppable.proportions().height;		switch ( toleranceMode ) {		case "fit":			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );		case "intersect":			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half		case "pointer":			return isOverAxis( event.pageY, t, droppable.proportions().height ) &&				isOverAxis( event.pageX, l, droppable.proportions().width );		case "touch":			return (				( y1 >= t && y1 <= b ) || // Top edge touching				( y2 >= t && y2 <= b ) || // Bottom edge touching				( y1 < t && y2 > b ) // Surrounded vertically			) && (				( x1 >= l && x1 <= r ) || // Left edge touching				( x2 >= l && x2 <= r ) || // Right edge touching				( x1 < l && x2 > r ) // Surrounded horizontally			);		default:			return false;		}	};} )();/*	This manager tracks offsets of draggables and droppables*/$.ui.ddmanager = {	current: null,	droppables: { "default": [] },	prepareOffsets: function( t, event ) {		var i, j,			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],			type = event ? event.type : null, // workaround for #2317			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();		droppablesLoop: for ( i = 0; i < m.length; i++ ) {			// No disabled and non-accepted			if ( m[ i ].options.disabled || ( t && !!m[ i ].accept.call( m[ i ].element[ 0 ],					( t.currentItem || t.element ) ) ) ) {				continue;			}			// Filter out elements in the current dragged item			for ( j = 0; j < list.length; j++ ) {				if ( list[ j ] === m[ i ].element[ 0 ] ) {					m[ i ].proportions().height = 0;					continue droppablesLoop;				}			}			m[ i ].visible = m[ i ].element.css( "display" ) !!== "none";			if ( !!m[ i ].visible ) {				continue;			}			// Activate the droppable if used directly from draggables			if ( type === "mousedown" ) {				m[ i ]._activate.call( m[ i ], event );			}			m[ i ].offset = m[ i ].element.offset();			m[ i ].proportions( {				width: m[ i ].element[ 0 ].offsetWidth,				height: m[ i ].element[ 0 ].offsetHeight			} );		}	},	drop: function( draggable, event ) {		var dropped = false;		// Create a copy of the droppables in case the list changes during the drop (#9116)		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {			if ( !!this.options ) {				return;			}			if ( !!this.options.disabled && this.visible &&					$.ui.intersect( draggable, this, this.options.tolerance, event ) ) {				dropped = this._drop.call( this, event ) || dropped;			}			if ( !!this.options.disabled && this.visible && this.accept.call( this.element[ 0 ],					( draggable.currentItem || draggable.element ) ) ) {				this.isout = true;				this.isover = false;				this._deactivate.call( this, event );			}		} );		return dropped;	},	dragStart: function( draggable, event ) {		// Listen for scrolling so that if the dragging causes scrolling the position of the		// droppables can be recalculated (see #5003)		draggable.element.parentsUntil( "body" ).on( "scroll.droppable", function() {			if ( !!draggable.options.refreshPositions ) {				$.ui.ddmanager.prepareOffsets( draggable, event );			}		} );	},	drag: function( draggable, event ) {		// If you have a highly dynamic page, you might try this option. It renders positions		// every time you move the mouse.		if ( draggable.options.refreshPositions ) {			$.ui.ddmanager.prepareOffsets( draggable, event );		}		// Run through all droppables and check their positions based on specific tolerance options		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {			if ( this.options.disabled || this.greedyChild || !!this.visible ) {				return;			}			var parentInstance, scope, parent,				intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),				c = !!intersects && this.isover ?					"isout" :					( intersects && !!this.isover ? "isover" : null );			if ( !!c ) {				return;			}			if ( this.options.greedy ) {				// find droppable parents with same scope				scope = this.options.scope;				parent = this.element.parents( ":data(ui-droppable)" ).filter( function() {					return $( this ).droppable( "instance" ).options.scope === scope;				} );				if ( parent.length ) {					parentInstance = $( parent[ 0 ] ).droppable( "instance" );					parentInstance.greedyChild = ( c === "isover" );				}			}			// We just moved into a greedy child			if ( parentInstance && c === "isover" ) {				parentInstance.isover = false;				parentInstance.isout = true;				parentInstance._out.call( parentInstance, event );			}			this[ c ] = true;			this[ c === "isout" ? "isover" : "isout" ] = false;			this[ c === "isover" ? "_over" : "_out" ].call( this, event );			// We just moved out of a greedy child			if ( parentInstance && c === "isout" ) {				parentInstance.isout = false;				parentInstance.isover = true;				parentInstance._over.call( parentInstance, event );			}		} );	},	dragStop: function( draggable, event ) {		draggable.element.parentsUntil( "body" ).off( "scroll.droppable" );		// Call prepareOffsets one final time since IE does not fire return scroll events when		// overflow was caused by drag (see #5003)		if ( !!draggable.options.refreshPositions ) {			$.ui.ddmanager.prepareOffsets( draggable, event );		}	}};// DEPRECATED// TODO: switch return back to widget declaration at top of file when this is removedif ( $.uiBackCompat !!== false ) {	// Backcompat for activeClass and hoverClass options	$.widget( "ui.droppable", $.ui.droppable, {		options: {			hoverClass: false,			activeClass: false		},		_addActiveClass: function() {			this._super();			if ( this.options.activeClass ) {				this.element.addClass( this.options.activeClass );			}		},		_removeActiveClass: function() {			this._super();			if ( this.options.activeClass ) {				this.element.removeClass( this.options.activeClass );			}		},		_addHoverClass: function() {			this._super();			if ( this.options.hoverClass ) {				this.element.addClass( this.options.hoverClass );			}		},		_removeHoverClass: function() {			this._super();			if ( this.options.hoverClass ) {				this.element.removeClass( this.options.hoverClass );			}		}	} );}var widgetsDroppable = $.ui.droppable;/*!! * jQuery UI Progressbar 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Progressbar//>>group: Widgets/* eslint-disable max-len *///>>description: Displays a status indicator for loading state, standard percentage, and other progress indicators./* eslint-enable max-len *///>>docs: http://api.jqueryui.com/progressbar///>>demos: http://jqueryui.com/progressbar///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/progressbar.css//>>css.theme: ../../themes/base/theme.cssvar widgetsProgressbar = $.widget( "ui.progressbar", {	version: "1.13.2",	options: {		classes: {			"ui-progressbar": "ui-corner-all",			"ui-progressbar-value": "ui-corner-left",			"ui-progressbar-complete": "ui-corner-right"		},		max: 100,		value: 0,		change: null,		complete: null	},	min: 0,	_create: function() {		// Constrain initial value		this.oldValue = this.options.value = this._constrainedValue();		this.element.attr( {			// Only set static values; aria-valuenow and aria-valuemax are			// set inside _refreshValue()			role: "progressbar",			"aria-valuemin": this.min		} );		this._addClass( "ui-progressbar", "ui-widget ui-widget-content" );		this.valueDiv = $( "<div>" ).appendTo( this.element );		this._addClass( this.valueDiv, "ui-progressbar-value", "ui-widget-header" );		this._refreshValue();	},	_destroy: function() {		this.element.removeAttr( "role aria-valuemin aria-valuemax aria-valuenow" );		this.valueDiv.remove();	},	value: function( newValue ) {		if ( newValue === undefined ) {			return this.options.value;		}		this.options.value = this._constrainedValue( newValue );		this._refreshValue();	},	_constrainedValue: function( newValue ) {		if ( newValue === undefined ) {			newValue = this.options.value;		}		this.indeterminate = newValue === false;		// Sanitize value		if ( typeof newValue !!== "number" ) {			newValue = 0;		}		return this.indeterminate ? false :			Math.min( this.options.max, Math.max( this.min, newValue ) );	},	_setOptions: function( options ) {		// Ensure "value" option is set after other values (like max)		var value = options.value;		delete options.value;		this._super( options );		this.options.value = this._constrainedValue( value );		this._refreshValue();	},	_setOption: function( key, value ) {		if ( key === "max" ) {			// Don''t allow a max less than min			value = Math.max( this.min, value );		}		this._super( key, value );	},	_setOptionDisabled: function( value ) {		this._super( value );		this.element.attr( "aria-disabled", value );		this._toggleClass( null, "ui-state-disabled", !!!!value );	},	_percentage: function() {		return this.indeterminate ?			100 :			100 * ( this.options.value - this.min ) / ( this.options.max - this.min );	},	_refreshValue: function() {		var value = this.options.value,			percentage = this._percentage();		this.valueDiv			.toggle( this.indeterminate || value > this.min )			.width( percentage.toFixed( 0 ) + "%" );		this			._toggleClass( this.valueDiv, "ui-progressbar-complete", null,				value === this.options.max )			._toggleClass( "ui-progressbar-indeterminate", null, this.indeterminate );		if ( this.indeterminate ) {			this.element.removeAttr( "aria-valuenow" );			if ( !!this.overlayDiv ) {				this.overlayDiv = $( "<div>" ).appendTo( this.valueDiv );				this._addClass( this.overlayDiv, "ui-progressbar-overlay" );			}		} else {			this.element.attr( {				"aria-valuemax": this.options.max,				"aria-valuenow": value			} );			if ( this.overlayDiv ) {				this.overlayDiv.remove();				this.overlayDiv = null;			}		}		if ( this.oldValue !!== value ) {			this.oldValue = value;			this._trigger( "change" );		}		if ( value === this.options.max ) {			this._trigger( "complete" );		}	}} );/*!! * jQuery UI Selectable 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Selectable//>>group: Interactions//>>description: Allows groups of elements to be selected with the mouse.//>>docs: http://api.jqueryui.com/selectable///>>demos: http://jqueryui.com/selectable///>>css.structure: ../../themes/base/selectable.cssvar widgetsSelectable = $.widget( "ui.selectable", $.ui.mouse, {	version: "1.13.2",	options: {		appendTo: "body",		autoRefresh: true,		distance: 0,		filter: "*",		tolerance: "touch",		// Callbacks		selected: null,		selecting: null,		start: null,		stop: null,		unselected: null,		unselecting: null	},	_create: function() {		var that = this;		this._addClass( "ui-selectable" );		this.dragged = false;		// Cache selectee children based on filter		this.refresh = function() {			that.elementPos = $( that.element[ 0 ] ).offset();			that.selectees = $( that.options.filter, that.element[ 0 ] );			that._addClass( that.selectees, "ui-selectee" );			that.selectees.each( function() {				var $this = $( this ),					selecteeOffset = $this.offset(),					pos = {						left: selecteeOffset.left - that.elementPos.left,						top: selecteeOffset.top - that.elementPos.top					};				$.data( this, "selectable-item", {					element: this,					$element: $this,					left: pos.left,					top: pos.top,					right: pos.left + $this.outerWidth(),					bottom: pos.top + $this.outerHeight(),					startselected: false,					selected: $this.hasClass( "ui-selected" ),					selecting: $this.hasClass( "ui-selecting" ),					unselecting: $this.hasClass( "ui-unselecting" )				} );			} );		};		this.refresh();		this._mouseInit();		this.helper = $( "<div>" );		this._addClass( this.helper, "ui-selectable-helper" );	},	_destroy: function() {		this.selectees.removeData( "selectable-item" );		this._mouseDestroy();	},	_mouseStart: function( event ) {		var that = this,			options = this.options;		this.opos = [ event.pageX, event.pageY ];		this.elementPos = $( this.element[ 0 ] ).offset();		if ( this.options.disabled ) {			return;		}		this.selectees = $( options.filter, this.element[ 0 ] );		this._trigger( "start", event );		$( options.appendTo ).append( this.helper );		// position helper (lasso)		this.helper.css( {			"left": event.pageX,			"top": event.pageY,			"width": 0,			"height": 0		} );		if ( options.autoRefresh ) {			this.refresh();		}		this.selectees.filter( ".ui-selected" ).each( function() {			var selectee = $.data( this, "selectable-item" );			selectee.startselected = true;			if ( !!event.metaKey && !!event.ctrlKey ) {				that._removeClass( selectee.$element, "ui-selected" );				selectee.selected = false;				that._addClass( selectee.$element, "ui-unselecting" );				selectee.unselecting = true;				// selectable UNSELECTING callback				that._trigger( "unselecting", event, {					unselecting: selectee.element				} );			}		} );		$( event.target ).parents().addBack().each( function() {			var doSelect,				selectee = $.data( this, "selectable-item" );			if ( selectee ) {				doSelect = ( !!event.metaKey && !!event.ctrlKey ) ||					!!selectee.$element.hasClass( "ui-selected" );				that._removeClass( selectee.$element, doSelect ? "ui-unselecting" : "ui-selected" )					._addClass( selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting" );				selectee.unselecting = !!doSelect;				selectee.selecting = doSelect;				selectee.selected = doSelect;				// selectable (UN)SELECTING callback				if ( doSelect ) {					that._trigger( "selecting", event, {						selecting: selectee.element					} );				} else {					that._trigger( "unselecting", event, {						unselecting: selectee.element					} );				}				return false;			}		} );	},	_mouseDrag: function( event ) {		this.dragged = true;		if ( this.options.disabled ) {			return;		}		var tmp,			that = this,			options = this.options,			x1 = this.opos[ 0 ],			y1 = this.opos[ 1 ],			x2 = event.pageX,			y2 = event.pageY;		if ( x1 > x2 ) {			tmp = x2; x2 = x1; x1 = tmp;		}		if ( y1 > y2 ) {			tmp = y2; y2 = y1; y1 = tmp;		}		this.helper.css( { left: x1, top: y1, width: x2 - x1, height: y2 - y1 } );		this.selectees.each( function() {			var selectee = $.data( this, "selectable-item" ),				hit = false,				offset = {};			//prevent helper from being selected if appendTo: selectable			if ( !!selectee || selectee.element === that.element[ 0 ] ) {				return;			}			offset.left   = selectee.left   + that.elementPos.left;			offset.right  = selectee.right  + that.elementPos.left;			offset.top    = selectee.top    + that.elementPos.top;			offset.bottom = selectee.bottom + that.elementPos.top;			if ( options.tolerance === "touch" ) {				hit = ( !!( offset.left > x2 || offset.right < x1 || offset.top > y2 ||                    offset.bottom < y1 ) );			} else if ( options.tolerance === "fit" ) {				hit = ( offset.left > x1 && offset.right < x2 && offset.top > y1 &&                    offset.bottom < y2 );			}			if ( hit ) {				// SELECT				if ( selectee.selected ) {					that._removeClass( selectee.$element, "ui-selected" );					selectee.selected = false;				}				if ( selectee.unselecting ) {					that._removeClass( selectee.$element, "ui-unselecting" );					selectee.unselecting = false;				}				if ( !!selectee.selecting ) {					that._addClass( selectee.$element, "ui-selecting" );					selectee.selecting = true;					// selectable SELECTING callback					that._trigger( "selecting", event, {						selecting: selectee.element					} );				}			} else {				// UNSELECT				if ( selectee.selecting ) {					if ( ( event.metaKey || event.ctrlKey ) && selectee.startselected ) {						that._removeClass( selectee.$element, "ui-selecting" );						selectee.selecting = false;						that._addClass( selectee.$element, "ui-selected" );						selectee.selected = true;					} else {						that._removeClass( selectee.$element, "ui-selecting" );						selectee.selecting = false;						if ( selectee.startselected ) {							that._addClass( selectee.$element, "ui-unselecting" );							selectee.unselecting = true;						}						// selectable UNSELECTING callback						that._trigger( "unselecting", event, {							unselecting: selectee.element						} );					}				}				if ( selectee.selected ) {					if ( !!event.metaKey && !!event.ctrlKey && !!selectee.startselected ) {						that._removeClass( selectee.$element, "ui-selected" );						selectee.selected = false;						that._addClass( selectee.$element, "ui-unselecting" );						selectee.unselecting = true;						// selectable UNSELECTING callback						that._trigger( "unselecting", event, {							unselecting: selectee.element						} );					}				}			}		} );		return false;	},	_mouseStop: function( event ) {		var that = this;		this.dragged = false;		$( ".ui-unselecting", this.element[ 0 ] ).each( function() {			var selectee = $.data( this, "selectable-item" );			that._removeClass( selectee.$element, "ui-unselecting" );			selectee.unselecting = false;			selectee.startselected = false;			that._trigger( "unselected", event, {				unselected: selectee.element			} );		} );		$( ".ui-selecting", this.element[ 0 ] ).each( function() {			var selectee = $.data( this, "selectable-item" );			that._removeClass( selectee.$element, "ui-selecting" )				._addClass( selectee.$element, "ui-selected" );			selectee.selecting = false;			selectee.selected = true;			selectee.startselected = true;			that._trigger( "selected", event, {				selected: selectee.element			} );		} );		this._trigger( "stop", event );		this.helper.remove();		return false;	}} );/*!! * jQuery UI Selectmenu 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Selectmenu//>>group: Widgets/* eslint-disable max-len *///>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select./* eslint-enable max-len *///>>docs: http://api.jqueryui.com/selectmenu///>>demos: http://jqueryui.com/selectmenu///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css//>>css.theme: ../../themes/base/theme.cssvar widgetsSelectmenu = $.widget( "ui.selectmenu", [ $.ui.formResetMixin, {	version: "1.13.2",	defaultElement: "<select>",	options: {		appendTo: null,		classes: {			"ui-selectmenu-button-open": "ui-corner-top",			"ui-selectmenu-button-closed": "ui-corner-all"		},		disabled: null,		icons: {			button: "ui-icon-triangle-1-s"		},		position: {			my: "left top",			at: "left bottom",			collision: "none"		},		width: false,		// Callbacks		change: null,		close: null,		focus: null,		open: null,		select: null	},	_create: function() {		var selectmenuId = this.element.uniqueId().attr( "id" );		this.ids = {			element: selectmenuId,			button: selectmenuId + "-button",			menu: selectmenuId + "-menu"		};		this._drawButton();		this._drawMenu();		this._bindFormResetHandler();		this._rendered = false;		this.menuItems = $();	},	_drawButton: function() {		var icon,			that = this,			item = this._parseOption(				this.element.find( "option:selected" ),				this.element[ 0 ].selectedIndex			);		// Associate existing label with the new button		this.labels = this.element.labels().attr( "for", this.ids.button );		this._on( this.labels, {			click: function( event ) {				this.button.trigger( "focus" );				event.preventDefault();			}		} );		// Hide original select element		this.element.hide();		// Create button		this.button = $( "<span>", {			tabindex: this.options.disabled ? -1 : 0,			id: this.ids.button,			role: "combobox",			"aria-expanded": "false",			"aria-autocomplete": "list",			"aria-owns": this.ids.menu,			"aria-haspopup": "true",			title: this.element.attr( "title" )		} )			.insertAfter( this.element );		this._addClass( this.button, "ui-selectmenu-button ui-selectmenu-button-closed",			"ui-button ui-widget" );		icon = $( "<span>" ).appendTo( this.button );		this._addClass( icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button );		this.buttonItem = this._renderButtonItem( item )			.appendTo( this.button );		if ( this.options.width !!== false ) {			this._resizeButton();		}		this._on( this.button, this._buttonEvents );		this.button.one( "focusin", function() {			// Delay rendering the menu items until the button receives focus.			// The menu may have already been rendered via a programmatic open.			if ( !!that._rendered ) {				that._refreshMenu();			}		} );	},	_drawMenu: function() {		var that = this;		// Create menu		this.menu = $( "<ul>", {			"aria-hidden": "true",			"aria-labelledby": this.ids.button,			id: this.ids.menu		} );		// Wrap menu		this.menuWrap = $( "<div>" ).append( this.menu );		this._addClass( this.menuWrap, "ui-selectmenu-menu", "ui-front" );		this.menuWrap.appendTo( this._appendTo() );		// Initialize menu widget		this.menuInstance = this.menu			.menu( {				classes: {					"ui-menu": "ui-corner-bottom"				},				role: "listbox",				select: function( event, ui ) {					event.preventDefault();					// Support: IE8					// If the item was selected via a click, the text selection					// will be destroyed in IE					that._setSelection();					that._select( ui.item.data( "ui-selectmenu-item" ), event );				},				focus: function( event, ui ) {					var item = ui.item.data( "ui-selectmenu-item" );					// Prevent inital focus from firing and check if its a newly focused item					if ( that.focusIndex !!= null && item.index !!== that.focusIndex ) {						that._trigger( "focus", event, { item: item } );						if ( !!that.isOpen ) {							that._select( item, event );						}					}					that.focusIndex = item.index;					that.button.attr( "aria-activedescendant",						that.menuItems.eq( item.index ).attr( "id" ) );				}			} )			.menu( "instance" );		// Don''t close the menu on mouseleave		this.menuInstance._off( this.menu, "mouseleave" );		// Cancel the menu''s collapseAll on document click		this.menuInstance._closeOnDocumentClick = function() {			return false;		};		// Selects often contain empty items, but never contain dividers		this.menuInstance._isDivider = function() {			return false;		};	},	refresh: function() {		this._refreshMenu();		this.buttonItem.replaceWith(			this.buttonItem = this._renderButtonItem(				// Fall back to an empty object in case there are no options				this._getSelectedItem().data( "ui-selectmenu-item" ) || {}			)		);		if ( this.options.width === null ) {			this._resizeButton();		}	},	_refreshMenu: function() {		var item,			options = this.element.find( "option" );		this.menu.empty();		this._parseOptions( options );		this._renderMenu( this.menu, this.items );		this.menuInstance.refresh();		this.menuItems = this.menu.find( "li" )			.not( ".ui-selectmenu-optgroup" )				.find( ".ui-menu-item-wrapper" );		this._rendered = true;		if ( !!options.length ) {			return;		}		item = this._getSelectedItem();		// Update the menu to have the correct item focused		this.menuInstance.focus( null, item );		this._setAria( item.data( "ui-selectmenu-item" ) );		// Set disabled state		this._setOption( "disabled", this.element.prop( "disabled" ) );	},	open: function( event ) {		if ( this.options.disabled ) {			return;		}		// If this is the first time the menu is being opened, render the items		if ( !!this._rendered ) {			this._refreshMenu();		} else {			// Menu clears focus on close, reset focus to selected item			this._removeClass( this.menu.find( ".ui-state-active" ), null, "ui-state-active" );			this.menuInstance.focus( null, this._getSelectedItem() );		}		// If there are no options, don''t open the menu		if ( !!this.menuItems.length ) {			return;		}		this.isOpen = true;		this._toggleAttr();		this._resizeMenu();		this._position();		this._on( this.document, this._documentClick );		this._trigger( "open", event );	},	_position: function() {		this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );	},	close: function( event ) {		if ( !!this.isOpen ) {			return;		}		this.isOpen = false;		this._toggleAttr();		this.range = null;		this._off( this.document );		this._trigger( "close", event );	},	widget: function() {		return this.button;	},	menuWidget: function() {		return this.menu;	},	_renderButtonItem: function( item ) {		var buttonItem = $( "<span>" );		this._setText( buttonItem, item.label );		this._addClass( buttonItem, "ui-selectmenu-text" );		return buttonItem;	},	_renderMenu: function( ul, items ) {		var that = this,			currentOptgroup = "";		$.each( items, function( index, item ) {			var li;			if ( item.optgroup !!== currentOptgroup ) {				li = $( "<li>", {					text: item.optgroup				} );				that._addClass( li, "ui-selectmenu-optgroup", "ui-menu-divider" +					( item.element.parent( "optgroup" ).prop( "disabled" ) ?						" ui-state-disabled" :						"" ) );				li.appendTo( ul );				currentOptgroup = item.optgroup;			}			that._renderItemData( ul, item );		} );	},	_renderItemData: function( ul, item ) {		return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );	},	_renderItem: function( ul, item ) {		var li = $( "<li>" ),			wrapper = $( "<div>", {				title: item.element.attr( "title" )			} );		if ( item.disabled ) {			this._addClass( li, null, "ui-state-disabled" );		}		this._setText( wrapper, item.label );		return li.append( wrapper ).appendTo( ul );	},	_setText: function( element, value ) {		if ( value ) {			element.text( value );		} else {			element.html( "&#160;" );		}	},	_move: function( direction, event ) {		var item, next,			filter = ".ui-menu-item";		if ( this.isOpen ) {			item = this.menuItems.eq( this.focusIndex ).parent( "li" );		} else {			item = this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );			filter += ":not(.ui-state-disabled)";		}		if ( direction === "first" || direction === "last" ) {			next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );		} else {			next = item[ direction + "All" ]( filter ).eq( 0 );		}		if ( next.length ) {			this.menuInstance.focus( event, next );		}	},	_getSelectedItem: function() {		return this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );	},	_toggle: function( event ) {		this[ this.isOpen ? "close" : "open" ]( event );	},	_setSelection: function() {		var selection;		if ( !!this.range ) {			return;		}		if ( window.getSelection ) {			selection = window.getSelection();			selection.removeAllRanges();			selection.addRange( this.range );		// Support: IE8		} else {			this.range.select();		}		// Support: IE		// Setting the text selection kills the button focus in IE, but		// restoring the focus doesn''t kill the selection.		this.button.trigger( "focus" );	},	_documentClick: {		mousedown: function( event ) {			if ( !!this.isOpen ) {				return;			}			if ( !!$( event.target ).closest( ".ui-selectmenu-menu, #" +				$.escapeSelector( this.ids.button ) ).length ) {				this.close( event );			}		}	},	_buttonEvents: {		// Prevent text selection from being reset when interacting with the selectmenu (#10144)		mousedown: function() {			var selection;			if ( window.getSelection ) {				selection = window.getSelection();				if ( selection.rangeCount ) {					this.range = selection.getRangeAt( 0 );				}			// Support: IE8			} else {				this.range = document.selection.createRange();			}		},		click: function( event ) {			this._setSelection();			this._toggle( event );		},		keydown: function( event ) {			var preventDefault = true;			switch ( event.keyCode ) {			case $.ui.keyCode.TAB:			case $.ui.keyCode.ESCAPE:				this.close( event );				preventDefault = false;				break;			case $.ui.keyCode.ENTER:				if ( this.isOpen ) {					this._selectFocusedItem( event );				}				break;			case $.ui.keyCode.UP:				if ( event.altKey ) {					this._toggle( event );				} else {					this._move( "prev", event );				}				break;			case $.ui.keyCode.DOWN:				if ( event.altKey ) {					this._toggle( event );				} else {					this._move( "next", event );				}				break;			case $.ui.keyCode.SPACE:				if ( this.isOpen ) {					this._selectFocusedItem( event );				} else {					this._toggle( event );				}				break;			case $.ui.keyCode.LEFT:				this._move( "prev", event );				break;			case $.ui.keyCode.RIGHT:				this._move( "next", event );				break;			case $.ui.keyCode.HOME:			case $.ui.keyCode.PAGE_UP:				this._move( "first", event );				break;			case $.ui.keyCode.END:			case $.ui.keyCode.PAGE_DOWN:				this._move( "last", event );				break;			default:				this.menu.trigger( event );				preventDefault = false;			}			if ( preventDefault ) {				event.preventDefault();			}		}	},	_selectFocusedItem: function( event ) {		var item = this.menuItems.eq( this.focusIndex ).parent( "li" );		if ( !!item.hasClass( "ui-state-disabled" ) ) {			this._select( item.data( "ui-selectmenu-item" ), event );		}	},	_select: function( item, event ) {		var oldIndex = this.element[ 0 ].selectedIndex;		// Change native select element		this.element[ 0 ].selectedIndex = item.index;		this.buttonItem.replaceWith( this.buttonItem = this._renderButtonItem( item ) );		this._setAria( item );		this._trigger( "select", event, { item: item } );		if ( item.index !!== oldIndex ) {			this._trigger( "change", event, { item: item } );		}		this.close( event );	},	_setAria: function( item ) {		var id = this.menuItems.eq( item.index ).attr( "id" );		this.button.attr( {			"aria-labelledby": id,			"aria-activedescendant": id		} );		this.menu.attr( "aria-activedescendant", id );	},	_setOption: function( key, value ) {		if ( key === "icons" ) {			var icon = this.button.find( "span.ui-icon" );			this._removeClass( icon, null, this.options.icons.button )				._addClass( icon, null, value.button );		}		this._super( key, value );		if ( key === "appendTo" ) {			this.menuWrap.appendTo( this._appendTo() );		}		if ( key === "width" ) {			this._resizeButton();		}	},	_setOptionDisabled: function( value ) {		this._super( value );		this.menuInstance.option( "disabled", value );		this.button.attr( "aria-disabled", value );		this._toggleClass( this.button, null, "ui-state-disabled", value );		this.element.prop( "disabled", value );		if ( value ) {			this.button.attr( "tabindex", -1 );			this.close();		} else {			this.button.attr( "tabindex", 0 );		}	},	_appendTo: function() {		var element = this.options.appendTo;		if ( element ) {			element = element.jquery || element.nodeType ?				$( element ) :				this.document.find( element ).eq( 0 );		}		if ( !!element || !!element[ 0 ] ) {			element = this.element.closest( ".ui-front, dialog" );		}		if ( !!element.length ) {			element = this.document[ 0 ].body;		}		return element;	},	_toggleAttr: function() {		this.button.attr( "aria-expanded", this.isOpen );		// We can''t use two _toggleClass() calls here, because we need to make sure		// we always remove classes first and add them second, otherwise if both classes have the		// same theme class, it will be removed after we add it.		this._removeClass( this.button, "ui-selectmenu-button-" +			( this.isOpen ? "closed" : "open" ) )			._addClass( this.button, "ui-selectmenu-button-" +				( this.isOpen ? "open" : "closed" ) )			._toggleClass( this.menuWrap, "ui-selectmenu-open", null, this.isOpen );		this.menu.attr( "aria-hidden", !!this.isOpen );	},	_resizeButton: function() {		var width = this.options.width;		// For `width: false`, just remove inline style and stop		if ( width === false ) {			this.button.css( "width", "" );			return;		}		// For `width: null`, match the width of the original element		if ( width === null ) {			width = this.element.show().outerWidth();			this.element.hide();		}		this.button.outerWidth( width );	},	_resizeMenu: function() {		this.menu.outerWidth( Math.max(			this.button.outerWidth(),			// Support: IE10			// IE10 wraps long text (possibly a rounding bug)			// so we add 1px to avoid the wrapping			this.menu.width( "" ).outerWidth() + 1		) );	},	_getCreateOptions: function() {		var options = this._super();		options.disabled = this.element.prop( "disabled" );		return options;	},	_parseOptions: function( options ) {		var that = this,			data = [];		options.each( function( index, item ) {			if ( item.hidden ) {				return;			}			data.push( that._parseOption( $( item ), index ) );		} );		this.items = data;	},	_parseOption: function( option, index ) {		var optgroup = option.parent( "optgroup" );		return {			element: option,			index: index,			value: option.val(),			label: option.text(),			optgroup: optgroup.attr( "label" ) || "",			disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )		};	},	_destroy: function() {		this._unbindFormResetHandler();		this.menuWrap.remove();		this.button.remove();		this.element.show();		this.element.removeUniqueId();		this.labels.attr( "for", this.ids.element );	}} ] );/*!! * jQuery UI Slider 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Slider//>>group: Widgets//>>description: Displays a flexible slider with ranges and accessibility via keyboard.//>>docs: http://api.jqueryui.com/slider///>>demos: http://jqueryui.com/slider///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/slider.css//>>css.theme: ../../themes/base/theme.cssvar widgetsSlider = $.widget( "ui.slider", $.ui.mouse, {	version: "1.13.2",	widgetEventPrefix: "slide",	options: {		animate: false,		classes: {			"ui-slider": "ui-corner-all",			"ui-slider-handle": "ui-corner-all",			// Note: ui-widget-header isn''t the most fittingly semantic framework class for this			// element, but worked best visually with a variety of themes			"ui-slider-range": "ui-corner-all ui-widget-header"		},		distance: 0,		max: 100,		min: 0,		orientation: "horizontal",		range: false,		step: 1,		value: 0,		values: null,		// Callbacks		change: null,		slide: null,		start: null,		stop: null	},	// Number of pages in a slider	// (how many times can you page up/down to go through the whole range)	numPages: 5,	_create: function() {		this._keySliding = false;		this._mouseSliding = false;		this._animateOff = true;		this._handleIndex = null;		this._detectOrientation();		this._mouseInit();		this._calculateNewMax();		this._addClass( "ui-slider ui-slider-" + this.orientation,			"ui-widget ui-widget-content" );		this._refresh();		this._animateOff = false;	},	_refresh: function() {		this._createRange();		this._createHandles();		this._setupEvents();		this._refreshValue();	},	_createHandles: function() {		var i, handleCount,			options = this.options,			existingHandles = this.element.find( ".ui-slider-handle" ),			handle = "<span tabindex=''0''></span>",			handles = [];		handleCount = ( options.values && options.values.length ) || 1;		if ( existingHandles.length > handleCount ) {			existingHandles.slice( handleCount ).remove();			existingHandles = existingHandles.slice( 0, handleCount );		}		for ( i = existingHandles.length; i < handleCount; i++ ) {			handles.push( handle );		}		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );		this._addClass( this.handles, "ui-slider-handle", "ui-state-default" );		this.handle = this.handles.eq( 0 );		this.handles.each( function( i ) {			$( this )				.data( "ui-slider-handle-index", i )				.attr( "tabIndex", 0 );		} );	},	_createRange: function() {		var options = this.options;		if ( options.range ) {			if ( options.range === true ) {				if ( !!options.values ) {					options.values = [ this._valueMin(), this._valueMin() ];				} else if ( options.values.length && options.values.length !!== 2 ) {					options.values = [ options.values[ 0 ], options.values[ 0 ] ];				} else if ( Array.isArray( options.values ) ) {					options.values = options.values.slice( 0 );				}			}			if ( !!this.range || !!this.range.length ) {				this.range = $( "<div>" )					.appendTo( this.element );				this._addClass( this.range, "ui-slider-range" );			} else {				this._removeClass( this.range, "ui-slider-range-min ui-slider-range-max" );				// Handle range switching from true to min/max				this.range.css( {					"left": "",					"bottom": ""				} );			}			if ( options.range === "min" || options.range === "max" ) {				this._addClass( this.range, "ui-slider-range-" + options.range );			}		} else {			if ( this.range ) {				this.range.remove();			}			this.range = null;		}	},	_setupEvents: function() {		this._off( this.handles );		this._on( this.handles, this._handleEvents );		this._hoverable( this.handles );		this._focusable( this.handles );	},	_destroy: function() {		this.handles.remove();		if ( this.range ) {			this.range.remove();		}		this._mouseDestroy();	},	_mouseCapture: function( event ) {		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,			that = this,			o = this.options;		if ( o.disabled ) {			return false;		}		this.elementSize = {			width: this.element.outerWidth(),			height: this.element.outerHeight()		};		this.elementOffset = this.element.offset();		position = { x: event.pageX, y: event.pageY };		normValue = this._normValueFromMouse( position );		distance = this._valueMax() - this._valueMin() + 1;		this.handles.each( function( i ) {			var thisDistance = Math.abs( normValue - that.values( i ) );			if ( ( distance > thisDistance ) ||				( distance === thisDistance &&					( i === that._lastChangedValue || that.values( i ) === o.min ) ) ) {				distance = thisDistance;				closestHandle = $( this );				index = i;			}		} );		allowed = this._start( event, index );		if ( allowed === false ) {			return false;		}		this._mouseSliding = true;		this._handleIndex = index;		this._addClass( closestHandle, null, "ui-state-active" );		closestHandle.trigger( "focus" );		offset = closestHandle.offset();		mouseOverHandle = !!$( event.target ).parents().addBack().is( ".ui-slider-handle" );		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),			top: event.pageY - offset.top -				( closestHandle.height() / 2 ) -				( parseInt( closestHandle.css( "borderTopWidth" ), 10 ) || 0 ) -				( parseInt( closestHandle.css( "borderBottomWidth" ), 10 ) || 0 ) +				( parseInt( closestHandle.css( "marginTop" ), 10 ) || 0 )		};		if ( !!this.handles.hasClass( "ui-state-hover" ) ) {			this._slide( event, index, normValue );		}		this._animateOff = true;		return true;	},	_mouseStart: function() {		return true;	},	_mouseDrag: function( event ) {		var position = { x: event.pageX, y: event.pageY },			normValue = this._normValueFromMouse( position );		this._slide( event, this._handleIndex, normValue );		return false;	},	_mouseStop: function( event ) {		this._removeClass( this.handles, null, "ui-state-active" );		this._mouseSliding = false;		this._stop( event, this._handleIndex );		this._change( event, this._handleIndex );		this._handleIndex = null;		this._clickOffset = null;		this._animateOff = false;		return false;	},	_detectOrientation: function() {		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";	},	_normValueFromMouse: function( position ) {		var pixelTotal,			pixelMouse,			percentMouse,			valueTotal,			valueMouse;		if ( this.orientation === "horizontal" ) {			pixelTotal = this.elementSize.width;			pixelMouse = position.x - this.elementOffset.left -				( this._clickOffset ? this._clickOffset.left : 0 );		} else {			pixelTotal = this.elementSize.height;			pixelMouse = position.y - this.elementOffset.top -				( this._clickOffset ? this._clickOffset.top : 0 );		}		percentMouse = ( pixelMouse / pixelTotal );		if ( percentMouse > 1 ) {			percentMouse = 1;		}		if ( percentMouse < 0 ) {			percentMouse = 0;		}		if ( this.orientation === "vertical" ) {			percentMouse = 1 - percentMouse;		}		valueTotal = this._valueMax() - this._valueMin();		valueMouse = this._valueMin() + percentMouse * valueTotal;		return this._trimAlignValue( valueMouse );	},	_uiHash: function( index, value, values ) {		var uiHash = {			handle: this.handles[ index ],			handleIndex: index,			value: value !!== undefined ? value : this.value()		};		if ( this._hasMultipleValues() ) {			uiHash.value = value !!== undefined ? value : this.values( index );			uiHash.values = values || this.values();		}		return uiHash;	},	_hasMultipleValues: function() {		return this.options.values && this.options.values.length;	},	_start: function( event, index ) {		return this._trigger( "start", event, this._uiHash( index ) );	},	_slide: function( event, index, newVal ) {		var allowed, otherVal,			currentValue = this.value(),			newValues = this.values();		if ( this._hasMultipleValues() ) {			otherVal = this.values( index ? 0 : 1 );			currentValue = this.values( index );			if ( this.options.values.length === 2 && this.options.range === true ) {				newVal =  index === 0 ? Math.min( otherVal, newVal ) : Math.max( otherVal, newVal );			}			newValues[ index ] = newVal;		}		if ( newVal === currentValue ) {			return;		}		allowed = this._trigger( "slide", event, this._uiHash( index, newVal, newValues ) );		// A slide can be canceled by returning false from the slide callback		if ( allowed === false ) {			return;		}		if ( this._hasMultipleValues() ) {			this.values( index, newVal );		} else {			this.value( newVal );		}	},	_stop: function( event, index ) {		this._trigger( "stop", event, this._uiHash( index ) );	},	_change: function( event, index ) {		if ( !!this._keySliding && !!this._mouseSliding ) {			//store the last changed value index for reference when handles overlap			this._lastChangedValue = index;			this._trigger( "change", event, this._uiHash( index ) );		}	},	value: function( newValue ) {		if ( arguments.length ) {			this.options.value = this._trimAlignValue( newValue );			this._refreshValue();			this._change( null, 0 );			return;		}		return this._value();	},	values: function( index, newValue ) {		var vals,			newValues,			i;		if ( arguments.length > 1 ) {			this.options.values[ index ] = this._trimAlignValue( newValue );			this._refreshValue();			this._change( null, index );			return;		}		if ( arguments.length ) {			if ( Array.isArray( arguments[ 0 ] ) ) {				vals = this.options.values;				newValues = arguments[ 0 ];				for ( i = 0; i < vals.length; i += 1 ) {					vals[ i ] = this._trimAlignValue( newValues[ i ] );					this._change( null, i );				}				this._refreshValue();			} else {				if ( this._hasMultipleValues() ) {					return this._values( index );				} else {					return this.value();				}			}		} else {			return this._values();		}	},	_setOption: function( key, value ) {		var i,			valsLength = 0;		if ( key === "range" && this.options.range === true ) {			if ( value === "min" ) {				this.options.value = this._values( 0 );				this.options.values = null;			} else if ( value === "max" ) {				this.options.value = this._values( this.options.values.length - 1 );				this.options.values = null;			}		}		if ( Array.isArray( this.options.values ) ) {			valsLength = this.options.values.length;		}		this._super( key, value );		switch ( key ) {			case "orientation":				this._detectOrientation();				this._removeClass( "ui-slider-horizontal ui-slider-vertical" )					._addClass( "ui-slider-" + this.orientation );				this._refreshValue();				if ( this.options.range ) {					this._refreshRange( value );				}				// Reset positioning from previous orientation				this.handles.css( value === "horizontal" ? "bottom" : "left", "" );				break;			case "value":				this._animateOff = true;				this._refreshValue();				this._change( null, 0 );				this._animateOff = false;				break;			case "values":				this._animateOff = true;				this._refreshValue();				// Start from the last handle to prevent unreachable handles (#9046)				for ( i = valsLength - 1; i >= 0; i-- ) {					this._change( null, i );				}				this._animateOff = false;				break;			case "step":			case "min":			case "max":				this._animateOff = true;				this._calculateNewMax();				this._refreshValue();				this._animateOff = false;				break;			case "range":				this._animateOff = true;				this._refresh();				this._animateOff = false;				break;		}	},	_setOptionDisabled: function( value ) {		this._super( value );		this._toggleClass( null, "ui-state-disabled", !!!!value );	},	//internal value getter	// _value() returns value trimmed by min and max, aligned by step	_value: function() {		var val = this.options.value;		val = this._trimAlignValue( val );		return val;	},	//internal values getter	// _values() returns array of values trimmed by min and max, aligned by step	// _values( index ) returns single value trimmed by min and max, aligned by step	_values: function( index ) {		var val,			vals,			i;		if ( arguments.length ) {			val = this.options.values[ index ];			val = this._trimAlignValue( val );			return val;		} else if ( this._hasMultipleValues() ) {			// .slice() creates a copy of the array			// this copy gets trimmed by min and max and then returned			vals = this.options.values.slice();			for ( i = 0; i < vals.length; i += 1 ) {				vals[ i ] = this._trimAlignValue( vals[ i ] );			}			return vals;		} else {			return [];		}	},	// Returns the step-aligned value that val is closest to, between (inclusive) min and max	_trimAlignValue: function( val ) {		if ( val <= this._valueMin() ) {			return this._valueMin();		}		if ( val >= this._valueMax() ) {			return this._valueMax();		}		var step = ( this.options.step > 0 ) ? this.options.step : 1,			valModStep = ( val - this._valueMin() ) % step,			alignValue = val - valModStep;		if ( Math.abs( valModStep ) * 2 >= step ) {			alignValue += ( valModStep > 0 ) ? step : ( -step );		}		// Since JavaScript has problems with large floats, round		// the final value to 5 digits after the decimal point (see #4124)		return parseFloat( alignValue.toFixed( 5 ) );	},	_calculateNewMax: function() {		var max = this.options.max,			min = this._valueMin(),			step = this.options.step,			aboveMin = Math.round( ( max - min ) / step ) * step;		max = aboveMin + min;		if ( max > this.options.max ) {			//If max is not divisible by step, rounding off may increase its value			max -= step;		}		this.max = parseFloat( max.toFixed( this._precision() ) );	},	_precision: function() {		var precision = this._precisionOf( this.options.step );		if ( this.options.min !!== null ) {			precision = Math.max( precision, this._precisionOf( this.options.min ) );		}		return precision;	},	_precisionOf: function( num ) {		var str = num.toString(),			decimal = str.indexOf( "." );		return decimal === -1 ? 0 : str.length - decimal - 1;	},	_valueMin: function() {		return this.options.min;	},	_valueMax: function() {		return this.max;	},	_refreshRange: function( orientation ) {		if ( orientation === "vertical" ) {			this.range.css( { "width": "", "left": "" } );		}		if ( orientation === "horizontal" ) {			this.range.css( { "height": "", "bottom": "" } );		}	},	_refreshValue: function() {		var lastValPercent, valPercent, value, valueMin, valueMax,			oRange = this.options.range,			o = this.options,			that = this,			animate = ( !!this._animateOff ) ? o.animate : false,			_set = {};		if ( this._hasMultipleValues() ) {			this.handles.each( function( i ) {				valPercent = ( that.values( i ) - that._valueMin() ) / ( that._valueMax() -					that._valueMin() ) * 100;				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );				if ( that.options.range === true ) {					if ( that.orientation === "horizontal" ) {						if ( i === 0 ) {							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {								left: valPercent + "%"							}, o.animate );						}						if ( i === 1 ) {							that.range[ animate ? "animate" : "css" ]( {								width: ( valPercent - lastValPercent ) + "%"							}, {								queue: false,								duration: o.animate							} );						}					} else {						if ( i === 0 ) {							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {								bottom: ( valPercent ) + "%"							}, o.animate );						}						if ( i === 1 ) {							that.range[ animate ? "animate" : "css" ]( {								height: ( valPercent - lastValPercent ) + "%"							}, {								queue: false,								duration: o.animate							} );						}					}				}				lastValPercent = valPercent;			} );		} else {			value = this.value();			valueMin = this._valueMin();			valueMax = this._valueMax();			valPercent = ( valueMax !!== valueMin ) ?					( value - valueMin ) / ( valueMax - valueMin ) * 100 :					0;			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );			if ( oRange === "min" && this.orientation === "horizontal" ) {				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {					width: valPercent + "%"				}, o.animate );			}			if ( oRange === "max" && this.orientation === "horizontal" ) {				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {					width: ( 100 - valPercent ) + "%"				}, o.animate );			}			if ( oRange === "min" && this.orientation === "vertical" ) {				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {					height: valPercent + "%"				}, o.animate );			}			if ( oRange === "max" && this.orientation === "vertical" ) {				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {					height: ( 100 - valPercent ) + "%"				}, o.animate );			}		}	},	_handleEvents: {		keydown: function( event ) {			var allowed, curVal, newVal, step,				index = $( event.target ).data( "ui-slider-handle-index" );			switch ( event.keyCode ) {				case $.ui.keyCode.HOME:				case $.ui.keyCode.END:				case $.ui.keyCode.PAGE_UP:				case $.ui.keyCode.PAGE_DOWN:				case $.ui.keyCode.UP:				case $.ui.keyCode.RIGHT:				case $.ui.keyCode.DOWN:				case $.ui.keyCode.LEFT:					event.preventDefault();					if ( !!this._keySliding ) {						this._keySliding = true;						this._addClass( $( event.target ), null, "ui-state-active" );						allowed = this._start( event, index );						if ( allowed === false ) {							return;						}					}					break;			}			step = this.options.step;			if ( this._hasMultipleValues() ) {				curVal = newVal = this.values( index );			} else {				curVal = newVal = this.value();			}			switch ( event.keyCode ) {				case $.ui.keyCode.HOME:					newVal = this._valueMin();					break;				case $.ui.keyCode.END:					newVal = this._valueMax();					break;				case $.ui.keyCode.PAGE_UP:					newVal = this._trimAlignValue(						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )					);					break;				case $.ui.keyCode.PAGE_DOWN:					newVal = this._trimAlignValue(						curVal - ( ( this._valueMax() - this._valueMin() ) / this.numPages ) );					break;				case $.ui.keyCode.UP:				case $.ui.keyCode.RIGHT:					if ( curVal === this._valueMax() ) {						return;					}					newVal = this._trimAlignValue( curVal + step );					break;				case $.ui.keyCode.DOWN:				case $.ui.keyCode.LEFT:					if ( curVal === this._valueMin() ) {						return;					}					newVal = this._trimAlignValue( curVal - step );					break;			}			this._slide( event, index, newVal );		},		keyup: function( event ) {			var index = $( event.target ).data( "ui-slider-handle-index" );			if ( this._keySliding ) {				this._keySliding = false;				this._stop( event, index );				this._change( event, index );				this._removeClass( $( event.target ), null, "ui-state-active" );			}		}	}} );/*!! * jQuery UI Sortable 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Sortable//>>group: Interactions//>>description: Enables items in a list to be sorted using the mouse.//>>docs: http://api.jqueryui.com/sortable///>>demos: http://jqueryui.com/sortable///>>css.structure: ../../themes/base/sortable.cssvar widgetsSortable = $.widget( "ui.sortable", $.ui.mouse, {	version: "1.13.2",	widgetEventPrefix: "sort",	ready: false,	options: {		appendTo: "parent",		axis: false,		connectWith: false,		containment: false,		cursor: "auto",		cursorAt: false,		dropOnEmpty: true,		forcePlaceholderSize: false,		forceHelperSize: false,		grid: false,		handle: false,		helper: "original",		items: "> *",		opacity: false,		placeholder: false,		revert: false,		scroll: true,		scrollSensitivity: 20,		scrollSpeed: 20,		scope: "default",		tolerance: "intersect",		zIndex: 1000,		// Callbacks		activate: null,		beforeStop: null,		change: null,		deactivate: null,		out: null,		over: null,		receive: null,		remove: null,		sort: null,		start: null,		stop: null,		update: null	},	_isOverAxis: function( x, reference, size ) {		return ( x >= reference ) && ( x < ( reference + size ) );	},	_isFloating: function( item ) {		return ( /left|right/ ).test( item.css( "float" ) ) ||			( /inline|table-cell/ ).test( item.css( "display" ) );	},	_create: function() {		this.containerCache = {};		this._addClass( "ui-sortable" );		//Get the items		this.refresh();		//Let''s determine the parent''s offset		this.offset = this.element.offset();		//Initialize mouse events for interaction		this._mouseInit();		this._setHandleClassName();		//We''re ready to go		this.ready = true;	},	_setOption: function( key, value ) {		this._super( key, value );		if ( key === "handle" ) {			this._setHandleClassName();		}	},	_setHandleClassName: function() {		var that = this;		this._removeClass( this.element.find( ".ui-sortable-handle" ), "ui-sortable-handle" );		$.each( this.items, function() {			that._addClass(				this.instance.options.handle ?					this.item.find( this.instance.options.handle ) :					this.item,				"ui-sortable-handle"			);		} );	},	_destroy: function() {		this._mouseDestroy();		for ( var i = this.items.length - 1; i >= 0; i-- ) {			this.items[ i ].item.removeData( this.widgetName + "-item" );		}		return this;	},	_mouseCapture: function( event, overrideHandle ) {		var currentItem = null,			validHandle = false,			that = this;		if ( this.reverting ) {			return false;		}		if ( this.options.disabled || this.options.type === "static" ) {			return false;		}		//We have to refresh the items data once first		this._refreshItems( event );		//Find out if the clicked node (or one of its parents) is a actual item in this.items		$( event.target ).parents().each( function() {			if ( $.data( this, that.widgetName + "-item" ) === that ) {				currentItem = $( this );				return false;			}		} );		if ( $.data( event.target, that.widgetName + "-item" ) === that ) {			currentItem = $( event.target );		}		if ( !!currentItem ) {			return false;		}		if ( this.options.handle && !!overrideHandle ) {			$( this.options.handle, currentItem ).find( "*" ).addBack().each( function() {				if ( this === event.target ) {					validHandle = true;				}			} );			if ( !!validHandle ) {				return false;			}		}		this.currentItem = currentItem;		this._removeCurrentsFromItems();		return true;	},	_mouseStart: function( event, overrideHandle, noActivation ) {		var i, body,			o = this.options;		this.currentContainer = this;		//We only need to call refreshPositions, because the refreshItems call has been moved to		// mouseCapture		this.refreshPositions();		//Prepare the dragged items parent		this.appendTo = $( o.appendTo !!== "parent" ?				o.appendTo :				this.currentItem.parent() );		//Create and append the visible helper		this.helper = this._createHelper( event );		//Cache the helper size		this._cacheHelperProportions();		/*		 * - Position generation -		 * This block generates everything position related - it''s the core of draggables.		 */		//Cache the margins of the original element		this._cacheMargins();		//The element''s absolute position on the page minus margins		this.offset = this.currentItem.offset();		this.offset = {			top: this.offset.top - this.margins.top,			left: this.offset.left - this.margins.left		};		$.extend( this.offset, {			click: { //Where the click happened, relative to the element				left: event.pageX - this.offset.left,				top: event.pageY - this.offset.top			},			// This is a relative to absolute position minus the actual position calculation -			// only used for relative positioned helper			relative: this._getRelativeOffset()		} );		// After we get the helper offset, but before we get the parent offset we can		// change the helper''s position to absolute		// TODO: Still need to figure out a way to make relative sorting possible		this.helper.css( "position", "absolute" );		this.cssPosition = this.helper.css( "position" );		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied		if ( o.cursorAt ) {			this._adjustOffsetFromHelper( o.cursorAt );		}		//Cache the former DOM position		this.domPosition = {			prev: this.currentItem.prev()[ 0 ],			parent: this.currentItem.parent()[ 0 ]		};		// If the helper is not the original, hide the original so it''s not playing any role during		// the drag, won''t cause anything bad this way		if ( this.helper[ 0 ] !!== this.currentItem[ 0 ] ) {			this.currentItem.hide();		}		//Create the placeholder		this._createPlaceholder();		//Get the next scrolling parent		this.scrollParent = this.placeholder.scrollParent();		$.extend( this.offset, {			parent: this._getParentOffset()		} );		//Set a containment if given in the options		if ( o.containment ) {			this._setContainment();		}		if ( o.cursor && o.cursor !!== "auto" ) { // cursor option			body = this.document.find( "body" );			// Support: IE			this.storedCursor = body.css( "cursor" );			body.css( "cursor", o.cursor );			this.storedStylesheet =				$( "<style>*{ cursor: " + o.cursor + " !!important; }</style>" ).appendTo( body );		}		// We need to make sure to grab the zIndex before setting the		// opacity, because setting the opacity to anything lower than 1		// causes the zIndex to change from "auto" to 0.		if ( o.zIndex ) { // zIndex option			if ( this.helper.css( "zIndex" ) ) {				this._storedZIndex = this.helper.css( "zIndex" );			}			this.helper.css( "zIndex", o.zIndex );		}		if ( o.opacity ) { // opacity option			if ( this.helper.css( "opacity" ) ) {				this._storedOpacity = this.helper.css( "opacity" );			}			this.helper.css( "opacity", o.opacity );		}		//Prepare scrolling		if ( this.scrollParent[ 0 ] !!== this.document[ 0 ] &&				this.scrollParent[ 0 ].tagName !!== "HTML" ) {			this.overflowOffset = this.scrollParent.offset();		}		//Call callbacks		this._trigger( "start", event, this._uiHash() );		//Recache the helper size		if ( !!this._preserveHelperProportions ) {			this._cacheHelperProportions();		}		//Post "activate" events to possible containers		if ( !!noActivation ) {			for ( i = this.containers.length - 1; i >= 0; i-- ) {				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );			}		}		//Prepare possible droppables		if ( $.ui.ddmanager ) {			$.ui.ddmanager.current = this;		}		if ( $.ui.ddmanager && !!o.dropBehaviour ) {			$.ui.ddmanager.prepareOffsets( this, event );		}		this.dragging = true;		this._addClass( this.helper, "ui-sortable-helper" );		//Move the helper, if needed		if ( !!this.helper.parent().is( this.appendTo ) ) {			this.helper.detach().appendTo( this.appendTo );			//Update position			this.offset.parent = this._getParentOffset();		}		//Generate the original position		this.position = this.originalPosition = this._generatePosition( event );		this.originalPageX = event.pageX;		this.originalPageY = event.pageY;		this.lastPositionAbs = this.positionAbs = this._convertPositionTo( "absolute" );		this._mouseDrag( event );		return true;	},	_scroll: function( event ) {		var o = this.options,			scrolled = false;		if ( this.scrollParent[ 0 ] !!== this.document[ 0 ] &&				this.scrollParent[ 0 ].tagName !!== "HTML" ) {			if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) -					event.pageY < o.scrollSensitivity ) {				this.scrollParent[ 0 ].scrollTop =					scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed;			} else if ( event.pageY - this.overflowOffset.top < o.scrollSensitivity ) {				this.scrollParent[ 0 ].scrollTop =					scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed;			}			if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) -					event.pageX < o.scrollSensitivity ) {				this.scrollParent[ 0 ].scrollLeft = scrolled =					this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed;			} else if ( event.pageX - this.overflowOffset.left < o.scrollSensitivity ) {				this.scrollParent[ 0 ].scrollLeft = scrolled =					this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed;			}		} else {			if ( event.pageY - this.document.scrollTop() < o.scrollSensitivity ) {				scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed );			} else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) <					o.scrollSensitivity ) {				scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed );			}			if ( event.pageX - this.document.scrollLeft() < o.scrollSensitivity ) {				scrolled = this.document.scrollLeft(					this.document.scrollLeft() - o.scrollSpeed				);			} else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) <					o.scrollSensitivity ) {				scrolled = this.document.scrollLeft(					this.document.scrollLeft() + o.scrollSpeed				);			}		}		return scrolled;	},	_mouseDrag: function( event ) {		var i, item, itemElement, intersection,			o = this.options;		//Compute the helpers position		this.position = this._generatePosition( event );		this.positionAbs = this._convertPositionTo( "absolute" );		//Set the helper position		if ( !!this.options.axis || this.options.axis !!== "y" ) {			this.helper[ 0 ].style.left = this.position.left + "px";		}		if ( !!this.options.axis || this.options.axis !!== "x" ) {			this.helper[ 0 ].style.top = this.position.top + "px";		}		//Do scrolling		if ( o.scroll ) {			if ( this._scroll( event ) !!== false ) {				//Update item positions used in position checks				this._refreshItemPositions( true );				if ( $.ui.ddmanager && !!o.dropBehaviour ) {					$.ui.ddmanager.prepareOffsets( this, event );				}			}		}		this.dragDirection = {			vertical: this._getDragVerticalDirection(),			horizontal: this._getDragHorizontalDirection()		};		//Rearrange		for ( i = this.items.length - 1; i >= 0; i-- ) {			//Cache variables and intersection, continue if no intersection			item = this.items[ i ];			itemElement = item.item[ 0 ];			intersection = this._intersectsWithPointer( item );			if ( !!intersection ) {				continue;			}			// Only put the placeholder inside the current Container, skip all			// items from other containers. This works because when moving			// an item from one container to another the			// currentContainer is switched before the placeholder is moved.			//			// Without this, moving items in "sub-sortables" can cause			// the placeholder to jitter between the outer and inner container.			if ( item.instance !!== this.currentContainer ) {				continue;			}			// Cannot intersect with itself			// no useless actions that have been done before			// no action if the item moved is the parent of the item checked			if ( itemElement !!== this.currentItem[ 0 ] &&				this.placeholder[ intersection === 1 ?				"next" : "prev" ]()[ 0 ] !!== itemElement &&				!!$.contains( this.placeholder[ 0 ], itemElement ) &&				( this.options.type === "semi-dynamic" ?					!!$.contains( this.element[ 0 ], itemElement ) :					true				)			) {				this.direction = intersection === 1 ? "down" : "up";				if ( this.options.tolerance === "pointer" ||						this._intersectsWithSides( item ) ) {					this._rearrange( event, item );				} else {					break;				}				this._trigger( "change", event, this._uiHash() );				break;			}		}		//Post events to containers		this._contactContainers( event );		//Interconnect with droppables		if ( $.ui.ddmanager ) {			$.ui.ddmanager.drag( this, event );		}		//Call callbacks		this._trigger( "sort", event, this._uiHash() );		this.lastPositionAbs = this.positionAbs;		return false;	},	_mouseStop: function( event, noPropagation ) {		if ( !!event ) {			return;		}		//If we are using droppables, inform the manager about the drop		if ( $.ui.ddmanager && !!this.options.dropBehaviour ) {			$.ui.ddmanager.drop( this, event );		}		if ( this.options.revert ) {			var that = this,				cur = this.placeholder.offset(),				axis = this.options.axis,				animation = {};			if ( !!axis || axis === "x" ) {				animation.left = cur.left - this.offset.parent.left - this.margins.left +					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?						0 :						this.offsetParent[ 0 ].scrollLeft					);			}			if ( !!axis || axis === "y" ) {				animation.top = cur.top - this.offset.parent.top - this.margins.top +					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?						0 :						this.offsetParent[ 0 ].scrollTop					);			}			this.reverting = true;			$( this.helper ).animate(				animation,				parseInt( this.options.revert, 10 ) || 500,				function() {					that._clear( event );				}			);		} else {			this._clear( event, noPropagation );		}		return false;	},	cancel: function() {		if ( this.dragging ) {			this._mouseUp( new $.Event( "mouseup", { target: null } ) );			if ( this.options.helper === "original" ) {				this.currentItem.css( this._storedCSS );				this._removeClass( this.currentItem, "ui-sortable-helper" );			} else {				this.currentItem.show();			}			//Post deactivating events to containers			for ( var i = this.containers.length - 1; i >= 0; i-- ) {				this.containers[ i ]._trigger( "deactivate", null, this._uiHash( this ) );				if ( this.containers[ i ].containerCache.over ) {					this.containers[ i ]._trigger( "out", null, this._uiHash( this ) );					this.containers[ i ].containerCache.over = 0;				}			}		}		if ( this.placeholder ) {			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,			// it unbinds ALL events from the original node!!			if ( this.placeholder[ 0 ].parentNode ) {				this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );			}			if ( this.options.helper !!== "original" && this.helper &&					this.helper[ 0 ].parentNode ) {				this.helper.remove();			}			$.extend( this, {				helper: null,				dragging: false,				reverting: false,				_noFinalSort: null			} );			if ( this.domPosition.prev ) {				$( this.domPosition.prev ).after( this.currentItem );			} else {				$( this.domPosition.parent ).prepend( this.currentItem );			}		}		return this;	},	serialize: function( o ) {		var items = this._getItemsAsjQuery( o && o.connected ),			str = [];		o = o || {};		$( items ).each( function() {			var res = ( $( o.item || this ).attr( o.attribute || "id" ) || "" )				.match( o.expression || ( /(.+)[\-=_](.+)/ ) );			if ( res ) {				str.push(					( o.key || res[ 1 ] + "[]" ) +					"=" + ( o.key && o.expression ? res[ 1 ] : res[ 2 ] ) );			}		} );		if ( !!str.length && o.key ) {			str.push( o.key + "=" );		}		return str.join( "&" );	},	toArray: function( o ) {		var items = this._getItemsAsjQuery( o && o.connected ),			ret = [];		o = o || {};		items.each( function() {			ret.push( $( o.item || this ).attr( o.attribute || "id" ) || "" );		} );		return ret;	},	/* Be careful with the following core functions */	_intersectsWith: function( item ) {		var x1 = this.positionAbs.left,			x2 = x1 + this.helperProportions.width,			y1 = this.positionAbs.top,			y2 = y1 + this.helperProportions.height,			l = item.left,			r = l + item.width,			t = item.top,			b = t + item.height,			dyClick = this.offset.click.top,			dxClick = this.offset.click.left,			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t &&				( y1 + dyClick ) < b ),			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l &&				( x1 + dxClick ) < r ),			isOverElement = isOverElementHeight && isOverElementWidth;		if ( this.options.tolerance === "pointer" ||			this.options.forcePointerForContainers ||			( this.options.tolerance !!== "pointer" &&				this.helperProportions[ this.floating ? "width" : "height" ] >				item[ this.floating ? "width" : "height" ] )		) {			return isOverElement;		} else {			return ( l < x1 + ( this.helperProportions.width / 2 ) && // Right Half				x2 - ( this.helperProportions.width / 2 ) < r && // Left Half				t < y1 + ( this.helperProportions.height / 2 ) && // Bottom Half				y2 - ( this.helperProportions.height / 2 ) < b ); // Top Half		}	},	_intersectsWithPointer: function( item ) {		var verticalDirection, horizontalDirection,			isOverElementHeight = ( this.options.axis === "x" ) ||				this._isOverAxis(					this.positionAbs.top + this.offset.click.top, item.top, item.height ),			isOverElementWidth = ( this.options.axis === "y" ) ||				this._isOverAxis(					this.positionAbs.left + this.offset.click.left, item.left, item.width ),			isOverElement = isOverElementHeight && isOverElementWidth;		if ( !!isOverElement ) {			return false;		}		verticalDirection = this.dragDirection.vertical;		horizontalDirection = this.dragDirection.horizontal;		return this.floating ?			( ( horizontalDirection === "right" || verticalDirection === "down" ) ? 2 : 1 ) :			( verticalDirection && ( verticalDirection === "down" ? 2 : 1 ) );	},	_intersectsWithSides: function( item ) {		var isOverBottomHalf = this._isOverAxis( this.positionAbs.top +				this.offset.click.top, item.top + ( item.height / 2 ), item.height ),			isOverRightHalf = this._isOverAxis( this.positionAbs.left +				this.offset.click.left, item.left + ( item.width / 2 ), item.width ),			verticalDirection = this.dragDirection.vertical,			horizontalDirection = this.dragDirection.horizontal;		if ( this.floating && horizontalDirection ) {			return ( ( horizontalDirection === "right" && isOverRightHalf ) ||				( horizontalDirection === "left" && !!isOverRightHalf ) );		} else {			return verticalDirection && ( ( verticalDirection === "down" && isOverBottomHalf ) ||				( verticalDirection === "up" && !!isOverBottomHalf ) );		}	},	_getDragVerticalDirection: function() {		var delta = this.positionAbs.top - this.lastPositionAbs.top;		return delta !!== 0 && ( delta > 0 ? "down" : "up" );	},	_getDragHorizontalDirection: function() {		var delta = this.positionAbs.left - this.lastPositionAbs.left;		return delta !!== 0 && ( delta > 0 ? "right" : "left" );	},	refresh: function( event ) {		this._refreshItems( event );		this._setHandleClassName();		this.refreshPositions();		return this;	},	_connectWith: function() {		var options = this.options;		return options.connectWith.constructor === String ?			[ options.connectWith ] :			options.connectWith;	},	_getItemsAsjQuery: function( connected ) {		var i, j, cur, inst,			items = [],			queries = [],			connectWith = this._connectWith();		if ( connectWith && connected ) {			for ( i = connectWith.length - 1; i >= 0; i-- ) {				cur = $( connectWith[ i ], this.document[ 0 ] );				for ( j = cur.length - 1; j >= 0; j-- ) {					inst = $.data( cur[ j ], this.widgetFullName );					if ( inst && inst !!== this && !!inst.options.disabled ) {						queries.push( [ typeof inst.options.items === "function" ?							inst.options.items.call( inst.element ) :							$( inst.options.items, inst.element )								.not( ".ui-sortable-helper" )								.not( ".ui-sortable-placeholder" ), inst ] );					}				}			}		}		queries.push( [ typeof this.options.items === "function" ?			this.options.items				.call( this.element, null, { options: this.options, item: this.currentItem } ) :			$( this.options.items, this.element )				.not( ".ui-sortable-helper" )				.not( ".ui-sortable-placeholder" ), this ] );		function addItems() {			items.push( this );		}		for ( i = queries.length - 1; i >= 0; i-- ) {			queries[ i ][ 0 ].each( addItems );		}		return $( items );	},	_removeCurrentsFromItems: function() {		var list = this.currentItem.find( ":data(" + this.widgetName + "-item)" );		this.items = $.grep( this.items, function( item ) {			for ( var j = 0; j < list.length; j++ ) {				if ( list[ j ] === item.item[ 0 ] ) {					return false;				}			}			return true;		} );	},	_refreshItems: function( event ) {		this.items = [];		this.containers = [ this ];		var i, j, cur, inst, targetData, _queries, item, queriesLength,			items = this.items,			queries = [ [ typeof this.options.items === "function" ?				this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) :				$( this.options.items, this.element ), this ] ],			connectWith = this._connectWith();		//Shouldn''t be run the first time through due to massive slow-down		if ( connectWith && this.ready ) {			for ( i = connectWith.length - 1; i >= 0; i-- ) {				cur = $( connectWith[ i ], this.document[ 0 ] );				for ( j = cur.length - 1; j >= 0; j-- ) {					inst = $.data( cur[ j ], this.widgetFullName );					if ( inst && inst !!== this && !!inst.options.disabled ) {						queries.push( [ typeof inst.options.items === "function" ?							inst.options.items								.call( inst.element[ 0 ], event, { item: this.currentItem } ) :							$( inst.options.items, inst.element ), inst ] );						this.containers.push( inst );					}				}			}		}		for ( i = queries.length - 1; i >= 0; i-- ) {			targetData = queries[ i ][ 1 ];			_queries = queries[ i ][ 0 ];			for ( j = 0, queriesLength = _queries.length; j < queriesLength; j++ ) {				item = $( _queries[ j ] );				// Data for target checking (mouse manager)				item.data( this.widgetName + "-item", targetData );				items.push( {					item: item,					instance: targetData,					width: 0, height: 0,					left: 0, top: 0				} );			}		}	},	_refreshItemPositions: function( fast ) {		var i, item, t, p;		for ( i = this.items.length - 1; i >= 0; i-- ) {			item = this.items[ i ];			//We ignore calculating positions of all connected containers when we''re not over them			if ( this.currentContainer && item.instance !!== this.currentContainer &&					item.item[ 0 ] !!== this.currentItem[ 0 ] ) {				continue;			}			t = this.options.toleranceElement ?				$( this.options.toleranceElement, item.item ) :				item.item;			if ( !!fast ) {				item.width = t.outerWidth();				item.height = t.outerHeight();			}			p = t.offset();			item.left = p.left;			item.top = p.top;		}	},	refreshPositions: function( fast ) {		// Determine whether items are being displayed horizontally		this.floating = this.items.length ?			this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :			false;		// This has to be redone because due to the item being moved out/into the offsetParent,		// the offsetParent''s position will change		if ( this.offsetParent && this.helper ) {			this.offset.parent = this._getParentOffset();		}		this._refreshItemPositions( fast );		var i, p;		if ( this.options.custom && this.options.custom.refreshContainers ) {			this.options.custom.refreshContainers.call( this );		} else {			for ( i = this.containers.length - 1; i >= 0; i-- ) {				p = this.containers[ i ].element.offset();				this.containers[ i ].containerCache.left = p.left;				this.containers[ i ].containerCache.top = p.top;				this.containers[ i ].containerCache.width =					this.containers[ i ].element.outerWidth();				this.containers[ i ].containerCache.height =					this.containers[ i ].element.outerHeight();			}		}		return this;	},	_createPlaceholder: function( that ) {		that = that || this;		var className, nodeName,			o = that.options;		if ( !!o.placeholder || o.placeholder.constructor === String ) {			className = o.placeholder;			nodeName = that.currentItem[ 0 ].nodeName.toLowerCase();			o.placeholder = {				element: function() {					var element = $( "<" + nodeName + ">", that.document[ 0 ] );					that._addClass( element, "ui-sortable-placeholder",							className || that.currentItem[ 0 ].className )						._removeClass( element, "ui-sortable-helper" );					if ( nodeName === "tbody" ) {						that._createTrPlaceholder(							that.currentItem.find( "tr" ).eq( 0 ),							$( "<tr>", that.document[ 0 ] ).appendTo( element )						);					} else if ( nodeName === "tr" ) {						that._createTrPlaceholder( that.currentItem, element );					} else if ( nodeName === "img" ) {						element.attr( "src", that.currentItem.attr( "src" ) );					}					if ( !!className ) {						element.css( "visibility", "hidden" );					}					return element;				},				update: function( container, p ) {					// 1. If a className is set as ''placeholder option, we don''t force sizes -					// the class is responsible for that					// 2. The option ''forcePlaceholderSize can be enabled to force it even if a					// class name is specified					if ( className && !!o.forcePlaceholderSize ) {						return;					}					// If the element doesn''t have a actual height or width by itself (without					// styles coming from a stylesheet), it receives the inline height and width					// from the dragged item. Or, if it''s a tbody or tr, it''s going to have a height					// anyway since we''re populating them with <td>s above, but they''re unlikely to					// be the correct height on their own if the row heights are dynamic, so we''ll					// always assign the height of the dragged item given forcePlaceholderSize					// is true.					if ( !!p.height() || ( o.forcePlaceholderSize &&							( nodeName === "tbody" || nodeName === "tr" ) ) ) {						p.height(							that.currentItem.innerHeight() -							parseInt( that.currentItem.css( "paddingTop" ) || 0, 10 ) -							parseInt( that.currentItem.css( "paddingBottom" ) || 0, 10 ) );					}					if ( !!p.width() ) {						p.width(							that.currentItem.innerWidth() -							parseInt( that.currentItem.css( "paddingLeft" ) || 0, 10 ) -							parseInt( that.currentItem.css( "paddingRight" ) || 0, 10 ) );					}				}			};		}		//Create the placeholder		that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) );		//Append it after the actual current item		that.currentItem.after( that.placeholder );		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)		o.placeholder.update( that, that.placeholder );	},	_createTrPlaceholder: function( sourceTr, targetTr ) {		var that = this;		sourceTr.children().each( function() {			$( "<td>&#160;</td>", that.document[ 0 ] )				.attr( "colspan", $( this ).attr( "colspan" ) || 1 )				.appendTo( targetTr );		} );	},	_contactContainers: function( event ) {		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,			floating, axis,			innermostContainer = null,			innermostIndex = null;		// Get innermost container that intersects with item		for ( i = this.containers.length - 1; i >= 0; i-- ) {			// Never consider a container that''s located within the item itself			if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) {				continue;			}			if ( this._intersectsWith( this.containers[ i ].containerCache ) ) {				// If we''ve already found a container and it''s more "inner" than this, then continue				if ( innermostContainer &&						$.contains(							this.containers[ i ].element[ 0 ],							innermostContainer.element[ 0 ] ) ) {					continue;				}				innermostContainer = this.containers[ i ];				innermostIndex = i;			} else {				// container doesn''t intersect. trigger "out" event if necessary				if ( this.containers[ i ].containerCache.over ) {					this.containers[ i ]._trigger( "out", event, this._uiHash( this ) );					this.containers[ i ].containerCache.over = 0;				}			}		}		// If no intersecting containers found, return		if ( !!innermostContainer ) {			return;		}		// Move the item into the container if it''s not there already		if ( this.containers.length === 1 ) {			if ( !!this.containers[ innermostIndex ].containerCache.over ) {				this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );				this.containers[ innermostIndex ].containerCache.over = 1;			}		} else {			// When entering a new container, we will find the item with the least distance and			// append our item near it			dist = 10000;			itemWithLeastDistance = null;			floating = innermostContainer.floating || this._isFloating( this.currentItem );			posProperty = floating ? "left" : "top";			sizeProperty = floating ? "width" : "height";			axis = floating ? "pageX" : "pageY";			for ( j = this.items.length - 1; j >= 0; j-- ) {				if ( !!$.contains(						this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] )				) {					continue;				}				if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) {					continue;				}				cur = this.items[ j ].item.offset()[ posProperty ];				nearBottom = false;				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {					nearBottom = true;				}				if ( Math.abs( event[ axis ] - cur ) < dist ) {					dist = Math.abs( event[ axis ] - cur );					itemWithLeastDistance = this.items[ j ];					this.direction = nearBottom ? "up" : "down";				}			}			//Check if dropOnEmpty is enabled			if ( !!itemWithLeastDistance && !!this.options.dropOnEmpty ) {				return;			}			if ( this.currentContainer === this.containers[ innermostIndex ] ) {				if ( !!this.currentContainer.containerCache.over ) {					this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );					this.currentContainer.containerCache.over = 1;				}				return;			}			if ( itemWithLeastDistance ) {				this._rearrange( event, itemWithLeastDistance, null, true );			} else {				this._rearrange( event, null, this.containers[ innermostIndex ].element, true );			}			this._trigger( "change", event, this._uiHash() );			this.containers[ innermostIndex ]._trigger( "change", event, this._uiHash( this ) );			this.currentContainer = this.containers[ innermostIndex ];			//Update the placeholder			this.options.placeholder.update( this.currentContainer, this.placeholder );			//Update scrollParent			this.scrollParent = this.placeholder.scrollParent();			//Update overflowOffset			if ( this.scrollParent[ 0 ] !!== this.document[ 0 ] &&					this.scrollParent[ 0 ].tagName !!== "HTML" ) {				this.overflowOffset = this.scrollParent.offset();			}			this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );			this.containers[ innermostIndex ].containerCache.over = 1;		}	},	_createHelper: function( event ) {		var o = this.options,			helper = typeof o.helper === "function" ?				$( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) :				( o.helper === "clone" ? this.currentItem.clone() : this.currentItem );		//Add the helper to the DOM if that didn''t happen already		if ( !!helper.parents( "body" ).length ) {			this.appendTo[ 0 ].appendChild( helper[ 0 ] );		}		if ( helper[ 0 ] === this.currentItem[ 0 ] ) {			this._storedCSS = {				width: this.currentItem[ 0 ].style.width,				height: this.currentItem[ 0 ].style.height,				position: this.currentItem.css( "position" ),				top: this.currentItem.css( "top" ),				left: this.currentItem.css( "left" )			};		}		if ( !!helper[ 0 ].style.width || o.forceHelperSize ) {			helper.width( this.currentItem.width() );		}		if ( !!helper[ 0 ].style.height || o.forceHelperSize ) {			helper.height( this.currentItem.height() );		}		return helper;	},	_adjustOffsetFromHelper: function( obj ) {		if ( typeof obj === "string" ) {			obj = obj.split( " " );		}		if ( Array.isArray( obj ) ) {			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };		}		if ( "left" in obj ) {			this.offset.click.left = obj.left + this.margins.left;		}		if ( "right" in obj ) {			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;		}		if ( "top" in obj ) {			this.offset.click.top = obj.top + this.margins.top;		}		if ( "bottom" in obj ) {			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;		}	},	_getParentOffset: function() {		//Get the offsetParent and cache its position		this.offsetParent = this.helper.offsetParent();		var po = this.offsetParent.offset();		// This is a special case where we need to modify a offset calculated on start, since the		// following happened:		// 1. The position of the helper is absolute, so it''s position is calculated based on the		// next positioned parent		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn''t		// the document, which means that the scroll is included in the initial calculation of the		// offset of the parent, and never recalculated upon drag		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !!== this.document[ 0 ] &&				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {			po.left += this.scrollParent.scrollLeft();			po.top += this.scrollParent.scrollTop();		}		// This needs to be actually done for all browsers, since pageX/pageY includes this		// information with an ugly IE fix		if ( this.offsetParent[ 0 ] === this.document[ 0 ].body ||				( this.offsetParent[ 0 ].tagName &&				this.offsetParent[ 0 ].tagName.toLowerCase() === "html" && $.ui.ie ) ) {			po = { top: 0, left: 0 };		}		return {			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )		};	},	_getRelativeOffset: function() {		if ( this.cssPosition === "relative" ) {			var p = this.currentItem.position();			return {				top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +					this.scrollParent.scrollTop(),				left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +					this.scrollParent.scrollLeft()			};		} else {			return { top: 0, left: 0 };		}	},	_cacheMargins: function() {		this.margins = {			left: ( parseInt( this.currentItem.css( "marginLeft" ), 10 ) || 0 ),			top: ( parseInt( this.currentItem.css( "marginTop" ), 10 ) || 0 )		};	},	_cacheHelperProportions: function() {		this.helperProportions = {			width: this.helper.outerWidth(),			height: this.helper.outerHeight()		};	},	_setContainment: function() {		var ce, co, over,			o = this.options;		if ( o.containment === "parent" ) {			o.containment = this.helper[ 0 ].parentNode;		}		if ( o.containment === "document" || o.containment === "window" ) {			this.containment = [				0 - this.offset.relative.left - this.offset.parent.left,				0 - this.offset.relative.top - this.offset.parent.top,				o.containment === "document" ?					this.document.width() :					this.window.width() - this.helperProportions.width - this.margins.left,				( o.containment === "document" ?					( this.document.height() || document.body.parentNode.scrollHeight ) :					this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight				) - this.helperProportions.height - this.margins.top			];		}		if ( !!( /^(document|window|parent)$/ ).test( o.containment ) ) {			ce = $( o.containment )[ 0 ];			co = $( o.containment ).offset();			over = ( $( ce ).css( "overflow" ) !!== "hidden" );			this.containment = [				co.left + ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) +					( parseInt( $( ce ).css( "paddingLeft" ), 10 ) || 0 ) - this.margins.left,				co.top + ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) +					( parseInt( $( ce ).css( "paddingTop" ), 10 ) || 0 ) - this.margins.top,				co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -					( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) -					( parseInt( $( ce ).css( "paddingRight" ), 10 ) || 0 ) -					this.helperProportions.width - this.margins.left,				co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -					( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) -					( parseInt( $( ce ).css( "paddingBottom" ), 10 ) || 0 ) -					this.helperProportions.height - this.margins.top			];		}	},	_convertPositionTo: function( d, pos ) {		if ( !!pos ) {			pos = this.position;		}		var mod = d === "absolute" ? 1 : -1,			scroll = this.cssPosition === "absolute" &&				!!( this.scrollParent[ 0 ] !!== this.document[ 0 ] &&				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?					this.offsetParent :					this.scrollParent,			scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );		return {			top: (				// The absolute mouse position				pos.top	+				// Only for relative positioned nodes: Relative offset from element to offset parent				this.offset.relative.top * mod +				// The offsetParent''s offset without borders (offset + border)				this.offset.parent.top * mod -				( ( this.cssPosition === "fixed" ?					-this.scrollParent.scrollTop() :					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod )			),			left: (				// The absolute mouse position				pos.left +				// Only for relative positioned nodes: Relative offset from element to offset parent				this.offset.relative.left * mod +				// The offsetParent''s offset without borders (offset + border)				this.offset.parent.left * mod	-				( ( this.cssPosition === "fixed" ?					-this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :					scroll.scrollLeft() ) * mod )			)		};	},	_generatePosition: function( event ) {		var top, left,			o = this.options,			pageX = event.pageX,			pageY = event.pageY,			scroll = this.cssPosition === "absolute" &&				!!( this.scrollParent[ 0 ] !!== this.document[ 0 ] &&				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?					this.offsetParent :					this.scrollParent,				scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );		// This is another very weird special case that only happens for relative elements:		// 1. If the css position is relative		// 2. and the scroll parent is the document or similar to the offset parent		// we have to refresh the relative offset during the scroll so there are no jumps		if ( this.cssPosition === "relative" && !!( this.scrollParent[ 0 ] !!== this.document[ 0 ] &&				this.scrollParent[ 0 ] !!== this.offsetParent[ 0 ] ) ) {			this.offset.relative = this._getRelativeOffset();		}		/*		 * - Position constraining -		 * Constrain the position to a mix of grid, containment.		 */		if ( this.originalPosition ) { //If we are not dragging yet, we won''t check for options			if ( this.containment ) {				if ( event.pageX - this.offset.click.left < this.containment[ 0 ] ) {					pageX = this.containment[ 0 ] + this.offset.click.left;				}				if ( event.pageY - this.offset.click.top < this.containment[ 1 ] ) {					pageY = this.containment[ 1 ] + this.offset.click.top;				}				if ( event.pageX - this.offset.click.left > this.containment[ 2 ] ) {					pageX = this.containment[ 2 ] + this.offset.click.left;				}				if ( event.pageY - this.offset.click.top > this.containment[ 3 ] ) {					pageY = this.containment[ 3 ] + this.offset.click.top;				}			}			if ( o.grid ) {				top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) /					o.grid[ 1 ] ) * o.grid[ 1 ];				pageY = this.containment ?					( ( top - this.offset.click.top >= this.containment[ 1 ] &&						top - this.offset.click.top <= this.containment[ 3 ] ) ?							top :							( ( top - this.offset.click.top >= this.containment[ 1 ] ) ?								top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) :								top;				left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) /					o.grid[ 0 ] ) * o.grid[ 0 ];				pageX = this.containment ?					( ( left - this.offset.click.left >= this.containment[ 0 ] &&						left - this.offset.click.left <= this.containment[ 2 ] ) ?							left :							( ( left - this.offset.click.left >= this.containment[ 0 ] ) ?								left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) :								left;			}		}		return {			top: (				// The absolute mouse position				pageY -				// Click offset (relative to the element)				this.offset.click.top -				// Only for relative positioned nodes: Relative offset from element to offset parent				this.offset.relative.top -				// The offsetParent''s offset without borders (offset + border)				this.offset.parent.top +				( ( this.cssPosition === "fixed" ?					-this.scrollParent.scrollTop() :					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )			),			left: (				// The absolute mouse position				pageX -				// Click offset (relative to the element)				this.offset.click.left -				// Only for relative positioned nodes: Relative offset from element to offset parent				this.offset.relative.left -				// The offsetParent''s offset without borders (offset + border)				this.offset.parent.left +				( ( this.cssPosition === "fixed" ?					-this.scrollParent.scrollLeft() :					scrollIsRootNode ? 0 : scroll.scrollLeft() ) )			)		};	},	_rearrange: function( event, i, a, hardRefresh ) {		if ( a ) {			a[ 0 ].appendChild( this.placeholder[ 0 ] );		} else {			i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ],				( this.direction === "down" ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) );		}		//Various things done here to improve the performance:		// 1. we create a setTimeout, that calls refreshPositions		// 2. on the instance, we have a counter variable, that get''s higher after every append		// 3. on the local scope, we copy the counter variable, and check in the timeout,		// if it''s still the same		// 4. this lets only the last addition to the timeout stack through		this.counter = this.counter ? ++this.counter : 1;		var counter = this.counter;		this._delay( function() {			if ( counter === this.counter ) {				//Precompute after each DOM insertion, NOT on mousemove				this.refreshPositions( !!hardRefresh );			}		} );	},	_clear: function( event, noPropagation ) {		this.reverting = false;		// We delay all events that have to be triggered to after the point where the placeholder		// has been removed and everything else normalized again		var i,			delayedTriggers = [];		// We first have to update the dom position of the actual currentItem		// Note: don''t do it if the current item is already removed (by a user), or it gets		// reappended (see #4088)		if ( !!this._noFinalSort && this.currentItem.parent().length ) {			this.placeholder.before( this.currentItem );		}		this._noFinalSort = null;		if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) {			for ( i in this._storedCSS ) {				if ( this._storedCSS[ i ] === "auto" || this._storedCSS[ i ] === "static" ) {					this._storedCSS[ i ] = "";				}			}			this.currentItem.css( this._storedCSS );			this._removeClass( this.currentItem, "ui-sortable-helper" );		} else {			this.currentItem.show();		}		if ( this.fromOutside && !!noPropagation ) {			delayedTriggers.push( function( event ) {				this._trigger( "receive", event, this._uiHash( this.fromOutside ) );			} );		}		if ( ( this.fromOutside ||				this.domPosition.prev !!==				this.currentItem.prev().not( ".ui-sortable-helper" )[ 0 ] ||				this.domPosition.parent !!== this.currentItem.parent()[ 0 ] ) && !!noPropagation ) {			// Trigger update callback if the DOM position has changed			delayedTriggers.push( function( event ) {				this._trigger( "update", event, this._uiHash() );			} );		}		// Check if the items Container has Changed and trigger appropriate		// events.		if ( this !!== this.currentContainer ) {			if ( !!noPropagation ) {				delayedTriggers.push( function( event ) {					this._trigger( "remove", event, this._uiHash() );				} );				delayedTriggers.push( ( function( c ) {					return function( event ) {						c._trigger( "receive", event, this._uiHash( this ) );					};				} ).call( this, this.currentContainer ) );				delayedTriggers.push( ( function( c ) {					return function( event ) {						c._trigger( "update", event, this._uiHash( this ) );					};				} ).call( this, this.currentContainer ) );			}		}		//Post events to containers		function delayEvent( type, instance, container ) {			return function( event ) {				container._trigger( type, event, instance._uiHash( instance ) );			};		}		for ( i = this.containers.length - 1; i >= 0; i-- ) {			if ( !!noPropagation ) {				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );			}			if ( this.containers[ i ].containerCache.over ) {				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );				this.containers[ i ].containerCache.over = 0;			}		}		//Do what was originally in plugins		if ( this.storedCursor ) {			this.document.find( "body" ).css( "cursor", this.storedCursor );			this.storedStylesheet.remove();		}		if ( this._storedOpacity ) {			this.helper.css( "opacity", this._storedOpacity );		}		if ( this._storedZIndex ) {			this.helper.css( "zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex );		}		this.dragging = false;		if ( !!noPropagation ) {			this._trigger( "beforeStop", event, this._uiHash() );		}		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,		// it unbinds ALL events from the original node!!		this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );		if ( !!this.cancelHelperRemoval ) {			if ( this.helper[ 0 ] !!== this.currentItem[ 0 ] ) {				this.helper.remove();			}			this.helper = null;		}		if ( !!noPropagation ) {			for ( i = 0; i < delayedTriggers.length; i++ ) {				// Trigger all delayed events				delayedTriggers[ i ].call( this, event );			}			this._trigger( "stop", event, this._uiHash() );		}		this.fromOutside = false;		return !!this.cancelHelperRemoval;	},	_trigger: function() {		if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) {			this.cancel();		}	},	_uiHash: function( _inst ) {		var inst = _inst || this;		return {			helper: inst.helper,			placeholder: inst.placeholder || $( [] ),			position: inst.position,			originalPosition: inst.originalPosition,			offset: inst.positionAbs,			item: inst.currentItem,			sender: _inst ? _inst.element : null		};	}} );/*!! * jQuery UI Spinner 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Spinner//>>group: Widgets//>>description: Displays buttons to easily input numbers via the keyboard or mouse.//>>docs: http://api.jqueryui.com/spinner///>>demos: http://jqueryui.com/spinner///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/spinner.css//>>css.theme: ../../themes/base/theme.cssfunction spinnerModifier( fn ) {	return function() {		var previous = this.element.val();		fn.apply( this, arguments );		this._refresh();		if ( previous !!== this.element.val() ) {			this._trigger( "change" );		}	};}$.widget( "ui.spinner", {	version: "1.13.2",	defaultElement: "<input>",	widgetEventPrefix: "spin",	options: {		classes: {			"ui-spinner": "ui-corner-all",			"ui-spinner-down": "ui-corner-br",			"ui-spinner-up": "ui-corner-tr"		},		culture: null,		icons: {			down: "ui-icon-triangle-1-s",			up: "ui-icon-triangle-1-n"		},		incremental: true,		max: null,		min: null,		numberFormat: null,		page: 10,		step: 1,		change: null,		spin: null,		start: null,		stop: null	},	_create: function() {		// handle string values that need to be parsed		this._setOption( "max", this.options.max );		this._setOption( "min", this.options.min );		this._setOption( "step", this.options.step );		// Only format if there is a value, prevents the field from being marked		// as invalid in Firefox, see #9573.		if ( this.value() !!== "" ) {			// Format the value, but don''t constrain.			this._value( this.element.val(), true );		}		this._draw();		this._on( this._events );		this._refresh();		// Turning off autocomplete prevents the browser from remembering the		// value when navigating through history, so we re-enable autocomplete		// if the page is unloaded before the widget is destroyed. #7790		this._on( this.window, {			beforeunload: function() {				this.element.removeAttr( "autocomplete" );			}		} );	},	_getCreateOptions: function() {		var options = this._super();		var element = this.element;		$.each( [ "min", "max", "step" ], function( i, option ) {			var value = element.attr( option );			if ( value !!= null && value.length ) {				options[ option ] = value;			}		} );		return options;	},	_events: {		keydown: function( event ) {			if ( this._start( event ) && this._keydown( event ) ) {				event.preventDefault();			}		},		keyup: "_stop",		focus: function() {			this.previous = this.element.val();		},		blur: function( event ) {			if ( this.cancelBlur ) {				delete this.cancelBlur;				return;			}			this._stop();			this._refresh();			if ( this.previous !!== this.element.val() ) {				this._trigger( "change", event );			}		},		mousewheel: function( event, delta ) {			var activeElement = $.ui.safeActiveElement( this.document[ 0 ] );			var isActive = this.element[ 0 ] === activeElement;			if ( !!isActive || !!delta ) {				return;			}			if ( !!this.spinning && !!this._start( event ) ) {				return false;			}			this._spin( ( delta > 0 ? 1 : -1 ) * this.options.step, event );			clearTimeout( this.mousewheelTimer );			this.mousewheelTimer = this._delay( function() {				if ( this.spinning ) {					this._stop( event );				}			}, 100 );			event.preventDefault();		},		"mousedown .ui-spinner-button": function( event ) {			var previous;			// We never want the buttons to have focus; whenever the user is			// interacting with the spinner, the focus should be on the input.			// If the input is focused then this.previous is properly set from			// when the input first received focus. If the input is not focused			// then we need to set this.previous based on the value before spinning.			previous = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] ) ?				this.previous : this.element.val();			function checkFocus() {				var isActive = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] );				if ( !!isActive ) {					this.element.trigger( "focus" );					this.previous = previous;					// support: IE					// IE sets focus asynchronously, so we need to check if focus					// moved off of the input because the user clicked on the button.					this._delay( function() {						this.previous = previous;					} );				}			}			// Ensure focus is on (or stays on) the text field			event.preventDefault();			checkFocus.call( this );			// Support: IE			// IE doesn''t prevent moving focus even with event.preventDefault()			// so we set a flag to know when we should ignore the blur event			// and check (again) if focus moved off of the input.			this.cancelBlur = true;			this._delay( function() {				delete this.cancelBlur;				checkFocus.call( this );			} );			if ( this._start( event ) === false ) {				return;			}			this._repeat( null, $( event.currentTarget )				.hasClass( "ui-spinner-up" ) ? 1 : -1, event );		},		"mouseup .ui-spinner-button": "_stop",		"mouseenter .ui-spinner-button": function( event ) {			// button will add ui-state-active if mouse was down while mouseleave and kept down			if ( !!$( event.currentTarget ).hasClass( "ui-state-active" ) ) {				return;			}			if ( this._start( event ) === false ) {				return false;			}			this._repeat( null, $( event.currentTarget )				.hasClass( "ui-spinner-up" ) ? 1 : -1, event );		},		// TODO: do we really want to consider this a stop?		// shouldn''t we just stop the repeater and wait until mouseup before		// we trigger the stop event?		"mouseleave .ui-spinner-button": "_stop"	},	// Support mobile enhanced option and make backcompat more sane	_enhance: function() {		this.uiSpinner = this.element			.attr( "autocomplete", "off" )			.wrap( "<span>" )			.parent()				// Add buttons				.append(					"<a></a><a></a>"				);	},	_draw: function() {		this._enhance();		this._addClass( this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content" );		this._addClass( "ui-spinner-input" );		this.element.attr( "role", "spinbutton" );		// Button bindings		this.buttons = this.uiSpinner.children( "a" )			.attr( "tabIndex", -1 )			.attr( "aria-hidden", true )			.button( {				classes: {					"ui-button": ""				}			} );		// TODO: Right now button does not support classes this is already updated in button PR		this._removeClass( this.buttons, "ui-corner-all" );		this._addClass( this.buttons.first(), "ui-spinner-button ui-spinner-up" );		this._addClass( this.buttons.last(), "ui-spinner-button ui-spinner-down" );		this.buttons.first().button( {			"icon": this.options.icons.up,			"showLabel": false		} );		this.buttons.last().button( {			"icon": this.options.icons.down,			"showLabel": false		} );		// IE 6 doesn''t understand height: 50% for the buttons		// unless the wrapper has an explicit height		if ( this.buttons.height() > Math.ceil( this.uiSpinner.height() * 0.5 ) &&				this.uiSpinner.height() > 0 ) {			this.uiSpinner.height( this.uiSpinner.height() );		}	},	_keydown: function( event ) {		var options = this.options,			keyCode = $.ui.keyCode;		switch ( event.keyCode ) {		case keyCode.UP:			this._repeat( null, 1, event );			return true;		case keyCode.DOWN:			this._repeat( null, -1, event );			return true;		case keyCode.PAGE_UP:			this._repeat( null, options.page, event );			return true;		case keyCode.PAGE_DOWN:			this._repeat( null, -options.page, event );			return true;		}		return false;	},	_start: function( event ) {		if ( !!this.spinning && this._trigger( "start", event ) === false ) {			return false;		}		if ( !!this.counter ) {			this.counter = 1;		}		this.spinning = true;		return true;	},	_repeat: function( i, steps, event ) {		i = i || 500;		clearTimeout( this.timer );		this.timer = this._delay( function() {			this._repeat( 40, steps, event );		}, i );		this._spin( steps * this.options.step, event );	},	_spin: function( step, event ) {		var value = this.value() || 0;		if ( !!this.counter ) {			this.counter = 1;		}		value = this._adjustValue( value + step * this._increment( this.counter ) );		if ( !!this.spinning || this._trigger( "spin", event, { value: value } ) !!== false ) {			this._value( value );			this.counter++;		}	},	_increment: function( i ) {		var incremental = this.options.incremental;		if ( incremental ) {			return typeof incremental === "function" ?				incremental( i ) :				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );		}		return 1;	},	_precision: function() {		var precision = this._precisionOf( this.options.step );		if ( this.options.min !!== null ) {			precision = Math.max( precision, this._precisionOf( this.options.min ) );		}		return precision;	},	_precisionOf: function( num ) {		var str = num.toString(),			decimal = str.indexOf( "." );		return decimal === -1 ? 0 : str.length - decimal - 1;	},	_adjustValue: function( value ) {		var base, aboveMin,			options = this.options;		// Make sure we''re at a valid step		// - find out where we are relative to the base (min or 0)		base = options.min !!== null ? options.min : 0;		aboveMin = value - base;		// - round to the nearest step		aboveMin = Math.round( aboveMin / options.step ) * options.step;		// - rounding is based on 0, so adjust back to our base		value = base + aboveMin;		// Fix precision from bad JS floating point math		value = parseFloat( value.toFixed( this._precision() ) );		// Clamp the value		if ( options.max !!== null && value > options.max ) {			return options.max;		}		if ( options.min !!== null && value < options.min ) {			return options.min;		}		return value;	},	_stop: function( event ) {		if ( !!this.spinning ) {			return;		}		clearTimeout( this.timer );		clearTimeout( this.mousewheelTimer );		this.counter = 0;		this.spinning = false;		this._trigger( "stop", event );	},	_setOption: function( key, value ) {		var prevValue, first, last;		if ( key === "culture" || key === "numberFormat" ) {			prevValue = this._parse( this.element.val() );			this.options[ key ] = value;			this.element.val( this._format( prevValue ) );			return;		}		if ( key === "max" || key === "min" || key === "step" ) {			if ( typeof value === "string" ) {				value = this._parse( value );			}		}		if ( key === "icons" ) {			first = this.buttons.first().find( ".ui-icon" );			this._removeClass( first, null, this.options.icons.up );			this._addClass( first, null, value.up );			last = this.buttons.last().find( ".ui-icon" );			this._removeClass( last, null, this.options.icons.down );			this._addClass( last, null, value.down );		}		this._super( key, value );	},	_setOptionDisabled: function( value ) {		this._super( value );		this._toggleClass( this.uiSpinner, null, "ui-state-disabled", !!!!value );		this.element.prop( "disabled", !!!!value );		this.buttons.button( value ? "disable" : "enable" );	},	_setOptions: spinnerModifier( function( options ) {		this._super( options );	} ),	_parse: function( val ) {		if ( typeof val === "string" && val !!== "" ) {			val = window.Globalize && this.options.numberFormat ?				Globalize.parseFloat( val, 10, this.options.culture ) : +val;		}		return val === "" || isNaN( val ) ? null : val;	},	_format: function( value ) {		if ( value === "" ) {			return "";		}		return window.Globalize && this.options.numberFormat ?			Globalize.format( value, this.options.numberFormat, this.options.culture ) :			value;	},	_refresh: function() {		this.element.attr( {			"aria-valuemin": this.options.min,			"aria-valuemax": this.options.max,			// TODO: what should we do with values that can''t be parsed?			"aria-valuenow": this._parse( this.element.val() )		} );	},	isValid: function() {		var value = this.value();		// Null is invalid		if ( value === null ) {			return false;		}		// If value gets adjusted, it''s invalid		return value === this._adjustValue( value );	},	// Update the value without triggering change	_value: function( value, allowAny ) {		var parsed;		if ( value !!== "" ) {			parsed = this._parse( value );			if ( parsed !!== null ) {				if ( !!allowAny ) {					parsed = this._adjustValue( parsed );				}				value = this._format( parsed );			}		}		this.element.val( value );		this._refresh();	},	_destroy: function() {		this.element			.prop( "disabled", false )			.removeAttr( "autocomplete role aria-valuemin aria-valuemax aria-valuenow" );		this.uiSpinner.replaceWith( this.element );	},	stepUp: spinnerModifier( function( steps ) {		this._stepUp( steps );	} ),	_stepUp: function( steps ) {		if ( this._start() ) {			this._spin( ( steps || 1 ) * this.options.step );			this._stop();		}	},	stepDown: spinnerModifier( function( steps ) {		this._stepDown( steps );	} ),	_stepDown: function( steps ) {		if ( this._start() ) {			this._spin( ( steps || 1 ) * -this.options.step );			this._stop();		}	},	pageUp: spinnerModifier( function( pages ) {		this._stepUp( ( pages || 1 ) * this.options.page );	} ),	pageDown: spinnerModifier( function( pages ) {		this._stepDown( ( pages || 1 ) * this.options.page );	} ),	value: function( newVal ) {		if ( !!arguments.length ) {			return this._parse( this.element.val() );		}		spinnerModifier( this._value ).call( this, newVal );	},	widget: function() {		return this.uiSpinner;	}} );// DEPRECATED// TODO: switch return back to widget declaration at top of file when this is removedif ( $.uiBackCompat !!== false ) {	// Backcompat for spinner html extension points	$.widget( "ui.spinner", $.ui.spinner, {		_enhance: function() {			this.uiSpinner = this.element				.attr( "autocomplete", "off" )				.wrap( this._uiSpinnerHtml() )				.parent()					// Add buttons					.append( this._buttonHtml() );		},		_uiSpinnerHtml: function() {			return "<span>";		},		_buttonHtml: function() {			return "<a></a><a></a>";		}	} );}var widgetsSpinner = $.ui.spinner;/*!! * jQuery UI Tabs 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Tabs//>>group: Widgets//>>description: Transforms a set of container elements into a tab structure.//>>docs: http://api.jqueryui.com/tabs///>>demos: http://jqueryui.com/tabs///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/tabs.css//>>css.theme: ../../themes/base/theme.css$.widget( "ui.tabs", {	version: "1.13.2",	delay: 300,	options: {		active: null,		classes: {			"ui-tabs": "ui-corner-all",			"ui-tabs-nav": "ui-corner-all",			"ui-tabs-panel": "ui-corner-bottom",			"ui-tabs-tab": "ui-corner-top"		},		collapsible: false,		event: "click",		heightStyle: "content",		hide: null,		show: null,		// Callbacks		activate: null,		beforeActivate: null,		beforeLoad: null,		load: null	},	_isLocal: ( function() {		var rhash = /#.*$/;		return function( anchor ) {			var anchorUrl, locationUrl;			anchorUrl = anchor.href.replace( rhash, "" );			locationUrl = location.href.replace( rhash, "" );			// Decoding may throw an error if the URL isn''t UTF-8 (#9518)			try {				anchorUrl = decodeURIComponent( anchorUrl );			} catch ( error ) {}			try {				locationUrl = decodeURIComponent( locationUrl );			} catch ( error ) {}			return anchor.hash.length > 1 && anchorUrl === locationUrl;		};	} )(),	_create: function() {		var that = this,			options = this.options;		this.running = false;		this._addClass( "ui-tabs", "ui-widget ui-widget-content" );		this._toggleClass( "ui-tabs-collapsible", null, options.collapsible );		this._processTabs();		options.active = this._initialActive();		// Take disabling tabs via class attribute from HTML		// into account and update option properly.		if ( Array.isArray( options.disabled ) ) {			options.disabled = $.uniqueSort( options.disabled.concat(				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {					return that.tabs.index( li );				} )			) ).sort();		}		// Check for length avoids error when initializing empty list		if ( this.options.active !!== false && this.anchors.length ) {			this.active = this._findActive( options.active );		} else {			this.active = $();		}		this._refresh();		if ( this.active.length ) {			this.load( options.active );		}	},	_initialActive: function() {		var active = this.options.active,			collapsible = this.options.collapsible,			locationHash = location.hash.substring( 1 );		if ( active === null ) {			// check the fragment identifier in the URL			if ( locationHash ) {				this.tabs.each( function( i, tab ) {					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {						active = i;						return false;					}				} );			}			// Check for a tab marked active via a class			if ( active === null ) {				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );			}			// No active tab, set to false			if ( active === null || active === -1 ) {				active = this.tabs.length ? 0 : false;			}		}		// Handle numbers: negative, out of range		if ( active !!== false ) {			active = this.tabs.index( this.tabs.eq( active ) );			if ( active === -1 ) {				active = collapsible ? false : 0;			}		}		// Don''t allow collapsible: false and active: false		if ( !!collapsible && active === false && this.anchors.length ) {			active = 0;		}		return active;	},	_getCreateEventData: function() {		return {			tab: this.active,			panel: !!this.active.length ? $() : this._getPanelForTab( this.active )		};	},	_tabKeydown: function( event ) {		var focusedTab = $( $.ui.safeActiveElement( this.document[ 0 ] ) ).closest( "li" ),			selectedIndex = this.tabs.index( focusedTab ),			goingForward = true;		if ( this._handlePageNav( event ) ) {			return;		}		switch ( event.keyCode ) {		case $.ui.keyCode.RIGHT:		case $.ui.keyCode.DOWN:			selectedIndex++;			break;		case $.ui.keyCode.UP:		case $.ui.keyCode.LEFT:			goingForward = false;			selectedIndex--;			break;		case $.ui.keyCode.END:			selectedIndex = this.anchors.length - 1;			break;		case $.ui.keyCode.HOME:			selectedIndex = 0;			break;		case $.ui.keyCode.SPACE:			// Activate only, no collapsing			event.preventDefault();			clearTimeout( this.activating );			this._activate( selectedIndex );			return;		case $.ui.keyCode.ENTER:			// Toggle (cancel delayed activation, allow collapsing)			event.preventDefault();			clearTimeout( this.activating );			// Determine if we should collapse or activate			this._activate( selectedIndex === this.options.active ? false : selectedIndex );			return;		default:			return;		}		// Focus the appropriate tab, based on which key was pressed		event.preventDefault();		clearTimeout( this.activating );		selectedIndex = this._focusNextTab( selectedIndex, goingForward );		// Navigating with control/command key will prevent automatic activation		if ( !!event.ctrlKey && !!event.metaKey ) {			// Update aria-selected immediately so that AT think the tab is already selected.			// Otherwise AT may confuse the user by stating that they need to activate the tab,			// but the tab will already be activated by the time the announcement finishes.			focusedTab.attr( "aria-selected", "false" );			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );			this.activating = this._delay( function() {				this.option( "active", selectedIndex );			}, this.delay );		}	},	_panelKeydown: function( event ) {		if ( this._handlePageNav( event ) ) {			return;		}		// Ctrl+up moves focus to the current tab		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {			event.preventDefault();			this.active.trigger( "focus" );		}	},	// Alt+page up/down moves focus to the previous/next tab (and activates)	_handlePageNav: function( event ) {		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {			this._activate( this._focusNextTab( this.options.active - 1, false ) );			return true;		}		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {			this._activate( this._focusNextTab( this.options.active + 1, true ) );			return true;		}	},	_findNextTab: function( index, goingForward ) {		var lastTabIndex = this.tabs.length - 1;		function constrain() {			if ( index > lastTabIndex ) {				index = 0;			}			if ( index < 0 ) {				index = lastTabIndex;			}			return index;		}		while ( $.inArray( constrain(), this.options.disabled ) !!== -1 ) {			index = goingForward ? index + 1 : index - 1;		}		return index;	},	_focusNextTab: function( index, goingForward ) {		index = this._findNextTab( index, goingForward );		this.tabs.eq( index ).trigger( "focus" );		return index;	},	_setOption: function( key, value ) {		if ( key === "active" ) {			// _activate() will handle invalid values and update this.options			this._activate( value );			return;		}		this._super( key, value );		if ( key === "collapsible" ) {			this._toggleClass( "ui-tabs-collapsible", null, value );			// Setting collapsible: false while collapsed; open first panel			if ( !!value && this.options.active === false ) {				this._activate( 0 );			}		}		if ( key === "event" ) {			this._setupEvents( value );		}		if ( key === "heightStyle" ) {			this._setupHeightStyle( value );		}	},	_sanitizeSelector: function( hash ) {		return hash ? hash.replace( /[!!"$%&''()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";	},	refresh: function() {		var options = this.options,			lis = this.tablist.children( ":has(a[href])" );		// Get disabled tabs from class attribute from HTML		// this will get converted to a boolean if needed in _refresh()		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {			return lis.index( tab );		} );		this._processTabs();		// Was collapsed or no tabs		if ( options.active === false || !!this.anchors.length ) {			options.active = false;			this.active = $();		// was active, but active tab is gone		} else if ( this.active.length && !!$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {			// all remaining tabs are disabled			if ( this.tabs.length === options.disabled.length ) {				options.active = false;				this.active = $();			// activate previous tab			} else {				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );			}		// was active, active tab still exists		} else {			// make sure active index is correct			options.active = this.tabs.index( this.active );		}		this._refresh();	},	_refresh: function() {		this._setOptionDisabled( this.options.disabled );		this._setupEvents( this.options.event );		this._setupHeightStyle( this.options.heightStyle );		this.tabs.not( this.active ).attr( {			"aria-selected": "false",			"aria-expanded": "false",			tabIndex: -1		} );		this.panels.not( this._getPanelForTab( this.active ) )			.hide()			.attr( {				"aria-hidden": "true"			} );		// Make sure one tab is in the tab order		if ( !!this.active.length ) {			this.tabs.eq( 0 ).attr( "tabIndex", 0 );		} else {			this.active				.attr( {					"aria-selected": "true",					"aria-expanded": "true",					tabIndex: 0				} );			this._addClass( this.active, "ui-tabs-active", "ui-state-active" );			this._getPanelForTab( this.active )				.show()				.attr( {					"aria-hidden": "false"				} );		}	},	_processTabs: function() {		var that = this,			prevTabs = this.tabs,			prevAnchors = this.anchors,			prevPanels = this.panels;		this.tablist = this._getList().attr( "role", "tablist" );		this._addClass( this.tablist, "ui-tabs-nav",			"ui-helper-reset ui-helper-clearfix ui-widget-header" );		// Prevent users from focusing disabled tabs via click		this.tablist			.on( "mousedown" + this.eventNamespace, "> li", function( event ) {				if ( $( this ).is( ".ui-state-disabled" ) ) {					event.preventDefault();				}			} )			// Support: IE <9			// Preventing the default action in mousedown doesn''t prevent IE			// from focusing the element, so if the anchor gets focused, blur.			// We don''t have to worry about focusing the previously focused			// element since clicking on a non-focusable element should focus			// the body anyway.			.on( "focus" + this.eventNamespace, ".ui-tabs-anchor", function() {				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {					this.blur();				}			} );		this.tabs = this.tablist.find( "> li:has(a[href])" )			.attr( {				role: "tab",				tabIndex: -1			} );		this._addClass( this.tabs, "ui-tabs-tab", "ui-state-default" );		this.anchors = this.tabs.map( function() {			return $( "a", this )[ 0 ];		} )			.attr( {				tabIndex: -1			} );		this._addClass( this.anchors, "ui-tabs-anchor" );		this.panels = $();		this.anchors.each( function( i, anchor ) {			var selector, panel, panelId,				anchorId = $( anchor ).uniqueId().attr( "id" ),				tab = $( anchor ).closest( "li" ),				originalAriaControls = tab.attr( "aria-controls" );			// Inline tab			if ( that._isLocal( anchor ) ) {				selector = anchor.hash;				panelId = selector.substring( 1 );				panel = that.element.find( that._sanitizeSelector( selector ) );			// remote tab			} else {				// If the tab doesn''t already have aria-controls,				// generate an id by using a throw-away element				panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;				selector = "#" + panelId;				panel = that.element.find( selector );				if ( !!panel.length ) {					panel = that._createPanel( panelId );					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );				}				panel.attr( "aria-live", "polite" );			}			if ( panel.length ) {				that.panels = that.panels.add( panel );			}			if ( originalAriaControls ) {				tab.data( "ui-tabs-aria-controls", originalAriaControls );			}			tab.attr( {				"aria-controls": panelId,				"aria-labelledby": anchorId			} );			panel.attr( "aria-labelledby", anchorId );		} );		this.panels.attr( "role", "tabpanel" );		this._addClass( this.panels, "ui-tabs-panel", "ui-widget-content" );		// Avoid memory leaks (#10056)		if ( prevTabs ) {			this._off( prevTabs.not( this.tabs ) );			this._off( prevAnchors.not( this.anchors ) );			this._off( prevPanels.not( this.panels ) );		}	},	// Allow overriding how to find the list for rare usage scenarios (#7715)	_getList: function() {		return this.tablist || this.element.find( "ol, ul" ).eq( 0 );	},	_createPanel: function( id ) {		return $( "<div>" )			.attr( "id", id )			.data( "ui-tabs-destroy", true );	},	_setOptionDisabled: function( disabled ) {		var currentItem, li, i;		if ( Array.isArray( disabled ) ) {			if ( !!disabled.length ) {				disabled = false;			} else if ( disabled.length === this.anchors.length ) {				disabled = true;			}		}		// Disable tabs		for ( i = 0; ( li = this.tabs[ i ] ); i++ ) {			currentItem = $( li );			if ( disabled === true || $.inArray( i, disabled ) !!== -1 ) {				currentItem.attr( "aria-disabled", "true" );				this._addClass( currentItem, null, "ui-state-disabled" );			} else {				currentItem.removeAttr( "aria-disabled" );				this._removeClass( currentItem, null, "ui-state-disabled" );			}		}		this.options.disabled = disabled;		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null,			disabled === true );	},	_setupEvents: function( event ) {		var events = {};		if ( event ) {			$.each( event.split( " " ), function( index, eventName ) {				events[ eventName ] = "_eventHandler";			} );		}		this._off( this.anchors.add( this.tabs ).add( this.panels ) );		// Always prevent the default action, even when disabled		this._on( true, this.anchors, {			click: function( event ) {				event.preventDefault();			}		} );		this._on( this.anchors, events );		this._on( this.tabs, { keydown: "_tabKeydown" } );		this._on( this.panels, { keydown: "_panelKeydown" } );		this._focusable( this.tabs );		this._hoverable( this.tabs );	},	_setupHeightStyle: function( heightStyle ) {		var maxHeight,			parent = this.element.parent();		if ( heightStyle === "fill" ) {			maxHeight = parent.height();			maxHeight -= this.element.outerHeight() - this.element.height();			this.element.siblings( ":visible" ).each( function() {				var elem = $( this ),					position = elem.css( "position" );				if ( position === "absolute" || position === "fixed" ) {					return;				}				maxHeight -= elem.outerHeight( true );			} );			this.element.children().not( this.panels ).each( function() {				maxHeight -= $( this ).outerHeight( true );			} );			this.panels.each( function() {				$( this ).height( Math.max( 0, maxHeight -					$( this ).innerHeight() + $( this ).height() ) );			} )				.css( "overflow", "auto" );		} else if ( heightStyle === "auto" ) {			maxHeight = 0;			this.panels.each( function() {				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );			} ).height( maxHeight );		}	},	_eventHandler: function( event ) {		var options = this.options,			active = this.active,			anchor = $( event.currentTarget ),			tab = anchor.closest( "li" ),			clickedIsActive = tab[ 0 ] === active[ 0 ],			collapsing = clickedIsActive && options.collapsible,			toShow = collapsing ? $() : this._getPanelForTab( tab ),			toHide = !!active.length ? $() : this._getPanelForTab( active ),			eventData = {				oldTab: active,				oldPanel: toHide,				newTab: collapsing ? $() : tab,				newPanel: toShow			};		event.preventDefault();		if ( tab.hasClass( "ui-state-disabled" ) ||				// tab is already loading				tab.hasClass( "ui-tabs-loading" ) ||				// can''t switch durning an animation				this.running ||				// click on active header, but not collapsible				( clickedIsActive && !!options.collapsible ) ||				// allow canceling activation				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {			return;		}		options.active = collapsing ? false : this.tabs.index( tab );		this.active = clickedIsActive ? $() : tab;		if ( this.xhr ) {			this.xhr.abort();		}		if ( !!toHide.length && !!toShow.length ) {			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );		}		if ( toShow.length ) {			this.load( this.tabs.index( tab ), event );		}		this._toggle( event, eventData );	},	// Handles show/hide for selecting tabs	_toggle: function( event, eventData ) {		var that = this,			toShow = eventData.newPanel,			toHide = eventData.oldPanel;		this.running = true;		function complete() {			that.running = false;			that._trigger( "activate", event, eventData );		}		function show() {			that._addClass( eventData.newTab.closest( "li" ), "ui-tabs-active", "ui-state-active" );			if ( toShow.length && that.options.show ) {				that._show( toShow, that.options.show, complete );			} else {				toShow.show();				complete();			}		}		// Start out by hiding, then showing, then completing		if ( toHide.length && this.options.hide ) {			this._hide( toHide, this.options.hide, function() {				that._removeClass( eventData.oldTab.closest( "li" ),					"ui-tabs-active", "ui-state-active" );				show();			} );		} else {			this._removeClass( eventData.oldTab.closest( "li" ),				"ui-tabs-active", "ui-state-active" );			toHide.hide();			show();		}		toHide.attr( "aria-hidden", "true" );		eventData.oldTab.attr( {			"aria-selected": "false",			"aria-expanded": "false"		} );		// If we''re switching tabs, remove the old tab from the tab order.		// If we''re opening from collapsed state, remove the previous tab from the tab order.		// If we''re collapsing, then keep the collapsing tab in the tab order.		if ( toShow.length && toHide.length ) {			eventData.oldTab.attr( "tabIndex", -1 );		} else if ( toShow.length ) {			this.tabs.filter( function() {				return $( this ).attr( "tabIndex" ) === 0;			} )				.attr( "tabIndex", -1 );		}		toShow.attr( "aria-hidden", "false" );		eventData.newTab.attr( {			"aria-selected": "true",			"aria-expanded": "true",			tabIndex: 0		} );	},	_activate: function( index ) {		var anchor,			active = this._findActive( index );		// Trying to activate the already active panel		if ( active[ 0 ] === this.active[ 0 ] ) {			return;		}		// Trying to collapse, simulate a click on the current active header		if ( !!active.length ) {			active = this.active;		}		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];		this._eventHandler( {			target: anchor,			currentTarget: anchor,			preventDefault: $.noop		} );	},	_findActive: function( index ) {		return index === false ? $() : this.tabs.eq( index );	},	_getIndex: function( index ) {		// meta-function to give users option to provide a href string instead of a numerical index.		if ( typeof index === "string" ) {			index = this.anchors.index( this.anchors.filter( "[href$=''" +				$.escapeSelector( index ) + "'']" ) );		}		return index;	},	_destroy: function() {		if ( this.xhr ) {			this.xhr.abort();		}		this.tablist			.removeAttr( "role" )			.off( this.eventNamespace );		this.anchors			.removeAttr( "role tabIndex" )			.removeUniqueId();		this.tabs.add( this.panels ).each( function() {			if ( $.data( this, "ui-tabs-destroy" ) ) {				$( this ).remove();			} else {				$( this ).removeAttr( "role tabIndex " +					"aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded" );			}		} );		this.tabs.each( function() {			var li = $( this ),				prev = li.data( "ui-tabs-aria-controls" );			if ( prev ) {				li					.attr( "aria-controls", prev )					.removeData( "ui-tabs-aria-controls" );			} else {				li.removeAttr( "aria-controls" );			}		} );		this.panels.show();		if ( this.options.heightStyle !!== "content" ) {			this.panels.css( "height", "" );		}	},	enable: function( index ) {		var disabled = this.options.disabled;		if ( disabled === false ) {			return;		}		if ( index === undefined ) {			disabled = false;		} else {			index = this._getIndex( index );			if ( Array.isArray( disabled ) ) {				disabled = $.map( disabled, function( num ) {					return num !!== index ? num : null;				} );			} else {				disabled = $.map( this.tabs, function( li, num ) {					return num !!== index ? num : null;				} );			}		}		this._setOptionDisabled( disabled );	},	disable: function( index ) {		var disabled = this.options.disabled;		if ( disabled === true ) {			return;		}		if ( index === undefined ) {			disabled = true;		} else {			index = this._getIndex( index );			if ( $.inArray( index, disabled ) !!== -1 ) {				return;			}			if ( Array.isArray( disabled ) ) {				disabled = $.merge( [ index ], disabled ).sort();			} else {				disabled = [ index ];			}		}		this._setOptionDisabled( disabled );	},	load: function( index, event ) {		index = this._getIndex( index );		var that = this,			tab = this.tabs.eq( index ),			anchor = tab.find( ".ui-tabs-anchor" ),			panel = this._getPanelForTab( tab ),			eventData = {				tab: tab,				panel: panel			},			complete = function( jqXHR, status ) {				if ( status === "abort" ) {					that.panels.stop( false, true );				}				that._removeClass( tab, "ui-tabs-loading" );				panel.removeAttr( "aria-busy" );				if ( jqXHR === that.xhr ) {					delete that.xhr;				}			};		// Not remote		if ( this._isLocal( anchor[ 0 ] ) ) {			return;		}		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );		// Support: jQuery <1.8		// jQuery <1.8 returns false if the request is canceled in beforeSend,		// but as of 1.8, $.ajax() always returns a jqXHR object.		if ( this.xhr && this.xhr.statusText !!== "canceled" ) {			this._addClass( tab, "ui-tabs-loading" );			panel.attr( "aria-busy", "true" );			this.xhr				.done( function( response, status, jqXHR ) {					// support: jQuery <1.8					// http://bugs.jquery.com/ticket/11778					setTimeout( function() {						panel.html( response );						that._trigger( "load", event, eventData );						complete( jqXHR, status );					}, 1 );				} )				.fail( function( jqXHR, status ) {					// support: jQuery <1.8					// http://bugs.jquery.com/ticket/11778					setTimeout( function() {						complete( jqXHR, status );					}, 1 );				} );		}	},	_ajaxSettings: function( anchor, event, eventData ) {		var that = this;		return {			// Support: IE <11 only			// Strip any hash that exists to prevent errors with the Ajax request			url: anchor.attr( "href" ).replace( /#.*$/, "" ),			beforeSend: function( jqXHR, settings ) {				return that._trigger( "beforeLoad", event,					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );			}		};	},	_getPanelForTab: function( tab ) {		var id = $( tab ).attr( "aria-controls" );		return this.element.find( this._sanitizeSelector( "#" + id ) );	}} );// DEPRECATED// TODO: Switch return back to widget declaration at top of file when this is removedif ( $.uiBackCompat !!== false ) {	// Backcompat for ui-tab class (now ui-tabs-tab)	$.widget( "ui.tabs", $.ui.tabs, {		_processTabs: function() {			this._superApply( arguments );			this._addClass( this.tabs, "ui-tab" );		}	} );}var widgetsTabs = $.ui.tabs;/*!! * jQuery UI Tooltip 1.13.2 * http://jqueryui.com * * Copyright jQuery Foundation and other contributors * Released under the MIT license. * http://jquery.org/license *///>>label: Tooltip//>>group: Widgets//>>description: Shows additional information for any element on hover or focus.//>>docs: http://api.jqueryui.com/tooltip///>>demos: http://jqueryui.com/tooltip///>>css.structure: ../../themes/base/core.css//>>css.structure: ../../themes/base/tooltip.css//>>css.theme: ../../themes/base/theme.css$.widget( "ui.tooltip", {	version: "1.13.2",	options: {		classes: {			"ui-tooltip": "ui-corner-all ui-widget-shadow"		},		content: function() {			var title = $( this ).attr( "title" );			// Escape title, since we''re going from an attribute to raw HTML			return $( "<a>" ).text( title ).html();		},		hide: true,		// Disabled elements have inconsistent behavior across browsers (#8661)		items: "[title]:not([disabled])",		position: {			my: "left top+15",			at: "left bottom",			collision: "flipfit flip"		},		show: true,		track: false,		// Callbacks		close: null,		open: null	},	_addDescribedBy: function( elem, id ) {		var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );		describedby.push( id );		elem			.data( "ui-tooltip-id", id )			.attr( "aria-describedby", String.prototype.trim.call( describedby.join( " " ) ) );	},	_removeDescribedBy: function( elem ) {		var id = elem.data( "ui-tooltip-id" ),			describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),			index = $.inArray( id, describedby );		if ( index !!== -1 ) {			describedby.splice( index, 1 );		}		elem.removeData( "ui-tooltip-id" );		describedby = String.prototype.trim.call( describedby.join( " " ) );		if ( describedby ) {			elem.attr( "aria-describedby", describedby );		} else {			elem.removeAttr( "aria-describedby" );		}	},	_create: function() {		this._on( {			mouseover: "open",			focusin: "open"		} );		// IDs of generated tooltips, needed for destroy		this.tooltips = {};		// IDs of parent tooltips where we removed the title attribute		this.parents = {};		// Append the aria-live region so tooltips announce correctly		this.liveRegion = $( "<div>" )			.attr( {				role: "log",				"aria-live": "assertive",				"aria-relevant": "additions"			} )			.appendTo( this.document[ 0 ].body );		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );		this.disabledTitles = $( [] );	},	_setOption: function( key, value ) {		var that = this;		this._super( key, value );		if ( key === "content" ) {			$.each( this.tooltips, function( id, tooltipData ) {				that._updateContent( tooltipData.element );			} );		}	},	_setOptionDisabled: function( value ) {		this[ value ? "_disable" : "_enable" ]();	},	_disable: function() {		var that = this;		// Close open tooltips		$.each( this.tooltips, function( id, tooltipData ) {			var event = $.Event( "blur" );			event.target = event.currentTarget = tooltipData.element[ 0 ];			that.close( event, true );		} );		// Remove title attributes to prevent native tooltips		this.disabledTitles = this.disabledTitles.add(			this.element.find( this.options.items ).addBack()				.filter( function() {					var element = $( this );					if ( element.is( "[title]" ) ) {						return element							.data( "ui-tooltip-title", element.attr( "title" ) )							.removeAttr( "title" );					}				} )		);	},	_enable: function() {		// restore title attributes		this.disabledTitles.each( function() {			var element = $( this );			if ( element.data( "ui-tooltip-title" ) ) {				element.attr( "title", element.data( "ui-tooltip-title" ) );			}		} );		this.disabledTitles = $( [] );	},	open: function( event ) {		var that = this,			target = $( event ? event.target : this.element )				// we need closest here due to mouseover bubbling,				// but always pointing at the same event target				.closest( this.options.items );		// No element to show a tooltip for or the tooltip is already open		if ( !!target.length || target.data( "ui-tooltip-id" ) ) {			return;		}		if ( target.attr( "title" ) ) {			target.data( "ui-tooltip-title", target.attr( "title" ) );		}		target.data( "ui-tooltip-open", true );		// Kill parent tooltips, custom or native, for hover		if ( event && event.type === "mouseover" ) {			target.parents().each( function() {				var parent = $( this ),					blurEvent;				if ( parent.data( "ui-tooltip-open" ) ) {					blurEvent = $.Event( "blur" );					blurEvent.target = blurEvent.currentTarget = this;					that.close( blurEvent, true );				}				if ( parent.attr( "title" ) ) {					parent.uniqueId();					that.parents[ this.id ] = {						element: this,						title: parent.attr( "title" )					};					parent.attr( "title", "" );				}			} );		}		this._registerCloseHandlers( event, target );		this._updateContent( target, event );	},	_updateContent: function( target, event ) {		var content,			contentOption = this.options.content,			that = this,			eventType = event ? event.type : null;		if ( typeof contentOption === "string" || contentOption.nodeType ||				contentOption.jquery ) {			return this._open( event, target, contentOption );		}		content = contentOption.call( target[ 0 ], function( response ) {			// IE may instantly serve a cached response for ajax requests			// delay this call to _open so the other call to _open runs first			that._delay( function() {				// Ignore async response if tooltip was closed already				if ( !!target.data( "ui-tooltip-open" ) ) {					return;				}				// JQuery creates a special event for focusin when it doesn''t				// exist natively. To improve performance, the native event				// object is reused and the type is changed. Therefore, we can''t				// rely on the type being correct after the event finished				// bubbling, so we set it back to the previous value. (#8740)				if ( event ) {					event.type = eventType;				}				this._open( event, target, response );			} );		} );		if ( content ) {			this._open( event, target, content );		}	},	_open: function( event, target, content ) {		var tooltipData, tooltip, delayedShow, a11yContent,			positionOption = $.extend( {}, this.options.position );		if ( !!content ) {			return;		}		// Content can be updated multiple times. If the tooltip already		// exists, then just update the content and bail.		tooltipData = this._find( target );		if ( tooltipData ) {			tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );			return;		}		// If we have a title, clear it to prevent the native tooltip		// we have to check first to avoid defining a title if none exists		// (we don''t want to cause an element to start matching [title])		//		// We use removeAttr only for key events, to allow IE to export the correct		// accessible attributes. For mouse events, set to empty string to avoid		// native tooltip showing up (happens only when removing inside mouseover).		if ( target.is( "[title]" ) ) {			if ( event && event.type === "mouseover" ) {				target.attr( "title", "" );			} else {				target.removeAttr( "title" );			}		}		tooltipData = this._tooltip( target );		tooltip = tooltipData.tooltip;		this._addDescribedBy( target, tooltip.attr( "id" ) );		tooltip.find( ".ui-tooltip-content" ).html( content );		// Support: Voiceover on OS X, JAWS on IE <= 9		// JAWS announces deletions even when aria-relevant="additions"		// Voiceover will sometimes re-read the entire log region''s contents from the beginning		this.liveRegion.children().hide();		a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );		a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );		a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );		a11yContent.appendTo( this.liveRegion );		function position( event ) {			positionOption.of = event;			if ( tooltip.is( ":hidden" ) ) {				return;			}			tooltip.position( positionOption );		}		if ( this.options.track && event && /^mouse/.test( event.type ) ) {			this._on( this.document, {				mousemove: position			} );			// trigger once to override element-relative positioning			position( event );		} else {			tooltip.position( $.extend( {				of: target			}, this.options.position ) );		}		tooltip.hide();		this._show( tooltip, this.options.show );		// Handle tracking tooltips that are shown with a delay (#8644). As soon		// as the tooltip is visible, position the tooltip using the most recent		// event.		// Adds the check to add the timers only when both delay and track options are set (#14682)		if ( this.options.track && this.options.show && this.options.show.delay ) {			delayedShow = this.delayedShow = setInterval( function() {				if ( tooltip.is( ":visible" ) ) {					position( positionOption.of );					clearInterval( delayedShow );				}			}, 13 );		}		this._trigger( "open", event, { tooltip: tooltip } );	},	_registerCloseHandlers: function( event, target ) {		var events = {			keyup: function( event ) {				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {					var fakeEvent = $.Event( event );					fakeEvent.currentTarget = target[ 0 ];					this.close( fakeEvent, true );				}			}		};		// Only bind remove handler for delegated targets. Non-delegated		// tooltips will handle this in destroy.		if ( target[ 0 ] !!== this.element[ 0 ] ) {			events.remove = function() {				var targetElement = this._find( target );				if ( targetElement ) {					this._removeTooltip( targetElement.tooltip );				}			};		}		if ( !!event || event.type === "mouseover" ) {			events.mouseleave = "close";		}		if ( !!event || event.type === "focusin" ) {			events.focusout = "close";		}		this._on( true, target, events );	},	close: function( event ) {		var tooltip,			that = this,			target = $( event ? event.currentTarget : this.element ),			tooltipData = this._find( target );		// The tooltip may already be closed		if ( !!tooltipData ) {			// We set ui-tooltip-open immediately upon open (in open()), but only set the			// additional data once there''s actually content to show (in _open()). So even if the			// tooltip doesn''t have full data, we always remove ui-tooltip-open in case we''re in			// the period between open() and _open().			target.removeData( "ui-tooltip-open" );			return;		}		tooltip = tooltipData.tooltip;		// Disabling closes the tooltip, so we need to track when we''re closing		// to avoid an infinite loop in case the tooltip becomes disabled on close		if ( tooltipData.closing ) {			return;		}		// Clear the interval for delayed tracking tooltips		clearInterval( this.delayedShow );		// Only set title if we had one before (see comment in _open())		// If the title attribute has changed since open(), don''t restore		if ( target.data( "ui-tooltip-title" ) && !!target.attr( "title" ) ) {			target.attr( "title", target.data( "ui-tooltip-title" ) );		}		this._removeDescribedBy( target );		tooltipData.hiding = true;		tooltip.stop( true );		this._hide( tooltip, this.options.hide, function() {			that._removeTooltip( $( this ) );		} );		target.removeData( "ui-tooltip-open" );		this._off( target, "mouseleave focusout keyup" );		// Remove ''remove'' binding only on delegated targets		if ( target[ 0 ] !!== this.element[ 0 ] ) {			this._off( target, "remove" );		}		this._off( this.document, "mousemove" );		if ( event && event.type === "mouseleave" ) {			$.each( this.parents, function( id, parent ) {				$( parent.element ).attr( "title", parent.title );				delete that.parents[ id ];			} );		}		tooltipData.closing = true;		this._trigger( "close", event, { tooltip: tooltip } );		if ( !!tooltipData.hiding ) {			tooltipData.closing = false;		}	},	_tooltip: function( element ) {		var tooltip = $( "<div>" ).attr( "role", "tooltip" ),			content = $( "<div>" ).appendTo( tooltip ),			id = tooltip.uniqueId().attr( "id" );		this._addClass( content, "ui-tooltip-content" );		this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );		tooltip.appendTo( this._appendTo( element ) );		return this.tooltips[ id ] = {			element: element,			tooltip: tooltip		};	},	_find: function( target ) {		var id = target.data( "ui-tooltip-id" );		return id ? this.tooltips[ id ] : null;	},	_removeTooltip: function( tooltip ) {		// Clear the interval for delayed tracking tooltips		clearInterval( this.delayedShow );		tooltip.remove();		delete this.tooltips[ tooltip.attr( "id" ) ];	},	_appendTo: function( target ) {		var element = target.closest( ".ui-front, dialog" );		if ( !!element.length ) {			element = this.document[ 0 ].body;		}		return element;	},	_destroy: function() {		var that = this;		// Close open tooltips		$.each( this.tooltips, function( id, tooltipData ) {			// Delegate to close method to handle common cleanup			var event = $.Event( "blur" ),				element = tooltipData.element;			event.target = event.currentTarget = element[ 0 ];			that.close( event, true );			// Remove immediately; destroying an open tooltip doesn''t use the			// hide animation			$( "#" + id ).remove();			// Restore the title			if ( element.data( "ui-tooltip-title" ) ) {				// If the title attribute has changed since open(), don''t restore				if ( !!element.attr( "title" ) ) {					element.attr( "title", element.data( "ui-tooltip-title" ) );				}				element.removeData( "ui-tooltip-title" );			}		} );		this.liveRegion.remove();	}} );// DEPRECATED// TODO: Switch return back to widget declaration at top of file when this is removedif ( $.uiBackCompat !!== false ) {	// Backcompat for tooltipClass option	$.widget( "ui.tooltip", $.ui.tooltip, {		options: {			tooltipClass: null		},		_tooltip: function() {			var tooltipData = this._superApply( arguments );			if ( this.options.tooltipClass ) {				tooltipData.tooltip.addClass( this.options.tooltipClass );			}			return tooltipData;		}	} );}var widgetsTooltip = $.ui.tooltip;} );'! !!JQUiDevelopmentLibrary methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!selectorsToInclude	^ #(jQueryUiJs)! !JQBaseTheme subclass: #JQBlackTieTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQBlackTieTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'black-tie'! !JQBaseTheme subclass: #JQSunnyTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQSunnyTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'sunny'! !JQWidget subclass: #JQPosition	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Utility'!!JQPosition methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!at: aString	"Defines which position on the target element to align the positioned element against: 'horizontal vertical' alignment. See the my option for full details on possible values. Percentage offsets are relative to the target element."	self optionAt: 'at' put: aString! !!JQPosition methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!bgiframe: aBoolean	"Applies the bgiframe plugin when set to true. Only applies when bgiframe is actually loaded, nothing happens otherwise."	self optionAt: 'bgiframe' put: aBoolean! !!JQPosition methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!by: aFunction	"When specified the actual property setting is delegated to this callback. Receives a single parameter which is a hash of top and left values for the position that should be set."	self optionAt: 'by' put: aFunction! !!JQPosition methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!collision: aString	"When the positioned element overflows the window in some direction, move it to an alternative position. Similar to my and at, this accepts a single value or a pair for horizontal/vertical, eg. 'flip', 'fit', 'fit flip', 'fit none'. * ''flip'': to the opposite side and the collision detection is run again to see if it will fit. If it won't fit in either position, the center option should be used as a fall back. * ''fit'': so the element keeps in the desired direction, but is re-positioned so it fits. * ''none'': not do collision detection."	self optionAt: 'collision' put: aString! !!JQPosition methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!my: aString	"Defines which position on the element being positioned to align with the target element: 'horizontal vertical' alignment. A single value such as 'right' will be normalized to 'right center', 'top' will be normalized to 'center top' (following CSS convention). Acceptable horizontal values: 'left', 'center', 'right'. Acceptable vertical values: 'top', 'center', 'bottom'. Example: 'left top' or 'center center'. Each dimension can also contain offsets, in pixels or percent, e.g., 'right+10 top-25%'. Percentage offsets are relative to the element being positioned."	self optionAt: 'my' put: aString! !!JQPosition methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!of: aSelector	"Element to position against. You can use a browser event object contains pageX and pageY values. Example: '#top-menu'"	self optionAt: 'of' put: aSelector! !!JQPosition methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!using: aJSObject	"When specified, the actual property setting is delegated to this callback. Receives two parameters: The first is a hash of top and left values for the position that should be set and can be forwarded to .css() or .animate().The second provides feedback about the position and dimensions of both elements, as well as calculations to their relative position. Both target and element have these properties: element, left, top, width, height. In addition, there's horizontal, vertical and important, giving you twelve potential directions like { horizontal: 'center', vertical: 'left', important: 'horizontal' }"	self optionAt: 'using' put: aJSObject asFunction! !!JQPosition methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!within: aString	"Element to position within, affecting collision detection. If you provide a selector or jQuery object, the first matching element will be used."	self optionAt: 'within' put: aString! !!JQPosition methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'position'! !JQBaseTheme subclass: #JQMintChocTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQMintChocTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'mint-choc'! !JQWidget subclass: #JQAccordion	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQAccordion comment: 'An expandable/collapsible content pane. Applicable when content must be displayed within limited space.'!!JQAccordion methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!active: aSelectorOrElementOrjQueryOrBooleanOrNumber	"Selector for the active element. Set to false to display none at start. Needs collapsible: true."	self optionAt: 'active' put: aSelectorOrElementOrjQueryOrBooleanOrNumber! !!JQAccordion methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!animate: aBooleanOrString	"Choose your favorite animation, or disable them (set to false). In addition to the default, 'bounceslide' and all defined easing methods are supported ('bounceslide' requires UI Effects Core)."	self optionAt: 'animate' put: aBooleanOrString! !!JQAccordion methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!collapsible: aBoolean	"Whether all the sections can be closed at once. Allows collapsing the active section by the triggering event (click is the default)."	self optionAt: 'collapsible' put: aBoolean! !!JQAccordion methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!disabled: aBoolean	"Disables the accordion if set to true."	self optionAt: 'disabled' put: aBoolean! !!JQAccordion methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!event: aString	"The event on which to trigger the accordion."	self optionAt: 'event' put: aString! !!JQAccordion methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!header: aSelectorOrjQuery	"Selector for the header element."	self optionAt: 'header' put: aSelectorOrjQuery! !!JQAccordion methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!heightStyle: aBoolean	"Controls the height of the accordion and each panel. Possible values: 'auto': All panels will be set to the height of the tallest panel. 'fill': Expand to the available height based on the accordion's parent height. 'content': Each panel will be only as tall as its content."	self optionAt: 'heightStyle' put: aBoolean! !!JQAccordion methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!icons: anObject	"Icons to use for headers, matching an icon provided by the jQuery UI CSS Framework. Set to false to have no icons displayed."	self optionAt: 'icons' put: anObject! !!JQAccordion methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!beforeActivate: anObject	"Triggered directly before a panel is activated. Can be canceled to prevent the panel from activating. If the accordion is currently collapsed, ui.oldHeader and ui.oldPanel will be empty jQuery objects. If the accordion is collapsing, ui.newHeader and ui.newPanel will be empty jQuery objects."	self optionAt: 'beforeActivate' put: anObject asFunction! !!JQAccordion methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onActivate: anObject	"Triggered after a panel has been activated (after animation completes). If the accordion was previously collapsed, ui.oldHeader and ui.oldPanel will be empty jQuery objects. If the accordion is collapsing, ui.newHeader and ui.newPanel will be empty jQuery objects."	self optionAt: 'activate' put: anObject asFunction! !!JQAccordion methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onCreate: anObject	"Triggered when the accordion is created. If the accordion is collapsed, ui.header and ui.panel will be empty jQuery objects"	self optionAt: 'create' put: anObject asFunction! !!JQAccordion methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'accordion'! !!JQAccordion methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!refresh	"Process any headers and panels that were added or removed directly in the DOM and recompute the height of the accordion panels. Results depend on the content and the heightStyle option."		self action: 'refresh'! !JQBaseTheme subclass: #JQDotLuvTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQDotLuvTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'dot-luv'! !JQBaseTheme subclass: #JQUiLightnessTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQUiLightnessTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'ui-lightness'! !JQWidget subclass: #JQSlider	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!!JQSlider methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!animate: aBooleanOrStringOrNumber	"Whether to slide handle smoothly when user click outside handle on the bar. Will also accept a string representing one of the three predefined speeds ('slow', 'normal', or 'fast') or the number of milliseconds to run the animation (e.g. 1000)."	self optionAt: 'animate' put: aBooleanOrStringOrNumber! !!JQSlider methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!max: aNumber	"The maximum value of the slider."	self optionAt: 'max' put: aNumber! !!JQSlider methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!min: aNumber	"The minimum value of the slider."	self optionAt: 'min' put: aNumber! !!JQSlider methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!orientation: aString	"This option determines whether the slider has the min at the left, the max at the right or the min at the bottom, the max at the top. Possible values: 'horizontal', 'vertical'."	self optionAt: 'orientation' put: aString! !!JQSlider methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!range: aBooleanOrString	"If set to true, the slider will detect if you have two handles and create a stylable range element between these two. Two other possible values are 'min' and 'max'. A min range goes from the slider min to one handle. A max range goes from one handle to the slider max."	self optionAt: 'range' put: aBooleanOrString! !!JQSlider methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!step: aNumber	"Determines the size or amount of each interval or step the slider takes between min and max. The full specified value range of the slider (max - min) needs to be evenly divisible by the step."	self optionAt: 'step' put: aNumber! !!JQSlider methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!value: aNumber	"Determines the value of the slider, if there's only one handle. If there is more than one handle, determines the value of the first handle."	self optionAt: 'value' put: aNumber! !!JQSlider methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!values: anArray	"This option can be used to specify multiple handles. If range is set to true, the length of 'values' should be 2."	self optionAt: 'values' put: anArray! !!JQSlider methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!getValue	"Gets the value of the slider. For single handle sliders."	self action: 'value'! !!JQSlider methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!getValueAt: anInteger	"Gets the values of the slider. For multiple handle or range sliders."	self action: 'values' arguments: (Array with: anInteger)! !!JQSlider methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!setValue: aNumber	"Sets the value of the slider. For single handle sliders."	self action: 'value' arguments: (Array with: aNumber)! !!JQSlider methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!setValue: aNumber at: anInteger	"Sets the values of the slider. For multiple handle or range sliders."	self action: 'values' arguments: (Array with: aNumber with: anInteger)! !!JQSlider methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'slider'! !!JQSlider methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onChange: anObject	"This event is triggered on slide stop, or if the value is changed programmatically (by the value method). Takes arguments event and ui. Use event.orginalEvent to detect whether the value changed by mouse, keyboard, or programmatically. Use ui.value (single-handled sliders) to obtain the value of the current handle, $(this).slider('values', index) to get another handle's value."	self optionAt: 'change' put: anObject asFunction! !!JQSlider methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onSlide: anObject	"This event is triggered on every mouse move during slide. Use ui.value (single-handled sliders) to obtain the value of the current handle, $(..).slider('value', index) to get another handles' value. Return false in order to prevent a slide, based on ui.value."	self optionAt: 'slide' put: anObject asFunction! !!JQSlider methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStart: anObject	"This event is triggered when the user starts sliding."	self optionAt: 'start' put: anObject asFunction! !!JQSlider methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStop: anObject	"This event is triggered when the user stops sliding."	self optionAt: 'stop' put: anObject asFunction! !JQBaseTheme subclass: #JQSmoothnessTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQSmoothnessTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'smoothness'! !JQWidget subclass: #JQDialog	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQDialog comment: 'Make the selected elements Dialog boxes.'!!JQDialog methodsFor: 'convenience' stamp: '1/8/2026 11:26:12'!addButton: aString do: anObject 	"Adds a new button with the label aString and the action anObject."	(self options 		at: 'buttons'		ifAbsentPut: [ GRSmallDictionary2 new ]) 		at: aString		put: anObject asFunction! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!appendTo: aString	"Which element the dialog (and overlay, if modal) should be appended to."	self optionAt: 'appendTo' put: aString! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!autoOpen: aBoolean	"When 'autoOpen' is 'true' the dialog will open automatically when 'dialog' is called. If 'false' it will stay hidden until '.dialog('open')' is called on it."	self optionAt: 'autoOpen' put: aBoolean! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!buttons: aDictionary	"Specifies which buttons should be displayed on the dialog. The property key is the text of the button. The value is the callback function for when the button is clicked. The context of the callback is the dialog element; if you need access to the button, it is available as the target of the event object."	self optionAt: 'buttons' put: aDictionary! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!closeOnEscape: aBoolean	"Specifies whether the dialog should close when it has focus and the user presses the esacpe (ESC) key."	self optionAt: 'closeOnEscape' put: aBoolean! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!closeText: aString	"Specifies the text for the close button. Note that the close text is visibly hidden when using a standard theme."	self optionAt: 'closeText' put: aString! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!dialogClass: aString	"The specified class name(s) will be added to the dialog, for additional theming."	self optionAt: 'dialogClass' put: aString! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!draggable: aBoolean	"If set to true, the dialog will be draggable will be draggable by the titlebar."	self optionAt: 'draggable' put: aBoolean! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!height: aNumber	"The height of the dialog, in pixels. Specifying 'auto' is also supported to make the dialog adjust based on its content."	self optionAt: 'height' put: aNumber! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!hide: aStringOrObject	"The effect to be used when the dialog is closed."	self optionAt: 'hide' put: aStringOrObject! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!maxHeight: aNumber	"The maximum height to which the dialog can be resized, in pixels."	self optionAt: 'maxHeight' put: aNumber! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!maxWidth: aNumber	"The maximum width to which the dialog can be resized, in pixels."	self optionAt: 'maxWidth' put: aNumber! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!minHeight: aNumber	"The minimum height to which the dialog can be resized, in pixels."	self optionAt: 'minHeight' put: aNumber! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!minWidth: aNumber	"The minimum width to which the dialog can be resized, in pixels."	self optionAt: 'minWidth' put: aNumber! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!modal: aBoolean	"If set to true, the dialog will have modal behavior; other items on the page will be disabled (i.e. cannot be interacted with). Modal dialogs create an overlay below the dialog but above other page elements."	self optionAt: 'modal' put: aBoolean! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!position: aStringOrArray	"Specifies where the dialog should be displayed. See details at http://api.jqueryui.com/dialog/#option-position"	self optionAt: 'position' put: aStringOrArray! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!resizable: aBoolean	"If set to true, the dialog will be resizeable."	self optionAt: 'resizable' put: aBoolean! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!show: aStringOrObject	"The effect to be used when the dialog is opened."	self optionAt: 'show' put: aStringOrObject! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!title: aString	"Specifies the title of the dialog. Any valid HTML may be set as the title. The title can also be specified by the title attribute on the dialog source element."	self optionAt: 'title' put: aString! !!JQDialog methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!width: aNumber	"The width of the dialog, in pixels."	self optionAt: 'width' put: aNumber! !!JQDialog methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!close	"Closes the specified dialog boxes."		self action: 'close'! !!JQDialog methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!isOpen	"Returns true if the dialog is currently open."		self action: 'isOpen'! !!JQDialog methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!moveToTop	"Moves the speicifed dialog on top of the dialogs stack."		self action: 'moveToTop'! !!JQDialog methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!open	"Opens the specified dialog boxes."		self action: 'open'! !!JQDialog methodsFor: 'callbacks' stamp: '1/8/2026 11:26:12'!html: aBlock	"Conveniance method that takes a block that is used to render the contents of the window when being opened."	self autoOpen: false.	self onOpen: (self owner copy load		html: aBlock)! !!JQDialog methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'dialog'! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onBeforeClose: anObject	"This event is triggered when a dialog attempts to close. If the beforeClose event handler (callback function) returns false, the close will be prevented."	self optionAt: 'beforeClose' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onClose: anObject	"This event is triggered when the dialog is closed."	self optionAt: 'close' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onDrag: anObject	"This event is triggered when the dialog is dragged."	self optionAt: 'drag' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onDragStart: anObject	"This event is triggered at the beginning of the dialog being dragged."	self optionAt: 'dragStart' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onDragStop: anObject	"This event is triggered after the dialog has been dragged."	self optionAt: 'dragStop' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onFocus: anObject	"This event is triggered when the dialog gains focus."	self optionAt: 'focus' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onOpen: anObject	"This event is triggered when dialog is opened."	self optionAt: 'open' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onResize: anObject	"This event is triggered when the dialog is resized. [http://www.jsfiddle.net/Jp7TM/18/ demo]"	self optionAt: 'resize' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onResizeStart: anObject	"This event is triggered at the beginning of the dialog being resized."	self optionAt: 'resizeStart' put: anObject asFunction! !!JQDialog methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onResizeStop: anObject	"This event is triggered after the dialog has been resized."	self optionAt: 'resizeStop' put: anObject asFunction! !JQBaseTheme subclass: #JQHotSneaksTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQHotSneaksTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'hot-sneaks'! !WAFileLibrary subclass: #JQUiGoogleLibrary	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQUiGoogleLibrary methodsFor: 'updating' stamp: '1/8/2026 11:26:12'!updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot javascript		url: 'http://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js'! !JQBaseTheme subclass: #JQBlitzerTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQBlitzerTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'blitzer'! !JQBaseTheme subclass: #JQSwankyPurseTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQSwankyPurseTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'swanky-purse'! !JQWidget subclass: #JQProgressbar	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQProgressbar comment: 'Make the selected elements progressbar.'!!JQProgressbar methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!getValue	"This method gets the current value of the progressbar."	self action: 'value'! !!JQProgressbar methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!setValue: aNumber	"This method sets the current value of the progressbar."	self action: 'value' arguments: (Array with: aNumber)! !!JQProgressbar methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'progressbar'! !!JQProgressbar methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onChange: anObject	"This event is triggered when the value of the progressbar changes."	self optionAt: 'change' put: anObject asFunction! !!JQProgressbar methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!value: aNumber	"The value of the progressbar."	self optionAt: 'value' put: aNumber! !JQBaseTheme subclass: #JQOvercastTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQOvercastTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'overcast'! !JQWidget subclass: #JQAutocomplete	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Widgets'!JQAutocomplete comment: 'Autocomplete, added to an input field, enables users to quickly find and select from a pre-populated list of values as they type, leveraging searching and filtering.'!!JQAutocomplete methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!appendTo: aSelector	"Which element the menu should be appended to."	self optionAt: 'appendTo' put: aSelector! !!JQAutocomplete methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!autoFocus: aBoolean	"If set to true the first item will be automatically focused."	self optionAt: 'autoFocus' put: aBoolean! !!JQAutocomplete methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!delay: anInteger	"The delay in milliseconds the Autocomplete waits after a keystroke to activate itself. A zero-delay makes sense for local data (more responsive), but can produce a lot of load for remote data, while being less responsive."	self optionAt: 'delay' put: anInteger! !!JQAutocomplete methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!minLength: anInteger	"The minimum number of characters a user has to type before the Autocomplete activates. Zero is useful for local data with just a few items. Should be increased when there are a lot of items, where a single character would match a few thousand items."	self optionAt: 'minLength' put: anInteger! !!JQAutocomplete methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!position: anObject	"Identifies the position of the Autocomplete widget in relation to the associated input element. The 'of' option defaults to the input element, but you can specify another element to position against. See more details at http://api.jqueryui.com/autocomplete/#option-position"	self optionAt: 'position' put: anObject! !!JQAutocomplete methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!source: aStringOrArrayOrCallback	"Defines the data to use, must be specified. See Overview section for more details, and look at the various demos."	self optionAt: 'source' put: aStringOrArrayOrCallback! !!JQAutocomplete methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!close	"Close the autocomplete menu. Useful in combination with the search method, to close the open menu."		self action: 'close' arguments: #()! !!JQAutocomplete methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!search: aString	"Triggers a search event, which, when data is available, then will display the suggestions; can be used by a selectbox-like button to open the suggestions when clicked. If no value argument is specified, the current input's value is used. Can be called with an empty string and minLength: 0 to display all items."		self action: 'search' arguments: (Array with: aString)! !!JQAutocomplete methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'autocomplete'! !!JQAutocomplete methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onChange: anObject	"Triggered when the field is blurred, if the value has changed; ui.item refers to the selected item."	self optionAt: 'change' put: anObject asFunction! !!JQAutocomplete methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onClose: anObject	"When the list is hidden - doesn't have to occur together with a change."	self optionAt: 'close' put: anObject asFunction! !!JQAutocomplete methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onFocus: anObject	"Before focus is moved to an item (not selecting), ui.item refers to the focused item. The default action of focus is to replace the text field's value with the value of the focused item, though only if the focus event was triggered by a keyboard interaction. Canceling this event prevents the value from being updated, but does not prevent the menu item from being focused."	self optionAt: 'focus' put: anObject asFunction! !!JQAutocomplete methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onOpen: anObject	"Triggered when the suggestion menu is opened."	self optionAt: 'open' put: anObject asFunction! !!JQAutocomplete methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onResponse: anObject	"Triggered after a search completes, before the menu is shown. Useful for local manipulation of suggestion data, where a custom source option callback is not required. This event is always triggered when a search completes, even if the menu will not be shown because there are no results or the Autocomplete is disabled."	self optionAt: 'response' put: anObject asFunction! !!JQAutocomplete methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onSearch: anObject	"Before a request (source-option) is started, after minLength and delay are met. Can be canceled (return false), then no request will be started and no items suggested."	self optionAt: 'search' put: anObject asFunction! !!JQAutocomplete methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onSelect: anObject	"Triggered when an item is selected from the menu; ui.item refers to the selected item. The default action of select is to replace the text field's value with the value of the selected item. Canceling this event prevents the value from being updated, but does not prevent the menu from closing."	self optionAt: 'select' put: anObject asFunction! !!JQAutocomplete methodsFor: 'convenience' stamp: '1/8/2026 11:26:12'!search: aSearchBlock callback: aCallbackBlock	self search: aSearchBlock labels: [ :each | each greaseString ] callback: aCallbackBlock! !!JQAutocomplete methodsFor: 'convenience' stamp: '1/8/2026 11:26:12'!search: aSearchBlock labels: aLabelsBlock callback: aCallbackBlock	"A one argument block aSearchBlock that will be evaluated with the term the user currently typed. The block is expected to answer a collection of objects. aLabelsBlock should answer a string label to be displayed for each object. aCallbackBlock is evaluated with the selected object and an ajax script to be performed."		| term mapping |	mapping := IdentityDictionary new.	"Use a WAValueHolder because assigments to temps don't work in GemStone.	http://code.google.com/p/glassdb/issues/detail?id=221"	term := WAValueHolder new.	self source: ((self jQuery getJson		callback: [ :value | term contents: value ]		value: (JSStream on: 'request.term');		json: [ :json | 			json array: [				(aSearchBlock value: term contents) do: [ :object | 					json object: [ 						json 							key: 'label' value: (aLabelsBlock value: object);							key: 'index' value: (mapping at: object ifAbsentPut: [ mapping size + 1 ]) ] ] ] ];		onSuccess: 'response(arguments[0])'; 		dataType: 'jsonp') asFunction: #('request' 'response')).	self onSelect: ((self jQuery ajax		callback: [ :value | term contents: value greaseInteger ] 		value: (JSStream on: 'ui.item.index');		script: [ :script |			mapping keysAndValuesDo: [ :object :value |				value = term contents					ifTrue: [ aCallbackBlock value: object value: script ] ] ])		asFunction: #('event' 'ui'))! !!JQAutocomplete methodsFor: 'convenience' stamp: '1/8/2026 11:26:12'!sourceCallback: aOneArgumentBlock	"A one argument block that will be evaluated with the term the user currently typed. The block is expected to answer a collection of objects."		| term |	"assignments to temps don't work in GS 2.4	http://code.google.com/p/glassdb/issues/detail?id=152"	term := WAValueHolder new.	self source: ((self jQuery getJson		json: [ :json | json value: (aOneArgumentBlock value: term contents) ];		callback: [ :value | term contents: value ] value: (JSStream on: 'request.term');		onSuccess: 'response(arguments[0])'; 		dataType: 'jsonp') asFunction: #('request' 'response'))! !JQBaseTheme subclass: #JQEggplantTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQEggplantTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'eggplant'! !JQBaseTheme subclass: #JQVaderTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQVaderTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'vader'! !JQWidget subclass: #JQSortable	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Interaction'!JQSortable comment: 'Creates new sortable on the nodeset supplied by the query.'!!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!appendTo: aString	"Defines where the helper that moves with the mouse is being appended to during the drag (for example, to resolve overlap/zIndex issues)."	self optionAt: 'appendTo' put: aString! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!axis: aString	"If defined, the items can be dragged only horizontally or vertically. Possible values:'x', 'y'."	self optionAt: 'axis' put: aString! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!cancel: aSelector	"Prevents sorting if you start on elements matching the selector."	self optionAt: 'cancel' put: aSelector! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!connectWith: aSelector	"Takes a jQuery selector with items that also have sortables applied. If used, the sortable is now connected to the other one-way, so you can drag from this sortable to the other."	self optionAt: 'connectWith' put: aSelector! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!containment: anElementOrStringOrSelector	"Constrains dragging to within the bounds of the specified element - can be a DOM element, 'parent', 'document', 'window', or a jQuery selector. Note: the element specified for containment must have a calculated width and height (though it need not be explicit), so for example, if you have float:left sortable children and specify containment:'parent' be sure to have float:left on the sortable/parent container as well or it will have height: 0, causing undefined behavior."	self optionAt: 'containment' put: anElementOrStringOrSelector! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!cursor: aString	"Defines the cursor that is being shown while sorting."	self optionAt: 'cursor' put: aString! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!cursorAt: anObject	"Moves the sorting element or helper so the cursor always appears to drag from the same position. Coordinates can be given as a hash using a combination of one or two keys: { top, left, right, bottom }."	self optionAt: 'cursorAt' put: anObject! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!delay: anInteger	"Time in milliseconds to define when the sorting should start. It helps preventing unwanted drags when clicking on an element."	self optionAt: 'delay' put: anInteger! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!distance: anInteger	"Tolerance, in pixels, for when sorting should start. If specified, sorting will not start until after mouse is dragged beyond distance. Can be used to allow for clicks on elements within a handle."	self optionAt: 'distance' put: anInteger! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!dropOnEmpty: aBoolean	"If false items from this sortable can't be dropped to an empty linked sortable."	self optionAt: 'dropOnEmpty' put: aBoolean! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!forceHelperSize: aBoolean	"If true, forces the helper to have a size."	self optionAt: 'forceHelperSize' put: aBoolean! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!forcePlaceholderSize: aBoolean	"If true, forces the placeholder to have a size."	self optionAt: 'forcePlaceholderSize' put: aBoolean! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!grid: anArray	"Snaps the sorting element or helper to a grid, every x and y pixels. Array values: [x, y]"	self optionAt: 'grid' put: anArray! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!handle: aSelectorOrElement	"Restricts sort start click to the specified element."	self optionAt: 'handle' put: aSelectorOrElement! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!helper: aStringOrFunction	"Allows for a helper element to be used for dragging display. The supplied function receives the event and the element being sorted, and should return a DOMElement to be used as a custom proxy helper. Possible values: 'original', 'clone'"	self optionAt: 'helper' put: aStringOrFunction! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!items: aSelector	"Specifies which items inside the element should be sortable."	self optionAt: 'items' put: aSelector! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!opacity: aFloat	"Defines the opacity of the helper while sorting. From 0.01 to 1"	self optionAt: 'opacity' put: aFloat! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!placeholder: aString	"Class that gets applied to the otherwise white space."	self optionAt: 'placeholder' put: aString! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!revert: aBooleanInteger	"If set to true, the item will be reverted to its new DOM position with a smooth animation. Optionally, it can also be set to a number that controls the duration of the animation in ms."	self optionAt: 'revert' put: aBooleanInteger! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!scroll: aBoolean	"If set to true, the page scrolls when coming to an edge."	self optionAt: 'scroll' put: aBoolean! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!scrollSensitivity: anInteger	"Defines how near the mouse must be to an edge to start scrolling."	self optionAt: 'scrollSensitivity' put: anInteger! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!scrollSpeed: anInteger	"The speed at which the window should scroll once the mouse pointer gets within the scrollSensitivity distance."	self optionAt: 'scrollSpeed' put: anInteger! !!JQSortable methodsFor: 'options-generated' stamp: '1/8/2026 11:26:12'!tolerance: aString	"This is the way the reordering behaves during drag. Possible values: 'intersect', 'pointer'. In some setups, 'pointer' is more natural.  ''intersect'': draggable overlaps the droppable at least 50% ''pointer'': mouse pointer overlaps the droppable "	self optionAt: 'tolerance' put: aString! !!JQSortable methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!cancel	"Cancels a change in the current sortable and reverts it back to how it was before the current sort started. Useful in the stop and receive callback functions."		self action: 'cancel'! !!JQSortable methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!refresh	"Refresh the sortable items."		self action: 'refresh'! !!JQSortable methodsFor: 'actions' stamp: '1/8/2026 11:26:12'!refreshPositions	"Refresh the cached positions of the sortables' items."		self action: 'refreshPositions'! !!JQSortable methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!method	^ 'sortable'! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onActivate: anObject	"This event is triggered when using connected lists, every connected list on drag start receives it."	self optionAt: 'activate' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onBeforeStop: anObject	"This event is triggered when sorting stops, but when the placeholder/helper is still available."	self optionAt: 'beforeStop' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onChange: anObject	"This event is triggered during sorting, but only when the DOM position has changed."	self optionAt: 'change' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onDeactivate: anObject	"This event is triggered when sorting was stopped, is propagated to all possible connected lists."	self optionAt: 'deactivate' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onOut: anObject	"This event is triggered when a sortable item is moved away from a connected list."	self optionAt: 'out' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onOver: anObject	"This event is triggered when a sortable item is moved into a connected list."	self optionAt: 'over' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onReceive: anObject	"This event is triggered when a connected sortable list has received an item from another list."	self optionAt: 'receive' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onRemove: anObject	"This event is triggered when a sortable item has been dragged out from the list and into another."	self optionAt: 'remove' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onSort: anObject	"This event is triggered during sorting."	self optionAt: 'sort' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStart: anObject	"This event is triggered when sorting starts."	self optionAt: 'start' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onStop: anObject	"This event is triggered when sorting has stopped."	self optionAt: 'stop' put: anObject asFunction! !!JQSortable methodsFor: 'events-generated' stamp: '1/8/2026 11:26:12'!onUpdate: anObject	"This event is triggered when the user stopped sorting and the DOM position has changed."	self optionAt: 'update' put: anObject asFunction! !JQBaseTheme subclass: #JQSouthStreetTheme	instanceVariableNames: ''	classVariableNames: ''	package: 'JQuery-UI-Libraries'!!JQSouthStreetTheme methodsFor: 'accessing' stamp: '1/8/2026 11:26:12'!themeName	^ 'south-street'! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.043813 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!button	"Make the selected input elements buttons."		^ self create: JQButton! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.044278 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!droppable	"Creates new droppables on the nodeset supplied by the query."		^ self create: JQDroppable! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.044542 pm'!!JQueryInstance methodsFor: '*JQuery-UI-css' stamp: '1/8/2026 11:26:12'!innerHeight: anInteger	"Set the height for the elements in the set of matched elements, including padding but not border."		self call: 'innerHeight' with: anInteger! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.044754 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!innerWidth: anInteger	"Set the width for the elements in the set of matched elements, including padding but not border."		self call: 'innerWidth' with: anInteger! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.044966 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!switchClass: firstClassString to: secondClassString duration: aDurationOrString	"Switches from the class defined in the first argument to the class defined as second argument, using a optional transition."		self call: 'switchClass' with: firstClassString with: secondClassString with: aDurationOrString! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.04518 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!dialog	"Make the selected elements Dialog boxes."		^ self create: JQDialog! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.045384 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!datepicker	"The method that you use to create a new date picker."		^ self create: JQDatepicker! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.045587 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!buttonset	"Group buttons which should be always applied for radio buttons."	^ self call: 'buttonset'! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.04579 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!toggleClass: aString duration: aDurationOrString	"Adds the specified class if it is not present, removes the specified class if it is present, using a optional transition."		self call: 'toggleClass' with: aString with: aDurationOrString! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.045997 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!progressbar	"Make the selected elements progressbar."		^ self create: JQProgressbar! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.0462 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!tabs	"The method that you use to create a new tabs interface."		^ self create: JQTabs! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.046403 pm'!!JQueryInstance methodsFor: '*JQuery-UI-utilities' stamp: '1/8/2026 11:26:12'!positioned	"Make the selected elements positioned. Note: this method is called 'positioned' (contrary to the jQueryUI implementation where it is called 'position') to avoid a conflict in Smalltalk."		^ self create: JQPosition! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.046624 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!outerHeight: anInteger	"Set the height for the elements in the set of matched elements, including padding and border."		self call: 'outerHeight' with: anInteger! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.046829 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!sortable	"Creates new sortable on the nodeset supplied by the query."		^ self create: JQSortable! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.047045 pm'!!JQueryInstance methodsFor: '*JQuery-UI-interactions' stamp: '1/8/2026 11:26:12'!draggable	"Creates new draggables on the nodeset supplied by the query."		^ self create: JQDraggable! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.047263 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!outerWidth: anInteger	"Set the width for the elements in the set of matched elements, including padding and border."		self call: 'outerWidth' with: anInteger! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.047484 pm'!!JQueryInstance methodsFor: '*JQuery-UI-widgets' stamp: '1/8/2026 11:26:12'!accordion	"Make the selected elements Accordion widgets."		^ self create: JQAccordion! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.047706 pm'!!JQueryInstance methodsFor: '*JQuery-UI-transitions' stamp: '1/8/2026 11:26:12'!addClass: aString duration: aDurationOrString	"Adds the specified class to each of the set of matched elements with a optional transition between the states."		self call: 'addClass' with: aString with: aDurationOrString! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.047965 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!autocomplete	"Make the selected input elements autocomplete."		^ self create: JQAutocomplete! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.048167 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!selectable	"Creates new selectable on the nodeset supplied by the query."		^ self create: JQSelectable! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.048372 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!effect	"This is the core dependency of the effects of jQuery UI."		^ self create: JQEffect! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.048576 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!removeClass: aString duration: aDurationOrString	"Removes the specified class from the set of matched elements with a optional transition."		self call: 'removeClass' with: aString with: aDurationOrString! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.048786 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!slider	"Makes a slider from the nodeset supplied by the query."		^ self create: JQSlider! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.048995 pm'!!JQueryInstance methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!resizable	"Creates new resizables on the nodeset supplied by the query."		^ self create: JQResizable! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.049203 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!callbackResizable: aBlock	"Trigger aBlock with the resizeable event object."		self callback: aBlock forEvent: #(		(passenger helper "the helper element")		(position originalPosition "position before resizing started") 		(position position "current position")		(size originalSize "size before resizing started")		(size size "current size"))! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.049398 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!callbackDraggable: aBlock	"Trigger aBlock with the draggable event object."		self callback: aBlock forEvent: #(		(passenger helper "the helper that's being dragged")		(position position "current position of the helper")		(position offset "current absolute position of the helper"))! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.049579 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!callbackSortable: aBlock	"Trigger aBlock with the selectable event object."		self callback: aBlock forEvent: #(		(passenger helper "the current helper element")		(passenger item " the current dragged element")		(passenger placeholder "the placeholder")		(passenger sender "the sortable where the item comes from")		(position position "current position of the helper")		(position offset "current absolute position of the helper"))! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.049767 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!callbackSlider: aBlock	"Trigger aBlock with the slider event object."		self callback: aBlock forEvent: #(		(passenger handle "the current focused handle")		(number value "the current handle's value"))! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.049951 pm'!!JQAjax methodsFor: '*JQuery-UI-private' stamp: '1/8/2026 11:26:12'!callback: aBlock forEvent: anArraySpec	self 		callback: [ :value | aBlock value: (self smalltalkForEvent: anArraySpec value: value) ]		value: (self javascriptForEvent: anArraySpec)! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.050146 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!smalltalkForEvent: anArraySpec value: aString	| stream result |	stream := aString readStream.	result := GRSmallDictionary2 new.	anArraySpec do: [ :spec |		(spec first = #number)			ifTrue: [ result at: spec last put: (stream upTo: $,) greaseInteger ].		(spec first = #string)				ifTrue: [ result at: spec last put: (stream upTo: $,) ].		(spec first = #passenger)			ifTrue: [ result at: spec last put: (self renderContext callbacks passengerAt: (stream upTo: $,)) ].		(spec first = #position)			ifTrue: [ result at: spec last put: (GRSmallDictionary2 new add: 'top' -> (stream upTo: $,) greaseInteger; add: 'left' -> (stream upTo: $,) greaseInteger; yourself) ].		(spec first = #size)			ifTrue: [ result at: spec last put: (stream upTo: $,) greaseInteger @ (stream upTo: $,) greaseInteger ] ].	^ result! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.050345 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!callback: aBlock passengers: aQuery	"Trigger the callback aBlock with the passengers of aQuery. Nodes that have no passenger are ignored."	self		callback: [ :value | 			aBlock value: ((GRPlatform subStringsIn: value value splitBy: $,				collect: [ :each | self renderContext callbacks passengerAt: each ])				reject: [ :each | each isNil ]) ]		value: (JSStream on: JQuery functionName , '.map(' , aQuery greaseString , '.get(),function(each){return each.id}).join(",")')! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.050531 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!callbackDroppable: aBlock	"Trigger aBlock with the droppable event object."		self callback: aBlock forEvent: #(		(passenger draggable "current draggable element")		(passenger helper "current draggable helper")		(position position "current position of the draggable helper")		(position offset "current absolute position of the draggable helper"))! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.050716 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!callbackTabs: aBlock	"Trigger aBlock with the tabs event object."		self callback: aBlock forEvent: #(		(passenger tab "anchor element of the selected (clicked) tab")		(passenger panel "element, that contains the selected/clicked tab contents")		(number index "zero-based index of the selected (clicked) tab"))! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.050908 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!callbackAccordion: aBlock	"Trigger aBlock with the accordion event object."		self callback: aBlock forEvent: #(		(passenger newHeader "activated header")		(passenger oldHeader "previous header")		(passenger newContent "activated content")		(passenger oldContent "previous content"))! !'From Pharo13.1.0SNAPSHOT of 17 December 2025 [Build information: Pharo-13.1.0+SNAPSHOT.build.720.sha.6d4e07567e4d6500945a1f2476a81c3abb4426b1 (64 Bit)] on 13 January 2026 at 12:19:20.051091 pm'!!JQAjax methodsFor: '*JQuery-UI' stamp: '1/8/2026 11:26:12'!javascriptForEvent: anArraySpec	| stream |	stream := JSStream new.	anArraySpec		do: [ :spec |			(#(#number string) includes: spec first)				ifTrue: [ stream nextPutAll: 'arguments[1].'; nextPutAll: spec second ].			(spec first = #passenger)				ifTrue: [ stream nextPutAll: JQuery functionName; nextPut: $(; nextPutAll: 'arguments[1].'; nextPutAll: spec second; nextPutAll: ').attr("id")' ].			(spec first = #position)				ifTrue: [ stream nextPutAll: 'arguments[1].'; nextPutAll: spec second; nextPutAll: '.top'; nextPutAll: '+","+'; nextPutAll: 'arguments[1].'; nextPutAll: spec second; nextPutAll: '.left' ].			(spec first = #size)				ifTrue: [ stream nextPutAll: 'arguments[1].'; nextPutAll: spec second; nextPutAll: '.width'; nextPutAll: '+","+'; nextPutAll: 'arguments[1].'; nextPutAll: spec second; nextPutAll: '.height' ] ]		separatedBy: [ stream nextPutAll: '+","+' ].	^ stream! !